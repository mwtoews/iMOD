!!  Copyright (C) Stichting Deltares, 2005-2018.
!!
!!  This file is part of iMOD.
!!
!!  This program is free software: you can redistribute it and/or modify
!!  it under the terms of the GNU General Public License as published by
!!  the Free Software Foundation, either version 3 of the License, or
!!  (at your option) any later version.
!!
!!  This program is distributed in the hope that it will be useful,
!!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!  GNU General Public License for more details.
!!
!!  You should have received a copy of the GNU General Public License
!!  along with this program.  If not, see <http://www.gnu.org/licenses/>.
!!
!!  Contact: imod.support@deltares.nl
!!  Stichting Deltares
!!  P.O. Box 177
!!  2600 MH Delft, The Netherlands.
!!
MODULE MOD_QKSORT

USE IMODVAR, ONLY : DP_KIND,SP_KIND

CONTAINS

 !###====================================================
 SUBROUTINE QKSORT(N,V1,V2,V3,V4,V5,V6)
 !###====================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: N
 REAL(KIND=DP_KIND),INTENT(INOUT),DIMENSION(N) :: V1
 REAL(KIND=DP_KIND),INTENT(INOUT),DIMENSION(N),OPTIONAL :: V2,V3,V4,V5,V6
 INTEGER :: I,M
 REAL(KIND=DP_KIND),ALLOCATABLE,DIMENSION(:,:) :: ARR

 M=1; IF(PRESENT(V2))M=M+1; IF(PRESENT(V3))M=M+1; IF(PRESENT(V4))M=M+1; IF(PRESENT(V5))M=M+1; IF(PRESENT(V6))M=M+1
 ALLOCATE(ARR(N,M))

 !## copy first vector in array
 DO I=1,N; ARR(I,1)=V1(I); ENDDO
 
 IF(M.EQ.1)THEN

  CALL QKSORT_SGL(N,ARR(:,1))
  DO I=1,N; V1(I)=ARR(I,1); ENDDO

 ELSE

  M=1
  IF(PRESENT(V2))THEN; M=M+1; DO I=1,N; ARR(I,M)=V2(I); ENDDO; ENDIF
  IF(PRESENT(V3))THEN; M=M+1; DO I=1,N; ARR(I,M)=V3(I); ENDDO; ENDIF
  IF(PRESENT(V4))THEN; M=M+1; DO I=1,N; ARR(I,M)=V4(I); ENDDO; ENDIF
  IF(PRESENT(V5))THEN; M=M+1; DO I=1,N; ARR(I,M)=V5(I); ENDDO; ENDIF
  IF(PRESENT(V6))THEN; M=M+1; DO I=1,N; ARR(I,M)=V6(I); ENDDO; ENDIF
  CALL QKSORT_DBL(N,ARR)
  M=1; DO I=1,N; V1(I)=ARR(I,M); ENDDO
  IF(PRESENT(V2))THEN; M=M+1; DO I=1,N; V2(I)=ARR(I,M); ENDDO; ENDIF
  IF(PRESENT(V3))THEN; M=M+1; DO I=1,N; V3(I)=ARR(I,M); ENDDO; ENDIF
  IF(PRESENT(V4))THEN; M=M+1; DO I=1,N; V4(I)=ARR(I,M); ENDDO; ENDIF
  IF(PRESENT(V5))THEN; M=M+1; DO I=1,N; V5(I)=ARR(I,M); ENDDO; ENDIF
  IF(PRESENT(V6))THEN; M=M+1; DO I=1,N; V6(I)=ARR(I,M); ENDDO; ENDIF

 ENDIF
  
 DEALLOCATE(ARR)

 END SUBROUTINE QKSORT

 !###====================================================
 SUBROUTINE QKSORT_INT(N,V1,V2,V3,V4,V5,V6)
 !###====================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: N
 INTEGER(KIND=SP_KIND),INTENT(INOUT),DIMENSION(:) :: V1
 INTEGER(KIND=SP_KIND),INTENT(INOUT),DIMENSION(:),OPTIONAL :: V2,V3,V4,V5,V6
 INTEGER :: I,M
 REAL(KIND=DP_KIND),ALLOCATABLE,DIMENSION(:,:) :: ARR

 M=1; IF(PRESENT(V2))M=M+1; IF(PRESENT(V3))M=M+1; IF(PRESENT(V4))M=M+1; IF(PRESENT(V5))M=M+1; IF(PRESENT(V6))M=M+1
 ALLOCATE(ARR(N,M)); M=1; DO I=1,N; ARR(I,M)=REAL(V1(I),8); ENDDO

 IF(M.EQ.1)THEN
  CALL QKSORT_SGL(N,ARR(:,1))
  M=1; DO I=1,N; V1(I)=INT(ARR(I,M),4); ENDDO
 ELSE
  IF(PRESENT(V2))THEN; M=M+1; DO I=1,N; ARR(I,M)=REAL(V2(I),8); ENDDO; ENDIF
  IF(PRESENT(V3))THEN; M=M+1; DO I=1,N; ARR(I,M)=REAL(V3(I),8); ENDDO; ENDIF
  IF(PRESENT(V4))THEN; M=M+1; DO I=1,N; ARR(I,M)=REAL(V4(I),8); ENDDO; ENDIF
  IF(PRESENT(V5))THEN; M=M+1; DO I=1,N; ARR(I,M)=REAL(V5(I),8); ENDDO; ENDIF
  IF(PRESENT(V6))THEN; M=M+1; DO I=1,N; ARR(I,M)=REAL(V6(I),8); ENDDO; ENDIF
  CALL QKSORT_DBL(N,ARR)
  M=1; DO I=1,N; V1(I)=ARR(I,M); ENDDO
  IF(PRESENT(V2))THEN; M=M+1; DO I=1,N; V2(I)=INT(ARR(I,M),4); ENDDO; ENDIF
  IF(PRESENT(V3))THEN; M=M+1; DO I=1,N; V3(I)=INT(ARR(I,M),4); ENDDO; ENDIF
  IF(PRESENT(V4))THEN; M=M+1; DO I=1,N; V4(I)=INT(ARR(I,M),4); ENDDO; ENDIF
  IF(PRESENT(V5))THEN; M=M+1; DO I=1,N; V5(I)=INT(ARR(I,M),4); ENDDO; ENDIF
  IF(PRESENT(V6))THEN; M=M+1; DO I=1,N; V6(I)=INT(ARR(I,M),4); ENDDO; ENDIF
 ENDIF
  
 DEALLOCATE(ARR)

 END SUBROUTINE QKSORT_INT

 !###====================================================
 SUBROUTINE QKSORT_INT8(N,V1,V2,V3,V4,V5,V6)
 !###====================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: N
 INTEGER(KIND=DP_KIND),INTENT(INOUT),DIMENSION(:) :: V1
 INTEGER(KIND=DP_KIND),INTENT(INOUT),DIMENSION(:),OPTIONAL :: V2,V3,V4,V5,V6
 INTEGER :: I,M
 REAL(KIND=DP_KIND),ALLOCATABLE,DIMENSION(:,:) :: ARR

 M=1; IF(PRESENT(V2))M=M+1; IF(PRESENT(V3))M=M+1; IF(PRESENT(V4))M=M+1; IF(PRESENT(V5))M=M+1; IF(PRESENT(V6))M=M+1
 ALLOCATE(ARR(N,M)); M=1; DO I=1,N; ARR(I,M)=REAL(V1(I),8); ENDDO

 IF(M.EQ.1)THEN
  CALL QKSORT_SGL(N,ARR(:,1))
  M=1; DO I=1,N; V1(I)=INT(ARR(I,M),8); ENDDO
 ELSE
  IF(PRESENT(V2))THEN; M=M+1; DO I=1,N; ARR(I,M)=REAL(V2(I),8); ENDDO; ENDIF
  IF(PRESENT(V3))THEN; M=M+1; DO I=1,N; ARR(I,M)=REAL(V3(I),8); ENDDO; ENDIF
  IF(PRESENT(V4))THEN; M=M+1; DO I=1,N; ARR(I,M)=REAL(V4(I),8); ENDDO; ENDIF
  IF(PRESENT(V5))THEN; M=M+1; DO I=1,N; ARR(I,M)=REAL(V5(I),8); ENDDO; ENDIF
  IF(PRESENT(V6))THEN; M=M+1; DO I=1,N; ARR(I,M)=REAL(V6(I),8); ENDDO; ENDIF
  CALL QKSORT_DBL(N,ARR)
  M=1; DO I=1,N; V1(I)=ARR(I,M); ENDDO
  IF(PRESENT(V2))THEN; M=M+1; DO I=1,N; V2(I)=INT(ARR(I,M),8); ENDDO; ENDIF
  IF(PRESENT(V3))THEN; M=M+1; DO I=1,N; V3(I)=INT(ARR(I,M),8); ENDDO; ENDIF
  IF(PRESENT(V4))THEN; M=M+1; DO I=1,N; V4(I)=INT(ARR(I,M),8); ENDDO; ENDIF
  IF(PRESENT(V5))THEN; M=M+1; DO I=1,N; V5(I)=INT(ARR(I,M),8); ENDDO; ENDIF
  IF(PRESENT(V6))THEN; M=M+1; DO I=1,N; V6(I)=INT(ARR(I,M),8); ENDDO; ENDIF
 ENDIF
  
 DEALLOCATE(ARR)

 END SUBROUTINE QKSORT_INT8
 
 !###====================================================
 SUBROUTINE QKSORT_P_INT4REAL8(N,V1,V2,V3,V4,V5,V6)
 !###====================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: N
 INTEGER(KIND=SP_KIND),INTENT(INOUT),DIMENSION(:),POINTER :: V1
 REAL(KIND=DP_KIND),INTENT(INOUT),DIMENSION(:),OPTIONAL,POINTER :: V2,V3,V4,V5,V6
 INTEGER :: I,M
 REAL(KIND=DP_KIND),ALLOCATABLE,DIMENSION(:,:) :: ARR

 M=1; IF(PRESENT(V2))M=M+1; IF(PRESENT(V3))M=M+1; IF(PRESENT(V4))M=M+1; IF(PRESENT(V5))M=M+1; IF(PRESENT(V6))M=M+1
 ALLOCATE(ARR(N,M)); M=1; DO I=1,N; ARR(I,M)=REAL(V1(I),8); ENDDO

 IF(M.EQ.1)THEN
  CALL QKSORT_SGL(N,ARR(:,1))
  M=1; DO I=1,N; V1(I)=INT(ARR(I,M),4); ENDDO
 ELSE
  IF(PRESENT(V2))THEN; M=M+1; DO I=1,N; ARR(I,M)=REAL(V2(I),8); ENDDO; ENDIF
  IF(PRESENT(V3))THEN; M=M+1; DO I=1,N; ARR(I,M)=REAL(V3(I),8); ENDDO; ENDIF
  IF(PRESENT(V4))THEN; M=M+1; DO I=1,N; ARR(I,M)=REAL(V4(I),8); ENDDO; ENDIF
  IF(PRESENT(V5))THEN; M=M+1; DO I=1,N; ARR(I,M)=REAL(V5(I),8); ENDDO; ENDIF
  IF(PRESENT(V6))THEN; M=M+1; DO I=1,N; ARR(I,M)=REAL(V6(I),8); ENDDO; ENDIF
  CALL QKSORT_DBL(N,ARR)
  M=1; DO I=1,N; V1(I)=ARR(I,M); ENDDO
  IF(PRESENT(V2))THEN; M=M+1; DO I=1,N; V2(I)=INT(ARR(I,M),4); ENDDO; ENDIF
  IF(PRESENT(V3))THEN; M=M+1; DO I=1,N; V3(I)=INT(ARR(I,M),4); ENDDO; ENDIF
  IF(PRESENT(V4))THEN; M=M+1; DO I=1,N; V4(I)=INT(ARR(I,M),4); ENDDO; ENDIF
  IF(PRESENT(V5))THEN; M=M+1; DO I=1,N; V5(I)=INT(ARR(I,M),4); ENDDO; ENDIF
  IF(PRESENT(V6))THEN; M=M+1; DO I=1,N; V6(I)=INT(ARR(I,M),4); ENDDO; ENDIF
 ENDIF
  
 DEALLOCATE(ARR)

 END SUBROUTINE QKSORT_P_INT4REAL8

! !###====================================================
! SUBROUTINE QKSORT_INTREAL(N,V1,V2,V3,V4,V5,V6)
! !###====================================================
! IMPLICIT NONE
! INTEGER,INTENT(IN) :: N
! INTEGER,INTENT(INOUT),DIMENSION(:),POINTER :: V1
! REAL(KIND=DP_KIND),INTENT(INOUT),DIMENSION(:),OPTIONAL,POINTER :: V2,V3,V4,V5,V6
! INTEGER :: I,M
! REAL(KIND=DP_KIND),ALLOCATABLE,DIMENSION(:,:) :: ARR
!
! M=1; IF(PRESENT(V2))M=M+1; IF(PRESENT(V3))M=M+1; IF(PRESENT(V4))M=M+1; IF(PRESENT(V5))M=M+1; IF(PRESENT(V6))M=M+1
! ALLOCATE(ARR(N,M)); M=1; DO I=1,N; ARR(I,M)=V1(I); ENDDO
!
! IF(M.EQ.1)THEN
!  CALL QKSORT_INT_SGL(N,ARR(:,1))
!  M=1; DO I=1,N; V1(I)=ARR(I,M); ENDDO
! ELSE
!  IF(PRESENT(V2))THEN; M=M+1; DO I=1,N; ARR(I,M)=V2(I); ENDDO; ENDIF
!  IF(PRESENT(V3))THEN; M=M+1; DO I=1,N; ARR(I,M)=V3(I); ENDDO; ENDIF
!  IF(PRESENT(V4))THEN; M=M+1; DO I=1,N; ARR(I,M)=V4(I); ENDDO; ENDIF
!  IF(PRESENT(V5))THEN; M=M+1; DO I=1,N; ARR(I,M)=V5(I); ENDDO; ENDIF
!  IF(PRESENT(V6))THEN; M=M+1; DO I=1,N; ARR(I,M)=V6(I); ENDDO; ENDIF
!  CALL QKSORT_INT_DBL(N,ARR)
!  M=1; DO I=1,N; V1(I)=ARR(I,M); ENDDO
!  IF(PRESENT(V2))THEN; M=M+1; DO I=1,N; V2(I)=ARR(I,M); ENDDO; ENDIF
!  IF(PRESENT(V3))THEN; M=M+1; DO I=1,N; V3(I)=ARR(I,M); ENDDO; ENDIF
!  IF(PRESENT(V4))THEN; M=M+1; DO I=1,N; V4(I)=ARR(I,M); ENDDO; ENDIF
!  IF(PRESENT(V5))THEN; M=M+1; DO I=1,N; V5(I)=ARR(I,M); ENDDO; ENDIF
!  IF(PRESENT(V6))THEN; M=M+1; DO I=1,N; V6(I)=ARR(I,M); ENDDO; ENDIF
! ENDIF
!
! DEALLOCATE(ARR)
!  
! END SUBROUTINE QKSORT_INTREAL
  
 !###====================================================
 SUBROUTINE QKSORT_SGL(N,ARR)
 !###====================================================
 IMPLICIT NONE
 INTEGER,PARAMETER :: M=7,NSTACK=50
 INTEGER,INTENT(IN) :: N
 REAL(KIND=DP_KIND),INTENT(INOUT),DIMENSION(:) :: ARR
 INTEGER :: I,IR,J,JSTACK,K,L
 INTEGER,DIMENSION(NSTACK) :: ISTACK
 REAL(KIND=DP_KIND) :: A,ATEMP
 
 JSTACK=0
 L=1
 IR=N
 1 IF(IR-L.LT.M)THEN
  DO J=L+1,IR
   A=ARR(J)
   DO I=J-1,1,-1
    IF(ARR(I).LE.A)GOTO 2
    ARR(I+1)=ARR(I)
   ENDDO
   I=0
 2 CONTINUE
   ARR(I+1)=A
  ENDDO
  IF(JSTACK.EQ.0)RETURN
  IR=ISTACK(JSTACK)
  L =ISTACK(JSTACK-1)
  JSTACK=JSTACK-2
 ELSE
  K=(L+IR)/2
  ATEMP   =ARR(K)
  ARR(K)  =ARR(L+1)
  ARR(L+1)=ATEMP
  IF(ARR(L+1).GT.ARR(IR))THEN
   ATEMP   =ARR(L+1)
   ARR(L+1)=ARR(IR)
   ARR(IR)=ATEMP
  ENDIF
  IF(ARR(L).GT.ARR(IR))THEN
   ATEMP  =ARR(L)
   ARR(L) =ARR(IR)
   ARR(IR)=ATEMP
  ENDIF
  IF(ARR(L+1).GT.ARR(L))THEN
   ATEMP   =ARR(L+1)
   ARR(L+1)=ARR(L)
   ARR(L)  =ATEMP
  ENDIF
  I=L+1
  J=IR
  A=ARR(L)
 3  CONTINUE
  I=I+1
  IF(ARR(I).LT.A)GOTO 3
 4  CONTINUE
  J=J-1
  IF(ARR(J).GT.A)GOTO 4
  IF(J.LT.I)GOTO 5
  ATEMP =ARR(I)
  ARR(I)=ARR(J)
  ARR(J)=ATEMP
  GOTO 3
 5 CONTINUE
  ARR(L)=ARR(J)
  ARR(J)=A
  JSTACK=JSTACK+2
  IF(JSTACK.GT.NSTACK)PAUSE 'NSTACK TOO SMALL'
  IF(IR-I+1.GT.J-L)THEN
   ISTACK(JSTACK)=IR
   ISTACK(JSTACK-1)=I
   IR=J-1
  ELSE
   ISTACK(JSTACK)=J-1
   ISTACK(JSTACK-1)=L
   L=I
  ENDIF
 ENDIF
 GOTO 1

 END SUBROUTINE QKSORT_SGL
 
 !###====================================================
 SUBROUTINE QKSORT_DBL(N,ARR)
 !###====================================================
 IMPLICIT NONE
 INTEGER,PARAMETER :: M=7,NSTACK=50
 INTEGER,INTENT(IN) :: N
 REAL(KIND=DP_KIND),INTENT(INOUT),DIMENSION(:,:) :: ARR
 INTEGER :: I,IR,J,JSTACK,K,L,NVAR,IVAR
 INTEGER,DIMENSION(NSTACK) :: ISTACK
 REAL(KIND=DP_KIND),ALLOCATABLE,DIMENSION(:) :: A,ATEMP
 
 NVAR=SIZE(ARR,2); ALLOCATE(A(NVAR),ATEMP(NVAR))

 JSTACK=0
 L=1
 IR=N
 1 IF(IR-L.LT.M)THEN
  DO J=L+1,IR
   DO IVAR=1,NVAR; A(IVAR)=ARR(J,IVAR); ENDDO
!   A=ARR(J)
!   B=BRR(J)
   DO I=J-1,1,-1
!    IF(ARR(I).LE.A)GOTO 2
    IF(ARR(I,1).LE.A(1))GOTO 2
    DO IVAR=1,NVAR; ARR(I+1,IVAR)=ARR(I,IVAR); ENDDO
!    ARR(I+1)=ARR(I)
!    BRR(I+1)=BRR(I)
   ENDDO
   I=0
 2 CONTINUE
   DO IVAR=1,NVAR; ARR(I+1,IVAR)=A(IVAR); ENDDO
!   ARR(I+1)=A
!   BRR(I+1)=B
  ENDDO
  IF(JSTACK.EQ.0)RETURN
  IR=ISTACK(JSTACK)
  L =ISTACK(JSTACK-1)
  JSTACK=JSTACK-2
 ELSE
  K=(L+IR)/2
  DO IVAR=1,NVAR; ATEMP(IVAR)=ARR(K,IVAR); ENDDO
!  ATEMP   =ARR(K)
!  BTEMP   =BRR(K)
  DO IVAR=1,NVAR; ARR(K,IVAR)=ARR(L+1,IVAR); ENDDO
!  ARR(K)  =ARR(L+1)
!  BRR(K)  =BRR(L+1)
  DO IVAR=1,NVAR; ARR(L+1,IVAR)=ATEMP(IVAR); ENDDO
!  ARR(L+1)=ATEMP
!  BRR(L+1)=BTEMP
!  IF(ARR(L+1).GT.ARR(IR))THEN
  IF(ARR(L+1,1).GT.ARR(IR,1))THEN
   DO IVAR=1,NVAR; ATEMP(IVAR)=ARR(L+1,IVAR); ENDDO
!   ATEMP   =ARR(L+1)
!   BTEMP   =BRR(L+1)
   DO IVAR=1,NVAR; ARR(L+1,IVAR)=ARR(IR,IVAR); ENDDO
!   ARR(L+1)=ARR(IR)
!   BRR(L+1)=BRR(IR)
   DO IVAR=1,NVAR; ARR(IR,IVAR)=ATEMP(IVAR); ENDDO
!   ARR(IR)=ATEMP
!   BRR(IR)=BTEMP
  ENDIF
!  IF(ARR(L).GT.ARR(IR))THEN
  IF(ARR(L,1).GT.ARR(IR,1))THEN
   DO IVAR=1,NVAR; ATEMP(IVAR)=ARR(L,IVAR); ENDDO
!   ATEMP  =ARR(L)
!   BTEMP  =BRR(L)
   DO IVAR=1,NVAR; ARR(L,IVAR)=ARR(IR,IVAR); ENDDO
!   ARR(L) =ARR(IR)
!   BRR(L) =BRR(IR)
   DO IVAR=1,NVAR; ARR(IR,IVAR)=ATEMP(IVAR); ENDDO
!   ARR(IR)=ATEMP
!   BRR(IR)=BTEMP
  ENDIF
!  IF(ARR(L+1).GT.ARR(L))THEN
  IF(ARR(L+1,1).GT.ARR(L,1))THEN
   DO IVAR=1,NVAR; ATEMP(IVAR)=ARR(L+1,IVAR); ENDDO
!   ATEMP   =ARR(L+1)
!   BTEMP   =BRR(L+1)
   DO IVAR=1,NVAR; ARR(L+1,IVAR)=ARR(L,IVAR); ENDDO
!   ARR(L+1)=ARR(L)
!   BRR(L+1)=BRR(L)
   DO IVAR=1,NVAR; ARR(L,IVAR)=ATEMP(IVAR); ENDDO
!   ARR(L)  =ATEMP
!   BRR(L)  =BTEMP
  ENDIF
  I=L+1
  J=IR
  DO IVAR=1,NVAR; A(IVAR)=ARR(L,IVAR); ENDDO
!  A=ARR(L)
!  B=BRR(L)
 3  CONTINUE
  I=I+1
  IF(ARR(I,1).LT.A(1))GOTO 3
!  IF(ARR(I).LT.A)GOTO 3
 4  CONTINUE
  J=J-1
  IF(ARR(J,1).GT.A(1))GOTO 4
!  IF(ARR(J).GT.A)GOTO 4
  IF(J.LT.I)GOTO 5
   DO IVAR=1,NVAR; ATEMP(IVAR)=ARR(I,IVAR); ENDDO
!  ATEMP =ARR(I)
!  BTEMP =BRR(I)
   DO IVAR=1,NVAR; ARR(I,IVAR)=ARR(J,IVAR); ENDDO
!  ARR(I)=ARR(J)
!  BRR(I)=BRR(J)
   DO IVAR=1,NVAR; ARR(J,IVAR)=ATEMP(IVAR); ENDDO
!  ARR(J)=ATEMP
!  BRR(J)=BTEMP
  GOTO 3
 5 CONTINUE
  DO IVAR=1,NVAR; ARR(L,IVAR)=ARR(J,IVAR); ENDDO
!  ARR(L)=ARR(J)
!  BRR(L)=BRR(J)
  DO IVAR=1,NVAR; ARR(J,IVAR)=A(IVAR); ENDDO
!  ARR(J)=A
!  BRR(J)=B
  JSTACK=JSTACK+2
  IF(JSTACK.GT.NSTACK)PAUSE 'NSTACK TOO SMALL'
  IF(IR-I+1.GT.J-L)THEN
   ISTACK(JSTACK)=IR
   ISTACK(JSTACK-1)=I
   IR=J-1
  ELSE
   ISTACK(JSTACK)=J-1
   ISTACK(JSTACK-1)=L
   L=I
  ENDIF
 ENDIF
 GOTO 1

 DEALLOCATE(A,ATEMP)

 END SUBROUTINE QKSORT_DBL



! !###====================================================
! SUBROUTINE UTL_QKSORT_INT(ARR,BRR,NDIM,N)
! !###====================================================
! IMPLICIT NONE
! INTEGER,INTENT(IN) :: NDIM,N
! INTEGER,INTENT(INOUT),DIMENSION(NDIM) :: ARR
! REAL(KIND=DP_KIND),INTENT(INOUT),DIMENSION(NDIM) :: BRR
! INTEGER,PARAMETER :: M=7,NSTACK=50
! INTEGER :: I,IR,J,JSTACK,K,L,ISTACK(NSTACK)
! REAL(KIND=DP_KIND) :: B,BTEMP
! INTEGER :: A,ATEMP
!
! JSTACK=0
! L=1
! IR=N
! 1 IF(IR-L.LT.M)THEN
!  DO J=L+1,IR
!   A=ARR(J)
!   B=BRR(J)
!   DO I=J-1,1,-1
!    IF(ARR(I).LE.A)GOTO 2
!    ARR(I+1)=ARR(I)
!    BRR(I+1)=BRR(I)
!   ENDDO
!   I=0
! 2 ARR(I+1)=A
!   BRR(I+1)=B
!  ENDDO
!  IF(JSTACK.EQ.0)RETURN
!  IR=ISTACK(JSTACK)
!  L =ISTACK(JSTACK-1)
!  JSTACK=JSTACK-2
! ELSE
!  K=(L+IR)/2
!  ATEMP   =ARR(K)
!  BTEMP   =BRR(K)
!  ARR(K)  =ARR(L+1)
!  BRR(K)  =BRR(L+1)
!  ARR(L+1)=ATEMP
!  BRR(L+1)=BTEMP
!  IF(ARR(L+1).GT.ARR(IR))THEN
!   ATEMP   =ARR(L+1)
!   BTEMP   =BRR(L+1)
!   ARR(L+1)=ARR(IR)
!   BRR(L+1)=BRR(IR)
!   ARR(IR)=ATEMP
!   BRR(IR)=BTEMP
!  ENDIF
!  IF(ARR(L).GT.ARR(IR))THEN
!   ATEMP  =ARR(L)
!   BTEMP  =BRR(L)
!   ARR(L) =ARR(IR)
!   BRR(L) =BRR(IR)
!   ARR(IR)=ATEMP
!   BRR(IR)=BTEMP
!  ENDIF
!  IF(ARR(L+1).GT.ARR(L))THEN
!   ATEMP   =ARR(L+1)
!   BTEMP   =BRR(L+1)
!   ARR(L+1)=ARR(L)
!   BRR(L+1)=BRR(L)
!   ARR(L)  =ATEMP
!   BRR(L)  =BTEMP
!  ENDIF
!  I=L+1
!  J=IR
!  A=ARR(L)
!  B=BRR(L)
! 3  CONTINUE
!  I=I+1
!  IF(ARR(I).LT.A)GOTO 3
! 4  CONTINUE
!  J=J-1
!  IF(ARR(J).GT.A)GOTO 4
!  IF(J.LT.I)GOTO 5
!  ATEMP =ARR(I)
!  BTEMP =BRR(I)
!  ARR(I)=ARR(J)
!  BRR(I)=BRR(J)
!  ARR(J)=ATEMP
!  BRR(J)=BTEMP
!  GOTO 3
! 5  ARR(L)=ARR(J)
!  BRR(L)=BRR(J)
!  ARR(J)=A
!  BRR(J)=B
!  JSTACK=JSTACK+2
!  IF(JSTACK.GT.NSTACK)PAUSE 'NSTACK TOO SMALL'
!  IF(IR-I+1.GT.J-L)THEN
!   ISTACK(JSTACK)=IR
!   ISTACK(JSTACK-1)=I
!   IR=J-1
!  ELSE
!   ISTACK(JSTACK)=J-1
!   ISTACK(JSTACK-1)=L
!   L=I
!  ENDIF
! ENDIF
! GOTO 1
!
! END SUBROUTINE
!
! !###====================================================
! SUBROUTINE UTL_QKSORT_INT2(ARR,BRR,NDIM,N)
! !###====================================================
! IMPLICIT NONE
! INTEGER,INTENT(IN) :: NDIM,N
! INTEGER,INTENT(INOUT),DIMENSION(NDIM) :: ARR
! INTEGER,INTENT(INOUT),DIMENSION(NDIM) :: BRR
! INTEGER,PARAMETER :: M=7,NSTACK=50
! INTEGER :: I,IR,J,JSTACK,K,L,ISTACK(NSTACK)
! INTEGER :: B,BTEMP
! INTEGER :: A,ATEMP
!
! JSTACK=0
! L=1
! IR=N
! 1 IF(IR-L.LT.M)THEN
!  DO J=L+1,IR
!   A=ARR(J)
!   B=BRR(J)
!   DO I=J-1,1,-1
!    IF(ARR(I).LE.A)GOTO 2
!    ARR(I+1)=ARR(I)
!    BRR(I+1)=BRR(I)
!   ENDDO
!   I=0
! 2 ARR(I+1)=A
!   BRR(I+1)=B
!  ENDDO
!  IF(JSTACK.EQ.0)RETURN
!  IR=ISTACK(JSTACK)
!  L =ISTACK(JSTACK-1)
!  JSTACK=JSTACK-2
! ELSE
!  K=(L+IR)/2
!  ATEMP   =ARR(K)
!  BTEMP   =BRR(K)
!  ARR(K)  =ARR(L+1)
!  BRR(K)  =BRR(L+1)
!  ARR(L+1)=ATEMP
!  BRR(L+1)=BTEMP
!  IF(ARR(L+1).GT.ARR(IR))THEN
!   ATEMP   =ARR(L+1)
!   BTEMP   =BRR(L+1)
!   ARR(L+1)=ARR(IR)
!   BRR(L+1)=BRR(IR)
!   ARR(IR)=ATEMP
!   BRR(IR)=BTEMP
!  ENDIF
!  IF(ARR(L).GT.ARR(IR))THEN
!   ATEMP  =ARR(L)
!   BTEMP  =BRR(L)
!   ARR(L) =ARR(IR)
!   BRR(L) =BRR(IR)
!   ARR(IR)=ATEMP
!   BRR(IR)=BTEMP
!  ENDIF
!  IF(ARR(L+1).GT.ARR(L))THEN
!   ATEMP   =ARR(L+1)
!   BTEMP   =BRR(L+1)
!   ARR(L+1)=ARR(L)
!   BRR(L+1)=BRR(L)
!   ARR(L)  =ATEMP
!   BRR(L)  =BTEMP
!  ENDIF
!  I=L+1
!  J=IR
!  A=ARR(L)
!  B=BRR(L)
! 3  CONTINUE
!  I=I+1
!  IF(ARR(I).LT.A)GOTO 3
! 4  CONTINUE
!  J=J-1
!  IF(ARR(J).GT.A)GOTO 4
!  IF(J.LT.I)GOTO 5
!  ATEMP =ARR(I)
!  BTEMP =BRR(I)
!  ARR(I)=ARR(J)
!  BRR(I)=BRR(J)
!  ARR(J)=ATEMP
!  BRR(J)=BTEMP
!  GOTO 3
! 5  ARR(L)=ARR(J)
!  BRR(L)=BRR(J)
!  ARR(J)=A
!  BRR(J)=B
!  JSTACK=JSTACK+2
!  IF(JSTACK.GT.NSTACK)PAUSE 'NSTACK TOO SMALL'
!  IF(IR-I+1.GT.J-L)THEN
!   ISTACK(JSTACK)=IR
!   ISTACK(JSTACK-1)=I
!   IR=J-1
!  ELSE
!   ISTACK(JSTACK)=J-1
!   ISTACK(JSTACK-1)=L
!   L=I
!  ENDIF
! ENDIF
! GOTO 1
!
! END SUBROUTINE

! !###====================================================
! SUBROUTINE SHELLSORT(N,A)
! !###====================================================
! IMPLICIT NONE
! INTEGER,INTENT(IN) :: N
! REAL(KIND=DP_KIND),DIMENSION(N)  :: A
! INTEGER :: I,J,INC
! REAL(KIND=DP_KIND) :: V
!
! INC=1
! 1 INC=3*INC+1
! IF(INC.LE.N)GOTO 1
!  2 CONTINUE
!  INC=INC/3
!  DO I=INC+1,N
!   V=A(I)
!   J=I
!   3 IF(A(J-INC).GT.V)THEN
!    A(J)=A(J-INC)
!    J=J-INC
!   IF(J.LE.INC)GOTO 4
!    GOTO 3
!   ENDIF
!   4  A(J)=V
! END DO
! IF(INC.GT.1)GOTO 2
!
! RETURN
! END SUBROUTINE
!
! !###====================================================
! SUBROUTINE SHELLSORT_DOUBLEINT(N,A)
! !###====================================================
! IMPLICIT NONE
! INTEGER,INTENT(IN) :: N
! INTEGER(KIND=8),POINTER,DIMENSION(:) :: A
! INTEGER :: I,J,INC
! INTEGER(KIND=8) :: V
!
! INC=1
! 1 INC=3*INC+1
! IF(INC.LE.N)GOTO 1
!  2 CONTINUE
!  INC=INC/3
!  DO I=INC+1,N
!   V=A(I)
!   J=I
!   3 IF(A(J-INC).GT.V)THEN
!    A(J)=A(J-INC)
!    J=J-INC
!   IF(J.LE.INC)GOTO 4
!    GOTO 3
!   ENDIF
!   4  A(J)=V
! END DO
! IF(INC.GT.1)GOTO 2
!
! RETURN
! END SUBROUTINE
!
! !###====================================================
! SUBROUTINE SHELLSORTDOUBLE2(N,A,B)
! !###====================================================
! IMPLICIT NONE
! INTEGER,INTENT(IN) :: N
! REAL(KIND=DP_KIND),DIMENSION(N) :: A,B
! INTEGER :: I,J,INC
! REAL(KIND=DP_KIND) :: V,W
!
! INC=1
! 1 INC=3*INC+1
! IF(INC.LE.N)GOTO 1
!  2 CONTINUE
!  INC=INC/3
!  DO I=INC+1,N
!   V=A(I)
!   W=B(I)
!   J=I
!   3 IF(A(J-INC).GT.V)THEN
!    A(J)=A(J-INC)
!    B(J)=B(J-INC)
!    J=J-INC
!   IF(J.LE.INC)GOTO 4
!    GOTO 3
!   ENDIF
!   4  A(J)=V
!   B(J)=W
! END DO
! IF(INC.GT.1)GOTO 2
!
! RETURN
! END SUBROUTINE
!
! !###====================================================
! SUBROUTINE SHELLSORTPOINTER2(N,A,B)
! !###====================================================
! IMPLICIT NONE
! INTEGER,INTENT(IN) :: N
! REAL(KIND=DP_KIND),POINTER,DIMENSION(:) :: A,B
! INTEGER :: I,J,INC
! REAL(KIND=DP_KIND) :: V,W
!
! INC=1
! 1 INC=3*INC+1
! IF(INC.LE.N)GOTO 1
!  2 CONTINUE
!  INC=INC/3
!  DO I=INC+1,N
!   V=A(I)
!   W=B(I)
!   J=I
!   3 IF(A(J-INC).GT.V)THEN
!    A(J)=A(J-INC)
!    B(J)=B(J-INC)
!    J=J-INC
!   IF(J.LE.INC)GOTO 4
!    GOTO 3
!   ENDIF
!   4  A(J)=V
!   B(J)=W
! END DO
! IF(INC.GT.1)GOTO 2
!
! RETURN
! END SUBROUTINE
!
 !###====================================================
 SUBROUTINE SHELLSORT_INT(N,A)
 !###====================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: N
 INTEGER,DIMENSION(N) :: A
 INTEGER :: I,J,INC
 INTEGER :: V

 INC=1
 1 INC=3*INC+1
 IF(INC.LE.N)GOTO 1
  2 CONTINUE
  INC=INC/3
  DO I=INC+1,N
   V=A(I)
   J=I
   3 IF(A(J-INC).GT.V)THEN
    A(J)=A(J-INC)
    J=J-INC
   IF(J.LE.INC)GOTO 4
    GOTO 3
   ENDIF
   4  A(J)=V
 END DO
 IF(INC.GT.1)GOTO 2

 END SUBROUTINE SHELLSORT_INT

 !###====================================================
 SUBROUTINE SHELLSORT_DINT(N,A)
 !###====================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: N
 INTEGER(KIND=8),DIMENSION(N) :: A
 INTEGER(KIND=8) :: I,J,INC
 INTEGER(KIND=8) :: V

 INC=1
 1 INC=3*INC+1
 IF(INC.LE.N)GOTO 1
  2 CONTINUE
  INC=INC/3
  DO I=INC+1,N
   V=A(I)
   J=I
   3 IF(A(J-INC).GT.V)THEN
    A(J)=A(J-INC)
    J=J-INC
   IF(J.LE.INC)GOTO 4
    GOTO 3
   ENDIF
   4  A(J)=V
 END DO
 IF(INC.GT.1)GOTO 2

 END SUBROUTINE SHELLSORT_DINT
 
END MODULE MOD_QKSORT
