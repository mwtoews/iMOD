MODULE MOD_UDF_UTL
 USE WINTERACTER
 USE MOD_IDF_PAR, ONLY : IDFOBJ
 USE KDTREE2_MODULE  
 USE MESHMOD
 USE MOD_UTL, ONLY: UTL_GETUNIT,UTL_TIMING
   
 IMPLICIT NONE

 TYPE(TMESH), POINTER :: UDFMESH
 TYPE(KDTREE2), POINTER :: UDFTREE  
 TYPE(KDTREE2_RESULT), DIMENSION(1) :: UDFRES

CONTAINS

 !##==============================================================
 SUBROUTINE UDF_DEALLOCATEMESH()
 !##==============================================================
 IMPLICIT NONE
 INTEGER :: I
 
 IF(ASSOCIATED(UDFMESH))THEN
  IF(ASSOCIATED(UDFMESH%TAG)) DEALLOCATE(UDFMESH%TAG)
  IF(ASSOCIATED(UDFMESH%NODE))DEALLOCATE(UDFMESH%NODE)
  IF(ASSOCIATED(UDFMESH%ELEM))THEN
   DO I=1,SIZE(UDFMESH%ELEM)
    IF(ASSOCIATED(UDFMESH%ELEM(I)%TAG)) DEALLOCATE(UDFMESH%ELEM(I)%TAG)
    IF(ASSOCIATED(UDFMESH%ELEM(I)%TAG)) DEALLOCATE(UDFMESH%ELEM(I)%TAG)
    IF(ASSOCIATED(UDFMESH%ELEM(I)%ITAG))DEALLOCATE(UDFMESH%ELEM(I)%ITAG)
   ENDDO
   DEALLOCATE(UDFMESH%ELEM)
  ENDIF
  
  IF(ASSOCIATED(UDFMESH%NODE2ELEM))THEN
   DO I=1,SIZE(UDFMESH%NODE2ELEM)
    IF(ASSOCIATED(UDFMESH%NODE2ELEM(I)%NUM)) DEALLOCATE(UDFMESH%NODE2ELEM(I)%NUM)
   ENDDO
   DEALLOCATE(UDFMESH%NODE2ELEM)
  ENDIF
 ENDIF
 
 END SUBROUTINE UDF_DEALLOCATEMESH
 
 !##==============================================================
 LOGICAL FUNCTION UDF_OPEN(IDF,UDFFILE,IREAD,IU)
 !##==============================================================
 IMPLICIT NONE
 TYPE(IDFOBJ),INTENT(INOUT) :: IDF
 CHARACTER(LEN=*),INTENT(IN) :: UDFFILE
 INTEGER,INTENT(IN) :: IREAD
 INTEGER,INTENT(OUT) :: IU
 INTEGER :: IOS,I
 REAL :: X
 CHARACTER(LEN=256) :: GMSHFILE,DATFILE
    
 UDF_OPEN=.FALSE.
 
 IU=UTL_GETUNIT(); OPEN(IU,FILE=UDFFILE,ACTION='READ',IOSTAT=IOS)
 IF(IOS.NE.0)THEN
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Cannot read file '//TRIM(UDFFILE),'Error'); RETURN
 ENDIF

 READ(IU,'(A256)') GMSHFILE
 READ(IU,'(A256)') DATFILE
 CLOSE(IU)

 !## read the gmshfile
 IF(.NOT.READGMSH(UDFMESH,GMSHFILE,IREAD))RETURN
    
 IDF%XMIN=UDFMESH%XMIN
 IDF%YMIN=UDFMESH%YMIN
 IDF%XMAX=UDFMESH%XMAX
 IDF%YMAX=UDFMESH%YMAX

 !## create kd-tree
 IF(IREAD.EQ.1)THEN 
! CALL DATE_AND_TIME(VALUES=T1)    
  UDFTREE=>KDTREE2_CREATE(UDFMESH%NODE,SORT=.FALSE.,REARRANGE=.FALSE.) 
! CALL DATE_AND_TIME(VALUES=T2)
! CALL UTL_TIMING(T1,T2,TD)
 ENDIF
    
 !## open the datfile
 IU=UTL_GETUNIT(); OPEN(UNIT=IU,FILE=DATFILE,FORM='UNFORMATTED',STATUS='OLD',ACCESS='STREAM',IOSTAT=IOS)
 IF(IOS.NE.0)THEN
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Cannot read file '//TRIM(UDFFILE),'Error'); RETURN
 ENDIF
    
 !## get data
 IF(IREAD.EQ.0)THEN
  IDF%DMIN= HUGE(1.0)
  IDF%DMAX=-HUGE(1.0)
  DO I=1,UDFMESH%NELEM
   READ(IU) X
   IDF%DMIN = MIN(IDF%DMIN,X)
   IDF%DMAX = MAX(IDF%DMAX,X)
  ENDDO
  CLOSE(IU)
 ENDIF
     
 UDF_OPEN=.TRUE.

 END FUNCTION UDF_OPEN
  
 !##==============================================================
 SUBROUTINE READUDFXY(X,Y,NODATA,VAL,IU)
 !##==============================================================
 IMPLICIT NONE
 REAL, INTENT(IN) :: X
 REAL, INTENT(IN) :: Y
 REAL, INTENT(IN) :: NODATA
 REAL, INTENT(OUT) :: VAL
 INTEGER,INTENT(IN) :: IU
 INTEGER :: NOD, ELEM, I, J, N, M, ELEMFOUND
 REAL(KDKIND), DIMENSION(2) :: QV
 LOGICAL :: LFOUND
 DOUBLEPRECISION, DIMENSION(2,4) :: V
 DOUBLEPRECISION, DIMENSION(2) :: P
  
 IF (X < UDFMESH%XMIN .OR. X > UDFMESH%XMAX .OR. Y < UDFMESH%YMIN .OR. Y > UDFMESH%YMAX) THEN
  VAL = NODATA
  RETURN  
 END IF
  
 QV(1) = X; QV(2) = Y
 P(1) = X; P(2) = Y
 !## find nearest node
 CALL KDTREE2_N_NEAREST(TP=UDFTREE,QV=QV,NN=1,RESULTS=UDFRES)
 NOD = UDFRES(1)%IDX
 !## loop over connected elements
 ELEMFOUND = 0
 LFOUND = .FALSE.
 DO I = 1, UDFMESH%NODE2ELEM(NOD)%N
  ELEM = UDFMESH%NODE2ELEM(NOD)%NUM(I)  
  N = UDFMESH%ELEM(ELEM)%N
  DO J = 1, N
   M = UDFMESH%ELEM(ELEM)%NUM(J)  
   V(1,J) = UDFMESH%NODE(1,M)
   V(2,J) = UDFMESH%NODE(2,M)
  END DO
  CALL POLYGON_CONTAINS_POINT_2D(N,V,P,LFOUND)
  IF (LFOUND) THEN
   ELEMFOUND = ELEM
   EXIT
  END IF  
 END DO    
  
 IF (LFOUND) THEN
  I = 4*(ELEMFOUND-1)+1 ! BYTES
  READ(IU,POS=I) VAL
 ELSE    
  VAL = NODATA
 END IF   
  
 END SUBROUTINE READUDFXY
  
END MODULE MOD_UDF_UTL 

    
