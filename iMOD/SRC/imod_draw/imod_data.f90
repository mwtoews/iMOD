!!  Copyright (C) Stichting Deltares, 2005-2019.
!!
!!  This file is part of iMOD.
!!
!!  This program is free software: you can redistribute it and/or modify
!!  it under the terms of the GNU General Public License as published by
!!  the Free Software Foundation, either version 3 of the License, or
!!  (at your option) any later version.
!!
!!  This program is distributed in the hope that it will be useful,
!!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!  GNU General Public License for more details.
!!
!!  You should have received a copy of the GNU General Public License
!!  along with this program.  If not, see <http://www.gnu.org/licenses/>.
!!
!!  Contact: imod.support@deltares.nl
!!  Stichting Deltares
!!  P.O. Box 177
!!  2600 MH Delft, The Netherlands.
!!
MODULE MOD_IDFPLOT

USE WINTERACTER
USE RESOURCE
USE MOD_DBL
USE MODPLOT
USE IMODVAR 
USE MOD_COLOURS
USE MOD_PREF_PAR, ONLY : PREFVAL
USE MOD_UTL
USE MOD_IDF
USE MOD_MDF, ONLY : READMDF,MDFDEALLOCATE,MDF
USE MOD_IDF_PAR, ONLY : IDFOBJ
USE MOD_SOF, ONLY : SOF_COMPUTE_GRAD,SOF_COMPUTE_GRAD_3D
USE MOD_ASC2IDF, ONLY : ASC2IDF_IMPORTASC,ASC2IDF_IMPORTASC_TYPE5
USE MOD_NC2IDF, ONLY : NC2IDF_IMPORTNC,INETCDF
USE MOD_LEGEND, ONLY : LEG_CREATE_CLASSES,LEG_CREATE_COLORS
USE MOD_LEGEND_UTL, ONLY : LEG_READ
USE MOD_OSD, ONLY : OSD_OPEN
USE MOD_ISG_PLOT, ONLY : ISGPLOTMAIN
USE MOD_MAP2IDF, ONLY : MAP2IDF_IMPORTMAP
USE MOD_GEF2IPF, ONLY : GEF2IPF_MAIN
USE MOD_LEGPLOT, ONLY : LEGPLOT_PLOT_SHOW,LEGPLOT_PLOTUPDATE
USE MOD_POLYGON_PAR
USE MOD_POLYGON_DRAW, ONLY : POLYGON1DRAWSHAPE,POLYGON1DRAWYSEL
USE MOD_IPF_PAR, ONLY : NIPF
USE MOD_IR_PAR, ONLY : IRWIN
USE MOD_IR_PLOT, ONLY : IR1DRAWSHAPES
USE MOD_IR_GEN, ONLY : IR1GENDRAW
USE MOD_TAGS, ONLY : TAGDRAW
USE MOD_IDFTIMESERIE_UTL, ONLY : IDFTIMESERIE_PLUSPLOTPOINT
USE MOD_TOPO, ONLY : TOPO1DRAW,TOPO1UPDATEMANAGER
USE MOD_SCENTOOL_PLOT, ONLY : ST1DRAWSCENARIO
USE MOD_SOLID_PROFILE, ONLY : SOLID_PLOTLOCATION_CROSSSECTIONS
USE MOD_MODEL_UTL, ONLY : MODEL1DRAW_SIMBOX
USE MOD_IFF, ONLY : IFFDRAW,IFFGETUNIT
USE MOD_GEF2IPF_PAR, ONLY : GEFNAMES,IPFFNAME
USE MOD_GENPLOT, ONLY : GEN_DRAW,GENDRAW
USE MOD_IPF, ONLY : IPFDRAW,IPFINIT
USE MOD_OSD, ONLY : OSD_OPEN
USE MOD_ISG_PAR, ONLY : MAXFILES
USE MOD_ISG_PLOT, ONLY : ISGPLOTMINMAX
USE MOD_PROFILE_PAR, ONLY : AREA
USE MOD_PROFILE_UTL, ONLY : PROFILE_PUTBITMAP
USE MOD_GENPLOT_PAR, ONLY : GEN,MXGEN,ACTLISTGEN
USE MOD_TAGS, ONLY : TAGZOOM
USE MOD_MODEL_PAR, ONLY : SIMBOX

CONTAINS

 !###======================================================================
 SUBROUTINE IDFPLOTFAST(IFAST)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IFAST
 INTEGER :: I,J,N,IPLOT
 INTEGER,DIMENSION(4) :: ID = [ID_LOWACCURACY,ID_MEDIUMACCURACY,ID_HIGHACCURACY,ID_EXCELLENTACCURACY]
! DATA                   (ID(I),I=1,4) /ID_LOWACCURACY, ID_MEDIUMACCURACY, &
!                                       ID_HIGHACCURACY,ID_EXCELLENTACCURACY/

 !## check whether transparancy need to be checked off
 IF(WMENUGETSTATE(ID_TRANSPARANTIDF,2))THEN
  N=0
  DO IPLOT=1,MXMPLOT
   IF(MP(IPLOT)%ISEL.AND.(MP(IPLOT)%IPLOT.EQ.1.OR.MP(IPLOT)%IPLOT.EQ.4))N=N+1
  ENDDO
  IF(N.GT.10)THEN
   CALL WMESSAGEBOX(YESNOCANCEL,QUESTIONICON,COMMONYES,'Are you sure to display '//TRIM(ITOS(N))//' IDF files in transparancy?'//CHAR(13)// &
    'If not, choose [No] and iMOD turns transparancy off','Question')
   IF(WINFODIALOG(EXITBUTTONCOMMON).EQ.2)THEN
    CALL WMENUSETSTATE(ID_TRANSPARANTIDF,2,0)
   ENDIF
  ENDIF
 ENDIF

 IF(IFAST.EQ.0)THEN
  CALL IDFPLOT(1)
 ELSE
  CALL WINDOWSELECT(0)
  DO I=1,4
   IF(WMENUGETSTATE(ID(I),2).EQ.1)EXIT
  END DO
  CALL WMENUSETSTATE(ID(I),2,0)

  DO J=1,I,MAX(1,I-1)
   CALL WMENUSETSTATE(ID(J),2,1)
   IF(J.EQ.I)THEN
    CALL IDFPLOT(1)  !## final
   ELSE
    CALL IDFPLOT(0)  !## rough
   ENDIF
   CALL WMENUSETSTATE(ID(J),2,0)
  END DO
  CALL WMENUSETSTATE(ID(I),2,1)
 ENDIF

 !## refresh legend in legend tab
 CALL LEGPLOT_PLOT_SHOW()

 END SUBROUTINE IDFPLOTFAST

 !###======================================================================
 SUBROUTINE IDFPLOT(IPLOTFAST)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IPLOTFAST
 INTEGER :: IPLOT,IIBITMAP,I,N
 REAL(KIND=DP_KIND) :: XMIN,YMIN,XMAX,YMAX,XA1,YA1,XA2,YA2
 INTEGER,DIMENSION(4) :: IP
 LOGICAL :: LPLOT,LEX
 CHARACTER(LEN=256) :: FNAME

 CALL WINDOWSELECT(0)
 CALL UTL_MESSAGEHANDLE(0)

 IF(MPW%IWIN.GT.0)THEN
  IIBITMAP=WINFOBITMAP(MPW%IWIN,BITMAPHANDLE)
 ELSE
  IIBITMAP=MPW%IBITMAP
 ENDIF

 !## create 'mother' bitmap for current coordinates
 CALL WBITMAPCREATE(MPW%IBITMAP,MPW%DIX,MPW%DIY)

 !## set area/units
 CALL IGRPLOTMODE(MODECOPY)

 !## define drawable and units
 CALL UTL_PLOT1BITMAP()

 !## get active drawing area (local coordinate system)
 CALL IDFPLOT_FEATURES_AXES_CRD(XA1,YA1,XA2,YA2)

 !## topo-drawing - if not transparant
 CALL WINDOWSELECT(0)
 IF(WMENUGETSTATE(ID_TOPOGRAPHY,2).EQ.1.AND. &
    WMENUGETSTATE(ID_TOPOTRANSPARANCY,2).EQ.0)CALL TOPO1DRAW()

 !## polygons
 IF(IPLOTFAST.EQ.1)CALL GENDRAW()
 
 !## collect all other 'child' bitmaps
 DRWLIST=0
 I      =0
 DO IPLOT=1,MXMPLOT

  CALL UTL_FILLARRAY(IP,4,MP(IPLOT)%IDFKIND)
  !## grid colouring
  IF(SUM(IP).EQ.0)CYCLE
  !## temp. turn out contouring/texting
  IF(IPLOTFAST.EQ.0)THEN; IP(2)=0; IP(4)=0; ENDIF
  !## plot for active plot
  IF(.NOT.MP(IPLOT)%ISEL)CYCLE
  !## selected ones only (idf,mdf)
  IF(MP(IPLOT)%IPLOT.NE.1.AND.MP(IPLOT)%IPLOT.NE.5)CYCLE

  !## get idf for mdf file
  LEX=.TRUE.
  IF(MP(IPLOT)%IPLOT.EQ.5)THEN
   FNAME=MP(IPLOT)%IDFNAME
   !## read *.mdf file, only to get selected idf to be plotted
   IF(READMDF(MP(IPLOT)%IDFNAME,N))THEN
    MP(IPLOT)%IDFNAME=MDF(MP(IPLOT)%NLIDF)%FNAME
    CALL MDFDEALLOCATE()
   ELSE
    LEX=.FALSE.
   ENDIF
  ENDIF

  IF(LEX)THEN

   !## reread dimensions ... in case different idf is placed ...
   IF(IDFREAD(MP(IPLOT)%IDF,MP(IPLOT)%IDFNAME,0))THEN

    !## check whether current plot inside current plot-domain
    IF(MP(IPLOT)%IDF%XMIN.LT.MPW%XMAX.AND.MP(IPLOT)%IDF%XMAX.GE.MPW%XMIN.AND. &
       MP(IPLOT)%IDF%YMIN.LT.MPW%YMAX.AND.MP(IPLOT)%IDF%YMAX.GE.MPW%YMIN)THEN

     !## size of coord. fit in plotwindow
     XMIN=MAX(MP(IPLOT)%IDF%XMIN,MPW%XMIN); XMAX=MIN(MP(IPLOT)%IDF%XMAX,MPW%XMAX)
     YMIN=MAX(MP(IPLOT)%IDF%YMIN,MPW%YMIN); YMAX=MIN(MP(IPLOT)%IDF%YMAX,MPW%YMAX)

     LPLOT=.TRUE.
     IF(WMENUGETSTATE(ID_TRANSPARANTIDF,2).EQ.0.AND.   &
        WMENUGETSTATE(ID_TRANSPARANTNODATAIDF,2).EQ.0)THEN
      I=I+1  
      CALL IDFPLOTAREA(XMIN,YMIN,XMAX,YMAX,I,LPLOT)
     ENDIF
     !## plot anyhow
     IF(WMENUGETSTATE(ID_SHOWOPAQUE,2).EQ.1)LPLOT=.TRUE.
    
     !## draw idf in bitmap
      CALL UTL_PLOT1BITMAP()
      IF(IDFDRAW(MP(IPLOT)%IDF,MP(IPLOT)%LEG,MP(IPLOT)%UNITS,IP,XMIN,YMIN,XMAX,YMAX, &
         MP(IPLOT)%THICKNESS,LPLOT,UMIN=MP(IPLOT)%UMIN,UMAX=MP(IPLOT)%UMAX))DRWLIST(IPLOT)=1
      !## deallocate idf%x
     CALL IDFDEALLOCATEX(MP(IPLOT)%IDF)
    ENDIF
    CLOSE(MP(IPLOT)%IDF%IU); MP(IPLOT)%IDF%IU=0
   ENDIF
  ENDIF
  IF(MP(IPLOT)%IPLOT.EQ.5)THEN; MP(IPLOT)%IDFNAME=FNAME; ENDIF

 ENDDO

 CALL UTL_PLOT1BITMAP()

 !## topo-drawing
 CALL WINDOWSELECT(0)
 IF(WMENUGETSTATE(ID_TOPOGRAPHY,2).EQ.1.AND. &
    WMENUGETSTATE(ID_TOPOTRANSPARANCY,2).EQ.1)CALL TOPO1DRAW()

 IF(IPLOTFAST.EQ.1)THEN

  CALL IGRPLOTMODE(MODECOPY)
  CALL UTL_PLOT1BITMAP()
 
  !## draw gens from overlay tab
  CALL IGRPLOTMODE(MODECOPY); CALL UTL_PLOT1BITMAP(); CALL GEN_DRAW(0) 

! if(.not.idfread(e(1),'d:\IMOD-MODELS\SWISS\DBASE_VISP_II\ANI\VERSION_2\ELLIPS_RAT.IDF',1))then; endif
! if(.not.idfread(e(2),'d:\IMOD-MODELS\SWISS\DBASE_VISP_II\ANI\VERSION_2\ELLIPS_ANI.IDF',1))then; endif
! if(.not.idfread(e(3),'d:\IMOD-MODELS\SWISS\DBASE_VISP_II\ANI\VERSION_2\ELLIPS_LEN.IDF',1))then; endif
! call igrlinewidth(1)
! call igrlinetype(0)
! do irow=1,e(1)%nrow,25; do icol=1,e(1)%ncol,25
!  call idfgetloc(e(1),irow,icol,x,y)
!  if(e(1)%x(icol,irow).eq.e(1)%nodata)cycle
!  dxe=e(3)%x(icol,irow)/2.0
!  dye=dxe*e(1)%x(icol,irow)
!  rat=e(2)%x(icol,irow)
!  !## 90 for ellips drawing
!  CALL UTL_DRAWELLIPSE(x,y,dxe,dye,rat-90.0D0) !e(2)%x(icol,irow)-90.0D0)
! enddo; enddo
!
! if(.not.idfread(e(1),'d:\iMOD-TEST\IMODBATCH_KRIGING\rat.IDF',0))then; endif
! if(.not.idfread(e(2),'d:\iMOD-TEST\IMODBATCH_KRIGING\ANI.IDF',0))then; endif
! if(.not.idfread(e(3),'d:\iMOD-TEST\IMODBATCH_KRIGING\LEN.IDF',0))then; endif
! iu=utl_getunit(); open(iu,file='d:\iMOD-TEST\IMODBATCH_KRIGING\TEST.ipf',status='old',action='read')
! read(iu,*) nn
! read(iu,*) mm
! do i=1,mm+1; read(iu,*) ; enddo
! do i=1,nn
!  read(iu,*,iostat=ios) x,y
!  if(ios.ne.0)exit
!  rat=IDFGETXYVAL(e(2),x,y) !-1928.36,2517.28)
!  dxe=IDFGETXYVAL(e(3),x,y) !-1928.36,2517.28)
!  dye=dxe*IDFGETXYVAL(e(1),x,y) !-1928.36,2517.28)
!  CALL UTL_DRAWELLIPSE(x,y,dxe,dye,rat-90.0D0) !e(2)%x(icol,irow)-90.0D0)
! enddo
! close(iu)
 
  !## imod isg plotting!!!
  CALL IGRPLOTMODE(MODECOPY)
  CALL UTL_PLOT1BITMAP()
  DO IPLOT=1,MXMPLOT
   IF(MP(IPLOT)%ISEL.AND.MP(IPLOT)%IPLOT.EQ.4)THEN
    CALL UTL_PLOT1BITMAP()
    CALL ISGPLOTMAIN(IPLOT,MPW%XMIN,MPW%YMIN,MPW%XMAX,MPW%YMAX)
   ENDIF
  END DO

  !## imodflow-line-files plotting!!!
  CALL IGRPLOTMODE(MODECOPY); CALL UTL_PLOT1BITMAP(); CALL IFFDRAW()

  !## imod-point-files plotting!!!
  CALL IGRPLOTMODE(MODECOPY); CALL UTL_PLOT1BITMAP(); CALL IPFDRAW() 

  !## esri-gen files plotting!!! 
  CALL IGRPLOTMODE(MODECOPY); CALL UTL_PLOT1BITMAP(); CALL GENDRAW()

  IF(WMENUGETSTATE(ID_RUNMODEL,2).EQ.1)CALL MODEL1DRAW_SIMBOX()

  IF(WMENUGETSTATE(ID_IRDATABASE,2).EQ.1)THEN
   !## from previous itree/ifield
   CALL IR1DRAWSHAPES(2)

   !## draw gen-file
   CALL IR1GENDRAW()

  ENDIF

  CALL POLYGON1DRAWSHAPE(1,SHP%NPOL,LPLOT=.FALSE.)

  !## draw selected points in idftimeserie
  CALL IDFTIMESERIE_PLUSPLOTPOINT()

  !## draw features from the scenario tool
  IF(WMENUGETSTATE(ID_SCENTOOL,2).EQ.1)CALL ST1DRAWSCENARIO()

  !## draw location of cross-sections in case solid modeling is active and profile tool is on!
  IF(WMENUGETSTATE(ID_SOLIDS,2).EQ.1)THEN 
   CALL UTL_PLOT1BITMAP()
   CALL IGRPLOTMODE(MODECOPY)
   CALL SOLID_PLOTLOCATION_CROSSSECTIONS()
  ENDIF

 ENDIF

 !## draw external features
 CALL IGRPLOTMODE(MODECOPY)
 CALL UTL_PLOT1BITMAP()
 CALL IDFPLOT_FEATURES()

 !## tag-drawing
 CALL TAGDRAW()

 CALL UTL_PLOT2BITMAP()

 IF(IIBITMAP.NE.0.AND.IIBITMAP.NE.MPW%IBITMAP)CALL WBITMAPDESTROY(IIBITMAP)

 !## legend plotting
 IF(IPLOTFAST.EQ.1)CALL LEGPLOT_PLOTUPDATE()

 CALL UTL_MESSAGEHANDLE(1)

 END SUBROUTINE IDFPLOT

!###======================================================================
SUBROUTINE IDFPLOT_CONTOUR(IDF,LEG,IP,THICKNESS)
!###======================================================================
IMPLICIT NONE
TYPE(IDFOBJ),INTENT(INOUT) :: IDF
TYPE(LEGENDOBJ),INTENT(INOUT) :: LEG
INTEGER,INTENT(IN),DIMENSION(3) :: IP
INTEGER,INTENT(IN) :: THICKNESS
REAL(KIND=DP_KIND),ALLOCATABLE,DIMENSION(:) :: DELR,DELC,XC,YC
INTEGER :: I,ICLR
REAL(KIND=DP_KIND) :: TWIDTH,THEIGHT,DXS,DYS,DX
CHARACTER(LEN=15) :: STR

ALLOCATE(DELR(IDF%NCOL),DELC(IDF%NROW),XC(IDF%NCOL),YC(IDF%NROW))

IF(IDF%IEQ.EQ.0)THEN
 XC(1)=IDF%XMIN+IDF%DX/2.0D0
 DO I=2,IDF%NCOL; XC(I)=XC(I-1)+IDF%DX; ENDDO
 YC(IDF%NROW)=IDF%YMIN+IDF%DY/2.0D0
 DO I=IDF%NROW-1,1,-1; YC(I)=YC(I+1)+IDF%DY; ENDDO
 DELR=IDF%DX; DELC=IDF%DY
ELSEIF(IDF%IEQ.EQ.1)THEN
 DO I=1,IDF%NCOL; XC(I)  =(IDF%SX(I-1)+IDF%SX(I))/2.0D0; ENDDO
 DO I=1,IDF%NCOL; DELR(I)= IDF%SX(I)-IDF%SX(I-1)       ; ENDDO
 DO I=1,IDF%NROW; YC(I)  =(IDF%SY(I-1)+IDF%SY(I))/2.0D0; ENDDO
 DO I=1,IDF%NROW; DELC(I)= IDF%SY(I-1)-IDF%SY(I)       ; ENDDO
ENDIF

!## allocate memory for labeling
ALLOCATE(CONT(100)); NLAB=0
LABDIST=0.10D0*SQRT((MPW%YMAX-MPW%YMIN)**2.0D0+(MPW%XMAX-MPW%XMIN)**2.0D0)

CALL IGRLINECAP(ROUNDCAP)
CALL IGRLINEJOIN(ROUNDJOIN)

DO I=0,LEG%NCLR
 CALL IGRLINEWIDTH(MAX(1,ABS(THICKNESS)))
 IF(MOD(I,5).EQ.0)CALL IGRLINEWIDTH(MAX(ABS(THICKNESS)-1,1))
 IF(IP(1).EQ.0)THEN
  ICLR=UTL_IDFGETCLASS(LEG,LEG%CLASS(I))
 ELSE
  ICLR=WRGB(0,0,0) 
 ENDIF 
 CALL IGRCOLOURN(ICLR)
 CALL IDFPLOT_COMPCONTOUR(IDF%X,IDF%NCOL,IDF%NROW,XC,YC,LEG%CLASS(I),IDF%NODATA,THICKNESS)
ENDDO

CALL IGRLINEJOIN()
CALL IGRLINECAP()

IF(THICKNESS.GT.0)THEN
 CALL UTL_SETTEXTSIZE(TWIDTH,THEIGHT,FCT=3.0D0+DBLE(THICKNESS))
 CALL DBL_WGRTEXTFONT(IFAMILY=FFHELVETICA,TWIDTH=TWIDTH,THEIGHT=THEIGHT,ISTYLE=0)
 DXS=WINFOGRREAL(GRAPHICSCHWIDTH)
 DYS=WINFOGRREAL(GRAPHICSCHHEIGHT)

 CALL IGRFILLPATTERN(SOLID)
 DO I=1,NLAB
  STR=UTL_REALTOSTRING(CONT(I)%VLAB)
  DX=WGRTEXTLENGTH(' '//TRIM(STR)//' ',0)*DXS
  CALL IDFPLOT_CLEANBOX(CONT(I)%XLAB,CONT(I)%YLAB,CONT(I)%ALAB,DX,DYS*0.8D0,WRGB(255,255,255)) 
  CALL DBL_WGRTEXTORIENTATION(IALIGN=ALIGNCENTRE,ANGLE=CONT(I)%ALAB) 
  CALL IGRCOLOURN(WRGB(0,0,0))
  CALL DBL_WGRTEXTSTRING(CONT(I)%XLAB,CONT(I)%YLAB,TRIM(STR),IOFFSET=1)
 ENDDO
ENDIF

CALL IGRFILLPATTERN(OUTLINE)

IF(ASSOCIATED(CONT))DEALLOCATE(CONT); NLAB=0
DEALLOCATE(DELR,DELC,XC,YC)

END SUBROUTINE IDFPLOT_CONTOUR

!###======================================================================
SUBROUTINE IDFPLOT_CLEANBOX(X,Y,ANGLE,DX,DY,ICLR)
!###======================================================================
IMPLICIT NONE
REAL(KIND=DP_KIND),INTENT(IN) :: X,Y,ANGLE,DX,DY
INTEGER,INTENT(IN) :: ICLR
REAL(KIND=DP_KIND),DIMENSION(6) :: XC,YC
REAL(KIND=DP_KIND) :: RAD

IF(DX.LE.0.0D0)RETURN
CALL IGRCOLOURN(ICLR)

RAD=ANGLE/(360.0D0/(2.0D0*PI))
XC(6)=X-(COS(RAD)*0.5D0*DX); YC(6)=Y-(SIN(RAD)*0.5D0*DX)
XC(5)=X+(COS(RAD)*0.5D0*DX); YC(5)=Y+(SIN(RAD)*0.5D0*DX)

RAD=(ANGLE+90.0D0)/(360.0D0/(2.0*PI))
XC(1)=XC(6)-(COS(RAD)*0.5D0*DY); YC(1)=YC(6)-(SIN(RAD)*0.5D0*DY)
XC(2)=XC(5)-(COS(RAD)*0.5D0*DY); YC(2)=YC(5)-(SIN(RAD)*0.5D0*DY)
XC(3)=XC(5)+(COS(RAD)*0.5D0*DY); YC(3)=YC(5)+(SIN(RAD)*0.5D0*DY)
XC(4)=XC(6)+(COS(RAD)*0.5D0*DY); YC(4)=YC(6)+(SIN(RAD)*0.5D0*DY)

CALL DBL_IGRPOLYGONCOMPLEX(XC,YC,4,IOFFSET=1)

END SUBROUTINE IDFPLOT_CLEANBOX

!###======================================================================
SUBROUTINE IDFPLOT_PUTLABEL(X1,Y1,X2,Y2,V,INILAB,XMIN,YMIN,XMAX,YMAX)
!###======================================================================
IMPLICIT NONE
REAL(KIND=DP_KIND),INTENT(IN) :: X1,Y1,X2,Y2,V,XMIN,YMIN,XMAX,YMAX
INTEGER,INTENT(INOUT) :: INILAB
INTEGER :: IOK,I
REAL(KIND=DP_KIND) :: X12,Y12,D,DE

!!## if segment too short do not place a label
!D=(X1-X2)**2.0D0+(Y1-Y2)**2.0D0; IF(D.GT.0.0D0)D=SQRT(D)
!IF(D.LT.LABDIST/10.0D0)RETURN

X12=(X1+X2)/2.0D0; Y12=(Y1+Y2)/2.0D0
IOK=1; IF(NLAB.GT.0)THEN
 DO I=1,NLAB
  D =(X12-CONT(I)%XLAB)**2.0D0+(Y12-CONT(I)%YLAB)**2.0D0; IF(D.GT.0.0D0)D=SQRT(D)
  IF(V.EQ.CONT(I)%VLAB)THEN
   !## to close to another label
   IF(D.LT.LABDIST)THEN; IOK=0; EXIT; ENDIF
  ELSE
   !## to close to another label
   IF(D.LT.LABDIST/5.0D0)THEN; IOK=0; EXIT; ENDIF
  ENDIF
 ENDDO
!## first label not too close to edge of graphical canvas
ENDIF
!## take edge into account
IF(INILAB.EQ.0)THEN
 DE=MIN(ABS(X12-XMIN),ABS(X12-XMAX),ABS(Y12-YMIN),ABS(Y12-YMAX))
 IF(DE.LT.LABDIST/2.0D0)IOK=0
ENDIF

IF(IOK.EQ.0)RETURN
INILAB=INILAB+1

IF(NLAB+1.GT.SIZE(CONT))THEN
 ALLOCATE(CONT_BU(NLAB+100))
 CONT_BU(1:NLAB)=CONT(1:NLAB)
 DEALLOCATE(CONT); CONT=>CONT_BU
ENDIF

NLAB=NLAB+1
CONT(NLAB)%XLAB=X12 
CONT(NLAB)%YLAB=Y12 
!## store angle
IF(X1.NE.X2) THEN
 CONT(NLAB)%ALAB=ATAN((Y1-Y2)/(X1-X2))/PI*180.0D0
ELSE
 CONT(NLAB)%ALAB=90.0D0
ENDIF
!## store label-value
CONT(NLAB)%VLAB=V

END SUBROUTINE IDFPLOT_PUTLABEL

!###======================================================================
SUBROUTINE IDFPLOT_COMPCONTOUR(XVAL,NCOL,NROW,XC,YC,V,XNODATA,THICKNESS)
!###======================================================================
IMPLICIT NONE
INTEGER,INTENT(IN) :: NCOL,NROW,THICKNESS
REAL(KIND=DP_KIND),INTENT(IN) :: XNODATA,V
REAL(KIND=DP_KIND),INTENT(IN),DIMENSION(NCOL,NROW) :: XVAL
REAL(KIND=DP_KIND),INTENT(IN),DIMENSION(NCOL) :: XC
REAL(KIND=DP_KIND),INTENT(IN),DIMENSION(NROW) :: YC
REAL(KIND=DP_KIND),DIMENSION(8) :: XS,YS
INTEGER :: I,J,II,INILAB,IROW,ICOL
REAL(KIND=DP_KIND) :: XMIN,YMIN,XMAX,YMAX,DX,DY,DA,DV
REAL(KIND=DP_KIND),DIMENSION(4) :: A
REAL(KIND=DP_KIND),DIMENSION(4) :: X,Y
INTEGER,DIMENSION(2,8) :: POS
DATA POS/1,3,1,2,2,4,2,3,3,1,3,4,4,2,4,1/

INILAB=0
XMIN=MAX(MPW%XMIN,XC(1)); XMAX=MIN(MPW%XMAX,XC(NCOL))
YMIN=MAX(MPW%YMIN,YC(NROW)); YMAX=MIN(MPW%YMAX,YC(1))

DO ICOL=1,NCOL-1
 DO IROW=2,NROW

  A(1)=XVAL(ICOL,IROW); A(2)=XVAL(ICOL+1,IROW); A(3)=XVAL(ICOL+1,IROW-1); A(4)=XVAL(ICOL,IROW-1)

  !## skip flat areas
  J=0; DO I=1,4; IF(A(I).EQ.V)J=J+1; ENDDO; IF(J.EQ.4)CYCLE

  !## skip nodata areas  
  J=0; DO I=1,4; IF(A(I).EQ.XNODATA)J=J+1; ENDDO; IF(J.NE.0)CYCLE 

  !## midpoints
  X(1)=XC(ICOL); X(2)=XC(ICOL+1); X(3)=X(2); X(4)=X(1)
  Y(1)=YC(IROW); Y(2)=Y(1); Y(3)=YC(IROW-1); Y(4)=Y(3)
    
  !## set contour-line
  II=0
  DO I=2,8,2 !1,8 !2,8,2
   IF((V.GE.A(POS(1,I)).AND.V.LT.A(POS(2,I))).OR. &
      (V.GE.A(POS(2,I)).AND.V.LT.A(POS(1,I))))THEN
        
    DA=A(POS(2,I))-A(POS(1,I))
    DV=V-A(POS(1,I))
    DX=X(POS(2,I))-X(POS(1,I))
    DY=Y(POS(2,I))-Y(POS(1,I))

!    !## diagonal if over half, skip it
!    IF(MOD(I,2).NE.0)THEN
!     IF(ABS(DV/DA).GT.0.5)CYCLE
!    ENDIF
    
    II=II+1
    XS(II)=X(POS(1,I))+DV/DA*DX
    YS(II)=Y(POS(1,I))+DV/DA*DY

   ENDIF
  ENDDO
  
  DO I=1,II-1; CALL DBL_IGRJOIN(XS(I),YS(I),XS(I+1),YS(I+1),IOFFSET=1); ENDDO
  !## add label
  IF(II.GT.1.AND.THICKNESS.GT.0)CALL IDFPLOT_PUTLABEL(XS(1),YS(1),XS(2),YS(2),V,INILAB,XMIN,YMIN,XMAX,YMAX)

 ENDDO
ENDDO

END SUBROUTINE IDFPLOT_COMPCONTOUR
       
!###======================================================================
SUBROUTINE IDFPLOT_FEATURES()
!###======================================================================
IMPLICIT NONE

CALL WINDOWSELECT(0)
IF(WMENUGETSTATE(ID_IDFRASTERLINES,2).EQ.1)CALL IDFPLOT_FEATURES_RASTER()
CALL IDFPLOT_FEATURES_EXTENT()
IF(WMENUGETSTATE(ID_SHOWAXES,2).EQ.1)CALL IDFPLOT_FEATURES_AXES()
IF(WMENUGETSTATE(ID_SHOWSCALEBAR,2).EQ.1)THEN
 CALL IDFPLOT_FEATURES_SCALE()
 CALL DBL_IGRAREA(0.0D0,0.0D0,1.0D0,1.0D0)
 CALL DBL_IGRUNITS(MPW%XMIN,MPW%YMIN,MPW%XMAX,MPW%YMAX,IOFFSET=1)
ENDIF
IF(WMENUGETSTATE(ID_SHOWNARROW,2).EQ.1)CALL IDFPLOT_FEATURES_NARROW()

END SUBROUTINE IDFPLOT_FEATURES

 !###======================================================================
 SUBROUTINE IDFPLOT_FEATURES_AXES_SELECT(X,Y)
 !###======================================================================
 IMPLICIT NONE
 REAL(KIND=DP_KIND),INTENT(IN) :: X,Y
 REAL(KIND=DP_KIND) :: XA1,YA1,XA2,YA2
 INTEGER :: IEDGE,I

 IF(WMENUGETSTATE(ID_SHOWAXES,2).EQ.0)RETURN
 
 CALL IDFPLOT_FEATURES_AXES_CRD(XA1,YA1,XA2,YA2)

 IEDGE=UTL_SELECTIEDGE(X-OFFSETX,Y-OFFSETY,XA1,YA1,XA2,YA2)
  
 !## remove previous selected line - if that is something else
 IF(SUM(IMOVEAX).NE.0)THEN
  DO I=1,SIZE(IMOVEAX); IF(IMOVEAX(I).EQ.1)EXIT; ENDDO
  CALL IDFPLOT_FEATURES_AXES_DRAWBOX()
 ENDIF
 
 IMOVEAX=0
 IF(IEDGE.NE.0)THEN
  IMOVEAX(IEDGE)=1
  CALL IDFPLOT_FEATURES_AXES_DRAWBOX()
 ENDIF
 
 END SUBROUTINE IDFPLOT_FEATURES_AXES_SELECT

 !###======================================================================
 SUBROUTINE IDFPLOT_FEATURES_AXES_CRD(XA1,YA1,XA2,YA2)
 !###======================================================================
 IMPLICIT NONE
 REAL(KIND=DP_KIND),INTENT(OUT) :: XA1,YA1,XA2,YA2
 REAL(KIND=DP_KIND) :: DX,DY,WX1,WX2,WY1,WY2

 WX1=DBLE(WINFOGRREAL(GRAPHICSUNITMINX)) ! (7)  left  limit of main graphics area
 WY1=DBLE(WINFOGRREAL(GRAPHICSUNITMINY)) ! (8)  lower limit of main graphics area
 WX2=DBLE(WINFOGRREAL(GRAPHICSUNITMAXX)) ! (9)  right limit of main graphics area
 WY2=DBLE(WINFOGRREAL(GRAPHICSUNITMAXY)) ! (10) upper limit of main graphics area

 DX =WX2-WX1;       DY =WY2-WY1
 XA1=WX1+AX_XP1*DX; XA2=WX1+AX_XP2*DX
 YA1=WY1+AX_YP1*DY; YA2=WY1+AX_YP2*DY

 END SUBROUTINE IDFPLOT_FEATURES_AXES_CRD
 
 !###======================================================================
 SUBROUTINE IDFPLOT_FEATURES_AXES_MOVE(X,Y,X0,Y0)
 !###======================================================================
 IMPLICIT NONE
 REAL(KIND=DP_KIND),INTENT(IN) :: X,Y,X0,Y0

 CALL IDFPLOT_FEATURES_AXES_DRAWBOX()
 CALL IDFPLOT_FEATURES_MOVE(X,Y,X0,Y0,IMOVEAX,AX_XP1,AX_YP1,AX_XP2,AX_YP2)
 CALL IDFPLOT_FEATURES_AXES_DRAWBOX()
 
 END SUBROUTINE IDFPLOT_FEATURES_AXES_MOVE
 
 !###======================================================================
 SUBROUTINE IDFPLOT_FEATURES_AXES_DRAWBOX()
 !###======================================================================
 IMPLICIT NONE
 REAL(KIND=DP_KIND) :: XA1,YA1,XA2,YA2

 CALL IGRPLOTMODE(MODEXOR)
 CALL IGRCOLOURN(WRGB(255,0,0))
 CALL IGRFILLPATTERN(OUTLINE)

 CALL UTL_PLOT1BITMAP()
 CALL IDFPLOT_FEATURES_AXES_CRD(XA1,YA1,XA2,YA2)
 IF(    IMOVEAX(1).EQ.1)THEN
  CALL DBL_IGRJOIN(XA1,YA1,XA1,YA2)
 ELSEIF(IMOVEAX(2).EQ.1)THEN
  CALL DBL_IGRJOIN(XA2,YA1,XA2,YA2)
 ELSEIF(IMOVEAX(3).EQ.1)THEN
  CALL DBL_IGRJOIN(XA1,YA1,XA2,YA1)
 ELSEIF(IMOVEAX(4).EQ.1)THEN
  CALL DBL_IGRJOIN(XA1,YA2,XA2,YA2)
 ELSE
  CALL DBL_IGRRECTANGLE(XA1,YA1,XA2,YA2)
 ENDIF
 
 CALL UTL_PLOT2BITMAP()

 CALL IGRPLOTMODE(MODECOPY)
 CALL IGRFILLPATTERN(OUTLINE)
 CALL IGRLINETYPE(SOLIDLINE)

 END SUBROUTINE IDFPLOT_FEATURES_AXES_DRAWBOX 
 
 !###======================================================================
 SUBROUTINE IDFPLOT_FEATURES_AXES()
 !###======================================================================
 IMPLICIT NONE
 INTEGER,PARAMETER :: N=10
 INTEGER :: I,J,IRASTER
 REAL(KIND=DP_KIND) :: V1,VI,X1,X2,Y1,Y2,TWIDTH,THEIGHT
 REAL(KIND=DP_KIND) :: XA1,YA1,XA2,YA2,MINORTIC,MAJORTIC,OFFSTTXT,DXX 
 REAL(KIND=DP_KIND) :: WX1,WX2,WY1,WY2
 CHARACTER(LEN=10) :: FRM

 WX1=REAL(WINFOGRREAL(GRAPHICSUNITMINX),8) ! (7)  left  limit of main graphics area
 WY1=REAL(WINFOGRREAL(GRAPHICSUNITMINY),8) ! (8)  lower limit of main graphics area
 WX2=REAL(WINFOGRREAL(GRAPHICSUNITMAXX),8) ! (9)  right limit of main graphics area
 WY2=REAL(WINFOGRREAL(GRAPHICSUNITMAXY),8) ! (10) upper limit of main graphics area

 IRASTER=WMENUGETSTATE(ID_SHOWRASTERLINES,2)

 !## get coordinates of axes
 CALL IDFPLOT_FEATURES_AXES_CRD(XA1,YA1,XA2,YA2)

 DXX=MIN((MPW%XMAX-MPW%XMIN),(MPW%YMAX-MPW%YMIN))
 MINORTIC=DXX*0.005D0
 MAJORTIC=DXX*0.010D0
 OFFSTTXT=DXX*0.020D0

 !## textsize
 CALL UTL_SETTEXTSIZE(TWIDTH,THEIGHT,FCT=6.0D0)

 CALL IGRFILLPATTERN(SOLID)
 CALL IGRCOLOURN(WRGB(255,255,255))
 CALL DBL_IGRRECTANGLE(WX1,WY1,WX2,YA1)  !## bottom
 CALL DBL_IGRRECTANGLE(XA2,WY1,WX2,WY2)  !## right
 CALL DBL_IGRRECTANGLE(WX1,WY2,WX2,YA2)  !## top
 CALL DBL_IGRRECTANGLE(WX1,WY1,XA1,WY2)  !## left

 !## bounding box
 CALL IGRFILLPATTERN(OUTLINE); CALL IGRLINEWIDTH(2); CALL IGRCOLOURN(WRGB(0,0,0))
 CALL DBL_IGRRECTANGLE(XA1,YA1,XA2,YA2)

 !## transform to correct coordinates
 XA1=XA1+OFFSETX; XA2=XA2+OFFSETX
 YA1=YA1+OFFSETY; YA2=YA2+OFFSETY

 !## get scale axes

 !## make sure both axes have similar length
 DX=XA2-XA1
 DY=YA2-YA1
 IF(DX.GT.DY)THEN
  DY=0.5D0*(DX-DY )
  DX=0.0D0
 ELSE
  DX=0.5D0*(DY-DX)
  DY=0.0D0
 ENDIF

 CALL UTL_GETAXESCALES(XA1-DX,YA1-DY,XA2+DX,YA2+DY) 

 !## x-axes interval
 VI=SXVALUE(2)-SXVALUE(1)

 Y1=YA1
 Y2=YA2

 CALL DBL_WGRTEXTFONT(IFAMILY=FFHELVETICA,TWIDTH=TWIDTH/1.5D0,THEIGHT=THEIGHT/1.5D0,ISTYLE=0)
 CALL DBL_WGRTEXTORIENTATION(IALIGN=ALIGNCENTRE,ANGLE=0.0D0,NALIGN=ALIGNCENTRE)

 !## minor ticks along x-axes
 CALL IGRLINEWIDTH(1)
 !## check whether interval is large enough
 DO
  IF(.NOT.UTL_EQUALS_REAL(SXVALUE(1)-VI/4.0D0,SXVALUE(1)))EXIT
  VI=VI*2.0D0
 ENDDO
 V1=SXVALUE(1)-VI
 I=0
 DO
  I=I+1
  V1=V1+VI/4.0D0
  IF(V1.GT.XA2)EXIT 
  IF(V1.GT.XA1)THEN 
   CALL DBL_IGRJOIN(V1,Y1-MINORTIC,V1,Y1+MINORTIC,IOFFSET=1)
   CALL DBL_IGRJOIN(V1,Y2-MINORTIC,V1,Y2+MINORTIC,IOFFSET=1)

   IF(MOD(I,4).NE.0.AND.MOD(I,2).EQ.0)THEN
    FRM=TRIM(UTL_GETFORMAT(V1/1000.0D0))
    J=INDEX(FRM,'.00)',.TRUE.)
    IF(J.EQ.0)THEN
     CALL DBL_WGRTEXTREAL(V1,Y1-OFFSTTXT,V1/1000.0D0,FRM,IOFFSET=1)
     CALL DBL_WGRTEXTREAL(V1,Y2+OFFSTTXT,V1/1000.0D0,FRM,IOFFSET=1)
    ELSE
     CALL DBL_WGRTEXTINTEGER(V1,Y1-OFFSTTXT,INT(V1/1000.0D0),IOFFSET=1)
     CALL DBL_WGRTEXTINTEGER(V1,Y2+OFFSTTXT,INT(V1/1000.0D0),IOFFSET=1)
    ENDIF
   ENDIF
 
  ENDIF
 END DO

 CALL DBL_WGRTEXTFONT(IFAMILY=FFHELVETICA,TWIDTH=TWIDTH,THEIGHT=THEIGHT,ISTYLE=0)
 CALL DBL_WGRTEXTORIENTATION(IALIGN=ALIGNCENTRE,ANGLE=0.0D0,NALIGN=ALIGNCENTRE)

 !## major ticks
 CALL IGRLINEWIDTH(2)
 V1=SXVALUE(1)-VI
 DO
  V1=V1+VI
  IF(V1.GT.XA2)EXIT 
  IF(V1.GT.XA1)THEN 
  
   CALL IGRLINEWIDTH(2)
   CALL IGRLINETYPE(SOLIDLINE)
   CALL DBL_IGRJOIN(V1,Y1-MAJORTIC,V1,Y1+MAJORTIC,IOFFSET=1)
   CALL DBL_IGRJOIN(V1,Y2-MAJORTIC,V1,Y2+MAJORTIC,IOFFSET=1)

   IF(IRASTER.EQ.1)THEN
    CALL IGRCOLOURN(WRGB(20,20,20))
    CALL IGRLINEWIDTH(1)
    CALL IGRLINETYPE(DOTTED)
    CALL DBL_IGRJOIN(V1,Y1+MAJORTIC,V1,Y2-MAJORTIC,IOFFSET=1)
    CALL IGRLINETYPE(SOLIDLINE)
    CALL IGRCOLOURN(WRGB(0,0,0))
   ENDIF
   
   FRM=TRIM(UTL_GETFORMAT(V1/1000.0D0))
   J=INDEX(FRM,'.00)',.TRUE.)
   IF(J.EQ.0)THEN
    CALL DBL_WGRTEXTREAL(V1,Y1-OFFSTTXT,V1/1000.0D0,FRM,IOFFSET=1)
    CALL DBL_WGRTEXTREAL(V1,Y2+OFFSTTXT,V1/1000.0D0,FRM,IOFFSET=1)
   ELSE
    CALL DBL_WGRTEXTINTEGER(V1,Y1-OFFSTTXT,INT(V1/1000.0D0),IOFFSET=1)
    CALL DBL_WGRTEXTINTEGER(V1,Y2+OFFSTTXT,INT(V1/1000.0D0),IOFFSET=1)
   ENDIF
  ENDIF
 END DO

 !## y-axes

 !## minor ticks

 CALL DBL_WGRTEXTFONT(IFAMILY=FFHELVETICA,TWIDTH=TWIDTH/1.5D0,THEIGHT=THEIGHT/1.5D0,ISTYLE=0)
 CALL DBL_WGRTEXTORIENTATION(IALIGN=ALIGNCENTRE,ANGLE=90.0D0,NALIGN=ALIGNCENTRE)

 !## y-axes interval
 VI=SYVALUE(2)-SYVALUE(1)

 X1=XA1
 X2=XA2
 CALL IGRLINEWIDTH(1)
 !## check whether interval is large enough
 DO
  IF(.NOT.UTL_EQUALS_REAL(SYVALUE(1)-VI/4.0D0,SYVALUE(1)))EXIT
  VI=VI*2.0D0
 ENDDO

 V1=SYVALUE(1)-VI
 I=0
 DO
  I=I+1
  V1=V1+VI/4.0D0
  IF(V1.GT.YA2)EXIT 
  IF(V1.GT.YA1)THEN 
   CALL DBL_IGRJOIN(X1-MINORTIC,V1,X1+MINORTIC,V1,IOFFSET=1)
   CALL DBL_IGRJOIN(X2-MINORTIC,V1,X2+MINORTIC,V1,IOFFSET=1)
  
   IF(MOD(I,4).NE.0.AND.MOD(I,2).EQ.0)THEN
    FRM=TRIM(UTL_GETFORMAT(V1/1000.0D0))
    J=INDEX(FRM,'.00)',.TRUE.)
    IF(J.EQ.0)THEN
     CALL DBL_WGRTEXTREAL(X1-OFFSTTXT,V1,V1/1000.0D0,FRM,IOFFSET=1)
     CALL DBL_WGRTEXTREAL(X2+OFFSTTXT,V1,V1/1000.0D0,FRM,IOFFSET=1)
    ELSE
     CALL DBL_WGRTEXTINTEGER(X1-OFFSTTXT,V1,INT(V1/1000.0D0),IOFFSET=1)
     CALL DBL_WGRTEXTINTEGER(X2+OFFSTTXT,V1,INT(V1/1000.0D0),IOFFSET=1)
    ENDIF
   ENDIF
 
  ENDIF
 END DO

 !## major ticks

 CALL DBL_WGRTEXTFONT(IFAMILY=FFHELVETICA,TWIDTH=TWIDTH,THEIGHT=THEIGHT,ISTYLE=0)

 CALL IGRLINEWIDTH(2)
 V1=SYVALUE(1)-VI
 DO
  V1=V1+VI
  IF(V1.GT.YA2)EXIT 
  IF(V1.GT.YA1)THEN 

   CALL IGRLINEWIDTH(2)
   CALL IGRLINETYPE(SOLIDLINE)
   CALL DBL_IGRJOIN(X1-MAJORTIC,V1,X1+MAJORTIC,V1,IOFFSET=1)
   CALL DBL_IGRJOIN(X2-MAJORTIC,V1,X2+MAJORTIC,V1,IOFFSET=1)

   IF(IRASTER.EQ.1)THEN
    CALL IGRCOLOURN(WRGB(20,20,20))
    CALL IGRLINEWIDTH(1)
    CALL IGRLINETYPE(DOTTED)
    CALL DBL_IGRJOIN(X1+MAJORTIC,V1,X2-MAJORTIC,V1,IOFFSET=1)
    CALL IGRLINETYPE(SOLIDLINE)
    CALL IGRCOLOURN(WRGB(0,0,0))
   ENDIF
   
   FRM=TRIM(UTL_GETFORMAT(V1/1000.0D0))
   J=INDEX(FRM,'.00)',.TRUE.)
   IF(J.EQ.0)THEN
    CALL DBL_WGRTEXTREAL(X1-OFFSTTXT,V1,V1/1000.0D0,FRM,IOFFSET=1)
    CALL DBL_WGRTEXTREAL(X2+OFFSTTXT,V1,V1/1000.0D0,FRM,IOFFSET=1)
   ELSE
    CALL DBL_WGRTEXTINTEGER(X1-OFFSTTXT,V1,INT(V1/1000.0D0),IOFFSET=1)
    CALL DBL_WGRTEXTINTEGER(X2+OFFSTTXT,V1,INT(V1/1000.0D0),IOFFSET=1)
   ENDIF
  ENDIF
 END DO

 CALL DBL_WGRTEXTORIENTATION(IALIGN=ALIGNLEFT,ANGLE=0.0D0)
 CALL IGRLINEWIDTH(1)

 END SUBROUTINE IDFPLOT_FEATURES_AXES

 !###======================================================================
 SUBROUTINE IDFPLOT_FEATURES_SCALE_CRD(XA1,YA1,XA2,YA2)
 !###======================================================================
 IMPLICIT NONE
 REAL(KIND=DP_KIND),INTENT(OUT) :: XA1,YA1,XA2,YA2
 REAL(KIND=DP_KIND) :: DX,DY,WX1,WX2,WY1,WY2

 WX1=REAL(WINFOGRREAL(GRAPHICSUNITMINX),8) ! (7)  left  limit of main graphics area
 WY1=REAL(WINFOGRREAL(GRAPHICSUNITMINY),8) ! (8)  lower limit of main graphics area
 WX2=REAL(WINFOGRREAL(GRAPHICSUNITMAXX),8) ! (9)  right limit of main graphics area
 WY2=REAL(WINFOGRREAL(GRAPHICSUNITMAXY),8) ! (10) upper limit of main graphics area

 DX =WX2-WX1;       DY =WY2-WY1
 XA1=WX1+SB_XP1*DX; XA2=WX1+SB_XP2*DX
 YA1=WY1+SB_YP1*DY; YA2=WY1+SB_YP2*DY

 END SUBROUTINE IDFPLOT_FEATURES_SCALE_CRD
 
 !###======================================================================
 SUBROUTINE IDFPLOT_FEATURES_SCALE_SELECT(X,Y)
 !###======================================================================
 IMPLICIT NONE
 REAL(KIND=DP_KIND),INTENT(IN) :: X,Y
 REAL(KIND=DP_KIND) :: XA1,YA1,XA2,YA2
 INTEGER :: I,IEDGE
 
 IF(WMENUGETSTATE(ID_SHOWSCALEBAR,2).EQ.0)RETURN
 
 CALL IDFPLOT_FEATURES_SCALE_CRD(XA1,YA1,XA2,YA2)

 IEDGE=UTL_SELECTIEDGE(X-OFFSETX,Y-OFFSETY,XA1,YA1,XA2,YA2)
  
 !## remove previous selected line - if that is something else
 IF(SUM(IMOVESC).NE.0)THEN
  DO I=1,SIZE(IMOVESC); IF(IMOVESC(I).EQ.1)EXIT; ENDDO
  CALL IDFPLOT_FEATURES_SCALE_DRAWBOX()
 ENDIF
 
 IMOVESC=0
 IF(IEDGE.NE.0)THEN
  IMOVESC(IEDGE)=1
  CALL IDFPLOT_FEATURES_SCALE_DRAWBOX()
 ENDIF

 END SUBROUTINE IDFPLOT_FEATURES_SCALE_SELECT

 !###======================================================================
 SUBROUTINE IDFPLOT_FEATURES_SCALE_MOVE(X,Y,X0,Y0)
 !###======================================================================
 IMPLICIT NONE
 REAL(KIND=DP_KIND),INTENT(IN) :: X,Y,X0,Y0

 CALL IDFPLOT_FEATURES_SCALE_DRAWBOX()
 CALL IDFPLOT_FEATURES_MOVE(X,Y,X0,Y0,IMOVESC,SB_XP1,SB_YP1,SB_XP2,SB_YP2)
 CALL IDFPLOT_FEATURES_SCALE_DRAWBOX()
 
 END SUBROUTINE IDFPLOT_FEATURES_SCALE_MOVE
 
 !###======================================================================
 SUBROUTINE IDFPLOT_FEATURES_SCALE_DRAWBOX()
 !###======================================================================
 IMPLICIT NONE
 REAL(KIND=DP_KIND) :: XA1,YA1,XA2,YA2

 CALL IGRPLOTMODE(MODEXOR)
 CALL IGRCOLOURN(WRGB(50,50,50))
 CALL IGRFILLPATTERN(OUTLINE)

 CALL UTL_PLOT1BITMAP()
! CALL IDFPLOT_FEATURES_SCALE()
 CALL IDFPLOT_FEATURES_SCALE_CRD(XA1,YA1,XA2,YA2)
 CALL DBL_IGRRECTANGLE(XA1,YA1,XA2,YA2)
 CALL UTL_PLOT2BITMAP()

 CALL IGRPLOTMODE(MODECOPY)
 CALL IGRFILLPATTERN(OUTLINE)
 CALL IGRLINETYPE(SOLIDLINE)

 END SUBROUTINE IDFPLOT_FEATURES_SCALE_DRAWBOX

 !###======================================================================
 SUBROUTINE IDFPLOT_FEATURES_SCALE()
 !###======================================================================
 IMPLICIT NONE
 REAL(KIND=DP_KIND) :: WX1,WY1,WX2,WY2
 REAL(KIND=DP_KIND) :: X,X1,X2,XI,TWIDTH,THEIGHT,Y,DY,XT
 INTEGER :: N,I,J,II
 CHARACTER(LEN=10) :: FRM
 CHARACTER(LEN=24) :: LINE
 INTEGER,DIMENSION(2,2) :: ICLR
 REAL(KIND=DP_KIND) :: RAT,XFCT,DX

 DX =MPW%XMAX-MPW%XMIN
 DY =MPW%YMAX-MPW%YMIN
 CALL DBL_IGRAREA(SB_XP1,SB_YP1,SB_XP2,SB_YP2)
 CALL DBL_IGRUNITS(MPW%XMIN+SB_XP1*DX,MPW%YMIN+SB_YP1*DY,MPW%XMIN+SB_XP2*DX,MPW%YMIN+SB_YP2*DY,IOFFSET=1)
 CALL IGRAREACLEAR()

 WX1=REAL(WINFOGRREAL(GRAPHICSUNITMINX),8) ! (7)  LEFT LIMIT OF MAIN GRAPHICS AREA
 WY1=REAL(WINFOGRREAL(GRAPHICSUNITMINY),8) ! (8)  LOWER LIMIT OF MAIN GRAPHICS AREA
 WX2=REAL(WINFOGRREAL(GRAPHICSUNITMAXX),8) ! (9)  RIGHT LIMIT OF MAIN GRAPHICS AREA
 WY2=REAL(WINFOGRREAL(GRAPHICSUNITMAXY),8) ! (10) UPPER LIMIT OF MAIN GRAPHICS AREA
 RAT=(WX2-WX1)/(WY2-WY1)

X1=0.0D0; X2=(WX2-WX1)/1.25D0 

CALL UTL_GETAXESCALES(X1,0.0D0,X2,1.0D0)

XI=SXVALUE(2)-SXVALUE(1)
IF(NSX.GT.8)THEN; NSX=NSX/2; XI=XI*2.0D0; ENDIF
N=NSX

!## mid
X1=(WX2+WX1)/2.0D0-((REAL(N)*XI)/2.0D0)
X2=X1+REAL(N)*XI

!## heigth of the scalebar
DY=(WY2-WY1)/6.0D0

ICLR(1,1)=WRGB(0,0,0)
ICLR(2,1)=WRGB(255,255,255)
ICLR(1,2)=WRGB(255,255,255)
ICLR(2,2)=WRGB(0,0,0)
CALL IGRFILLPATTERN(SOLID)

Y=WY1+DY*4.0D0
CALL IGRFILLPATTERN(SOLID)
DO II=1,2
 IF(II.EQ.2)Y=Y-(0.5D0*DY)
 DO I=1,N
  IF(MOD(I,2).EQ.0)CALL IGRCOLOURN(ICLR(1,II))
  IF(MOD(I,2).NE.0)CALL IGRCOLOURN(ICLR(2,II))
  X =X1+(I-1)*XI
  X2=X1+(I)*XI
  IF(.NOT.UTL_EQUALS_REAL(Y-0.5D0*DY,Y))CALL DBL_IGRRECTANGLE(X,Y-0.5D0*DY,X2,Y)
 ENDDO
 !## first, split in 10
 DO I=1,10
  IF(MOD(I,2).EQ.0)CALL IGRCOLOURN(ICLR(1,II))
  IF(MOD(I,2).NE.0)CALL IGRCOLOURN(ICLR(2,II))
  X =X1+(I-1)*(XI/10.0D0)
  X2=X1+I*(XI/10.0D0)
  IF(.NOT.UTL_EQUALS_REAL(Y-0.5D0*DY,Y))CALL DBL_IGRRECTANGLE(X,Y-0.5D0*DY,X2,Y)
 ENDDO
 !## second, split in 2
 DO I=1,2
  IF(MOD(I,2).EQ.0)CALL IGRCOLOURN(ICLR(1,II))
  IF(MOD(I,2).NE.0)CALL IGRCOLOURN(ICLR(2,II))
  X =X1+XI+(I-1)*(XI/2.0D0)
  X2=X1+XI+I*(XI/2.0D0)
  IF(.NOT.UTL_EQUALS_REAL(Y-0.5D0*DY,Y))CALL DBL_IGRRECTANGLE(X,Y-0.5D0*DY,X2,Y)
 ENDDO
END DO

CALL IGRCOLOURN(WRGB(0,0,0))
CALL IGRFILLPATTERN(OUTLINE)
X1=(WX2+WX1)/2.0D0-((REAL(N)*XI)/2.0D0)
X2=X1+REAL(N)*XI
Y=WY1+DY*4.0D0
CALL DBL_IGRRECTANGLE(X1,Y-DY,X2,Y)
CALL DBL_IGRJOIN     (X1,Y-0.5D0*DY,X2,Y-0.5D0*DY)

I=INT(LOG10(WX2-WX1))

SELECT CASE (IMOD_IUNITS)
 CASE (0,1)
  SELECT CASE (I)
   CASE (6:);   XFCT=1000000.0D0
   CASE (3:5);  XFCT=1000.0D0  !## km
   CASE (1:2);  XFCT=1.0D0     !## meter
   CASE (0);    XFCT=0.1D0     !## decimeter
   CASE (-1);   XFCT=0.01D0    !## centimeter
   CASE (:-2);  XFCT=0.001D0   !## millimeter
  END SELECT
 CASE (2)
  SELECT CASE (I)
   CASE (6:);  XFCT=5280000.0D0 !## 1000 mile
   CASE (3:5); XFCT=5280.0D0    !## mile
   CASE (:2);  XFCT=1.0D0       !## feet
  END SELECT
END SELECT

CALL IGRLINEWIDTH(1)
CALL IGRFILLPATTERN(OUTLINE)
!## textsize in graphical dimensions

CALL UTL_SETTEXTSIZE(TWIDTH,THEIGHT,FCT=60.0D0)
CALL DBL_WGRTEXTFONT(IFAMILY=FFHELVETICA,TWIDTH=TWIDTH,THEIGHT=THEIGHT,ISTYLE=0)
CALL DBL_WGRTEXTORIENTATION(IALIGN=ALIGNCENTRE,ANGLE=0.0D0)
!## vertical lines
Y =WY1+DY*3.0D0
XT=0.0D0
DO I=1,N+1
 X =X1+(I-1)*XI
 XT=(I-1)*XI
 CALL IGRCOLOURN(WRGB(0,0,0))
 CALL DBL_IGRJOIN(X,Y-0.5D0*DY,X,Y+DY )
 FRM=TRIM(UTL_GETFORMAT(XT/XFCT))
 J=INDEX(FRM,'.00)',.TRUE.)
 IF(J.EQ.0)THEN
  CALL IDOUBLETOSTRING(XT/XFCT,LINE,FRM)
 ELSE
  CALL INTEGERTOSTRING(INT(XT/XFCT),LINE,'(I10)')
 ENDIF
 LINE=ADJUSTL(LINE)
 CALL DBL_WGRTEXTSTRING(X,WY1+1.75D0*DY,TRIM(LINE))
END DO
Y =WY1+DY*5.0D0

SELECT CASE (IMOD_IUNITS)
 CASE (0,1) !## meters
  IF(XFCT.EQ.1000000.0D0)CALL DBL_WGRTEXTSTRING((WX1+WX2)/2.0D0,Y,'kilometer (*1000)')
  IF(XFCT.EQ.1000.0D0)   CALL DBL_WGRTEXTSTRING((WX1+WX2)/2.0D0,Y,'kilometer')
  IF(XFCT.EQ.1.0D0)      CALL DBL_WGRTEXTSTRING((WX1+WX2)/2.0D0,Y,'meters')
  IF(XFCT.EQ.0.1D0)      CALL DBL_WGRTEXTSTRING((WX1+WX2)/2.0D0,Y,'decimeters')
  IF(XFCT.EQ.0.01D0)     CALL DBL_WGRTEXTSTRING((WX1+WX2)/2.0D0,Y,'millimeters')
 CASE (2) !## feet
  IF(XFCT.EQ.5280000.0D0)CALL DBL_WGRTEXTSTRING((WX1+WX2)/2.0D0,Y,'mile (*1000)')
  IF(XFCT.EQ.5280.0D0)   CALL DBL_WGRTEXTSTRING((WX1+WX2)/2.0D0,Y,'mile')
  IF(XFCT.EQ.1.0D0)      CALL DBL_WGRTEXTSTRING((WX1+WX2)/2.0D0,Y,'feet')
END SELECT

END SUBROUTINE IDFPLOT_FEATURES_SCALE

 !###======================================================================
 SUBROUTINE IDFPLOT_FEATURES_LEGEND_SELECT(X,Y)
 !###======================================================================
 IMPLICIT NONE
 REAL(KIND=DP_KIND),INTENT(IN) :: X,Y
 REAL(KIND=DP_KIND) :: XA1,YA1,XA2,YA2
 INTEGER :: IEDGE,I

 CALL WINDOWSELECT(0); IF(WMENUGETSTATE(ID_PLOTLEGEND,2).NE.1)RETURN
 
 CALL IDFPLOT_FEATURES_LEGEND_CRD(XA1,YA1,XA2,YA2)

 IEDGE=UTL_SELECTIEDGE(X-OFFSETX,Y-OFFSETY,XA1,YA1,XA2,YA2)
  
 !## remove previous selected line - if that is something else
 IF(SUM(IMOVELG).NE.0)THEN
  DO I=1,SIZE(IMOVELG); IF(IMOVELG(I).EQ.1)EXIT; ENDDO
  CALL IDFPLOT_FEATURES_LEGEND_DRAWBOX()
 ENDIF
 
 IMOVELG=0
 IF(IEDGE.NE.0)THEN
  IMOVELG(IEDGE)=1
  CALL IDFPLOT_FEATURES_LEGEND_DRAWBOX()
 ENDIF
 
 END SUBROUTINE IDFPLOT_FEATURES_LEGEND_SELECT

 !###======================================================================
 SUBROUTINE IDFPLOT_FEATURES_LEGEND_CRD(XA1,YA1,XA2,YA2)
 !###======================================================================
 IMPLICIT NONE
 REAL(KIND=DP_KIND),INTENT(OUT) :: XA1,YA1,XA2,YA2
 REAL(KIND=DP_KIND) :: DX,DY,WX1,WX2,WY1,WY2

 WX1=REAL(WINFOGRREAL(GRAPHICSUNITMINX),8) ! (7)  left  limit of main graphics area
 WY1=REAL(WINFOGRREAL(GRAPHICSUNITMINY),8) ! (8)  lower limit of main graphics area
 WX2=REAL(WINFOGRREAL(GRAPHICSUNITMAXX),8) ! (9)  right limit of main graphics area
 WY2=REAL(WINFOGRREAL(GRAPHICSUNITMAXY),8) ! (10) upper limit of main graphics area

 DX =WX2-WX1;       DY =WY2-WY1
 XA1=WX1+LG_XP1*DX; XA2=WX1+LG_XP2*DX
 YA1=WY1+LG_YP1*DY; YA2=WY1+LG_YP2*DY

 END SUBROUTINE IDFPLOT_FEATURES_LEGEND_CRD
 
 !###======================================================================
 SUBROUTINE IDFPLOT_FEATURES_LEGEND_MOVE(X,Y,X0,Y0)
 !###======================================================================
 IMPLICIT NONE
 REAL(KIND=DP_KIND),INTENT(IN) :: X,Y,X0,Y0

 CALL IDFPLOT_FEATURES_LEGEND_DRAWBOX()
 CALL IDFPLOT_FEATURES_MOVE(X,Y,X0,Y0,IMOVELG,LG_XP1,LG_YP1,LG_XP2,LG_YP2)
 CALL IDFPLOT_FEATURES_LEGEND_DRAWBOX()
 
 END SUBROUTINE IDFPLOT_FEATURES_LEGEND_MOVE
 
 !###======================================================================
 SUBROUTINE IDFPLOT_FEATURES_LEGEND_DRAWBOX()
 !###======================================================================
 IMPLICIT NONE
 REAL(KIND=DP_KIND) :: XA1,YA1,XA2,YA2

 CALL IGRPLOTMODE(MODEXOR)
 CALL IGRCOLOURN(WRGB(50,50,50))
 CALL IGRFILLPATTERN(OUTLINE)

 CALL UTL_PLOT1BITMAP()
 CALL IDFPLOT_FEATURES_LEGEND_CRD(XA1,YA1,XA2,YA2)
 IF(    IMOVELG(1).EQ.1)THEN
  CALL DBL_IGRJOIN(XA1,YA1,XA1,YA2)
 ELSEIF(IMOVELG(2).EQ.1)THEN
  CALL DBL_IGRJOIN(XA2,YA1,XA2,YA2)
 ELSEIF(IMOVELG(3).EQ.1)THEN
  CALL DBL_IGRJOIN(XA1,YA1,XA2,YA1)
 ELSEIF(IMOVELG(4).EQ.1)THEN
  CALL DBL_IGRJOIN(XA1,YA2,XA2,YA2)
 ELSE
  CALL DBL_IGRRECTANGLE(XA1,YA1,XA2,YA2)
 ENDIF
 
 CALL UTL_PLOT2BITMAP()

 CALL IGRPLOTMODE(MODECOPY)
 CALL IGRFILLPATTERN(OUTLINE)
 CALL IGRLINETYPE(SOLIDLINE)

 END SUBROUTINE IDFPLOT_FEATURES_LEGEND_DRAWBOX 

 !###======================================================================
 SUBROUTINE IDFPLOT_FEATURES_MOVE(X,Y,X0,Y0,IMOVE,XP1,YP1,XP2,YP2)
 !###======================================================================
 IMPLICIT NONE
 REAL(KIND=DP_KIND),INTENT(IN) :: X,Y,X0,Y0
 REAL(KIND=DP_KIND),INTENT(INOUT) :: XP1,YP1,XP2,YP2
 INTEGER,INTENT(IN),DIMENSION(:) :: IMOVE
 REAL(KIND=DP_KIND) :: DX,DY

 DX=X-X0
 DY=Y-Y0

 DOWNX=DOWNX+DX
 DOWNY=DOWNY+DY

 DX=DX/(MPW%XMAX-MPW%XMIN)
 DY=DY/(MPW%YMAX-MPW%YMIN)
 
 IF(    IMOVE(1).EQ.1)THEN
  XP1=MIN(XP2,XP1+DX)
 ELSEIF(IMOVE(2).EQ.1)THEN
  XP2=MAX(XP1,XP2+DX)
 ELSEIF(IMOVE(3).EQ.1)THEN
  YP1=MIN(YP2,YP1+DY)
 ELSEIF(IMOVE(4).EQ.1)THEN
  YP2=MAX(YP1,YP2+DY)
 ELSEIF(IMOVE(5).EQ.1)THEN
  XP1=MIN(XP2,XP1+DX)
  YP1=MIN(YP2,YP1+DY)
 ELSEIF(IMOVE(6).EQ.1)THEN
  XP2=MAX(XP1,XP2+DX)
  YP1=MIN(YP2,YP1+DY)
 ELSEIF(IMOVE(7).EQ.1)THEN
  XP2=MAX(XP1,XP2+DX)
  YP2=MAX(YP1,YP2+DY)
 ELSEIF(IMOVE(8).EQ.1)THEN
  XP1=MIN(XP2,XP1+DX)
  YP2=MAX(YP1,YP2+DY)
 ELSEIF(IMOVE(9).EQ.1)THEN
  XP1=MIN(XP2,XP1+DX)
  YP1=MIN(YP2,YP1+DY)
  XP2=MAX(XP1,XP2+DX)
  YP2=MAX(YP1,YP2+DY)
 ENDIF 
 
 XP1=MAX(0.0,MIN(1.0,XP1))
 XP2=MAX(0.0,MIN(1.0,XP2))

 YP1=MAX(0.0,MIN(1.0,YP1))
 YP2=MAX(0.0,MIN(1.0,YP2))
 
 END SUBROUTINE IDFPLOT_FEATURES_MOVE
 
!###======================================================================
SUBROUTINE IDFPLOT_FEATURES_NARROW()
!###======================================================================
IMPLICIT NONE
REAL(KIND=DP_KIND) :: X1,Y2,XOFFSET,IXDES1,IYDES1,IXDES2,IYDES2,RAT1,RAT2
INTEGER,DIMENSION(3) :: INFO
INTEGER,ALLOCATABLE,DIMENSION(:,:) :: IBMPDATA
INTEGER :: IBITMAP

!## appropriate keyword not available
IF(LEN_TRIM(PREFVAL(11)).EQ.0)RETURN

IF(WMENUGETSTATE(ID_SHOWAXES,2).EQ.1)XOFFSET=0.05D0
IF(WMENUGETSTATE(ID_SHOWAXES,2).EQ.0)XOFFSET=0.025D0

RAT1=WINFOGRREAL(GRAPHICSRATIO) !## dx/dy

X1=XOFFSET !0.05D0
Y2=1.0D0-XOFFSET*RAT1 !0.95

!CALL WGRCURVE(X,Y,3)
!BMPFNAME='D:\IMOD-CODE\IMOD-GUI\BMP\NORTH_ARROW.PNG'
CALL IGRFILEINFO(PREFVAL(11),INFO,3)
!## file not found
IF(INFO(1).EQ.0)THEN
 CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'iMOD cannot find:'//CHAR(13)// &
  TRIM(PREFVAL(11)),'Warning')
 PREFVAL(11)=''
 RETURN
ENDIF
IF(INFO(1).LT.0)THEN
 CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Wrong format for:'//CHAR(13)// &
  TRIM(PREFVAL(11)),'Warning')
 PREFVAL(11)=''
 RETURN
ENDIF

IF(ALLOCATED(IBMPDATA))DEALLOCATE(IBMPDATA)
ALLOCATE(IBMPDATA(INFO(2),INFO(3)))

IF(.NOT.UTL_LOADIMAGE(PREFVAL(11),SIZE(IBMPDATA),IBMPDATA,0))THEN
 DEALLOCATE(IBMPDATA); RETURN
ENDIF

CALL WBITMAPCREATE(IBITMAP,INFO(2),INFO(3))
CALL WBITMAPGETDATA(IBITMAP,IBMPDATA)

RAT2=REAL(INFO(3))/REAL(INFO(2)) !## dy/dx

!## largest side = 0.1
IF(INFO(2).GT.INFO(3))THEN !## col>row
 IXDES1=X1
 IXDES2=X1+0.1
 IYDES1=Y2-(0.1*RAT1*RAT2)
 IYDES2=Y2
 Y2    =0.05D0*RAT1
 X1    =0.05D0
ELSE                       !## row>col
 IXDES1=X1
 IXDES2=X1+(0.1/RAT1/RAT2)
 IYDES1=Y2-0.1
 IYDES2=Y2
 X1    =0.05D0/RAT1
 Y2    =0.05D0
ENDIF

CALL DBL_IGRAREA(IXDES1-X1,IYDES1-Y2,IXDES2+X1,IYDES2+Y2)
CALL IGRFILLPATTERN(SOLID)
CALL IGRCOLOURN(WRGB(255,255,255))
CALL DBL_IGRUNITS(0.0D0,0.0D0,1.0D0,1.0D0)
CALL DBL_IGRRECTANGLE(0.0D0,0.0D0,1.0D0,1.0D0)
CALL DBL_IGRAREA(IXDES1,IYDES1,IXDES2,IYDES2)
CALL WBITMAPPUT(IBITMAP,2,1)
CALL WBITMAPDESTROY(IBITMAP)

END SUBROUTINE IDFPLOT_FEATURES_NARROW

!###======================================================================
SUBROUTINE IDFPLOT_FEATURES_RASTER()
!###======================================================================
IMPLICIT NONE
INTEGER :: IPLOT,IC,IR,N
LOGICAL :: LEX
CHARACTER(LEN=256) :: FNAME

CALL IGRCOLOURN(WRGB(100,100,100))
CALL IGRLINEWIDTH(1)
DO IPLOT=1,MXMPLOT

 IF(.NOT.MP(IPLOT)%ISEL)CYCLE
 
 IF(MP(IPLOT)%IPLOT.EQ.1.OR.MP(IPLOT)%IPLOT.EQ.5)THEN

  !## get idf for mdf file
  LEX=.TRUE.
  IF(MP(IPLOT)%IPLOT.EQ.5)THEN
   FNAME=MP(IPLOT)%IDFNAME
   !## read *.mdf file, only to get selected idf to be plotted
   IF(READMDF(MP(IPLOT)%IDFNAME,N))THEN
    MP(IPLOT)%IDFNAME=MDF(MP(IPLOT)%NLIDF)%FNAME
    CALL MDFDEALLOCATE()
   ELSE
    LEX=.FALSE.
   ENDIF
  ENDIF

  IF(LEX)THEN

   !## reread dimensions ... in case different idf is placed ...
   IF(IDFREAD(MP(IPLOT)%IDF,MP(IPLOT)%IDFNAME,0))THEN

    IF(MP(IPLOT)%IDF%IEQ.EQ.0)THEN

     DO IR=0,MP(IPLOT)%IDF%NROW
      CALL DBL_IGRJOIN(MP(IPLOT)%IDF%XMIN,MP(IPLOT)%IDF%YMAX-IR*MP(IPLOT)%IDF%DY, &
                   MP(IPLOT)%IDF%XMAX,MP(IPLOT)%IDF%YMAX-IR*MP(IPLOT)%IDF%DY,IOFFSET=1)
     ENDDO
     DO IC=0,MP(IPLOT)%IDF%NCOL
      CALL DBL_IGRJOIN(MP(IPLOT)%IDF%XMIN+IC*MP(IPLOT)%IDF%DX,MP(IPLOT)%IDF%YMIN, &
                   MP(IPLOT)%IDF%XMIN+IC*MP(IPLOT)%IDF%DX,MP(IPLOT)%IDF%YMAX,IOFFSET=1)
     ENDDO

    ELSE

     DO IR=0,MP(IPLOT)%IDF%NROW
      CALL DBL_IGRJOIN(MP(IPLOT)%IDF%XMIN,MP(IPLOT)%IDF%SY(IR),MP(IPLOT)%IDF%XMAX,MP(IPLOT)%IDF%SY(IR),IOFFSET=1)
     ENDDO
     DO IC=0,MP(IPLOT)%IDF%NCOL
      CALL DBL_IGRJOIN(MP(IPLOT)%IDF%SX(IC),MP(IPLOT)%IDF%YMIN,MP(IPLOT)%IDF%SX(IC),MP(IPLOT)%IDF%YMAX,IOFFSET=1)
     ENDDO

    ENDIF

    CLOSE(MP(IPLOT)%IDF%IU)
    MP(IPLOT)%IDF%IU=0
    CALL IDFDEALLOCATEX(MP(IPLOT)%IDF)

   ENDIF

  ENDIF

  IF(MP(IPLOT)%IPLOT.EQ.5)MP(IPLOT)%IDFNAME=FNAME
  
 ENDIF
ENDDO

END SUBROUTINE IDFPLOT_FEATURES_RASTER

!###======================================================================
SUBROUTINE IDFPLOT_FEATURES_EXTENT()
!###======================================================================
IMPLICIT NONE
INTEGER :: I,J,IPLOT,N,IROW,ICOL,IDX,IDY
REAL(KIND=DP_KIND) :: TWIDTH,THEIGHT,X,Y,X1,Y1,X2,Y2,XMIN,XMAX,YMIN,YMAX
LOGICAL :: LEX
CHARACTER(LEN=256) :: FNAME
CHARACTER(LEN=52) :: STRING

I=0; J=0
IF(WMENUGETSTATE(ID_IDFEXTENT,2).EQ.1)I=1   
IF(WMENUGETSTATE(ID_IDFINDICES,2).EQ.1)J=1

CALL UTL_SETTEXTSIZE(TWIDTH,THEIGHT,FCT=5.0D0)
CALL DBL_WGRTEXTFONT(IFAMILY=FFHELVETICA,TWIDTH=TWIDTH,THEIGHT=THEIGHT,ISTYLE=0)
CALL DBL_WGRTEXTORIENTATION(IALIGN=ALIGNCENTRE,ANGLE=0.0D0)

CALL IGRLINEWIDTH(1); CALL IGRFILLPATTERN(OUTLINE)
CALL IGRCOLOURN(WRGB(0,0,0)) 

DO IPLOT=1,MXMPLOT

 IF(MP(IPLOT)%ISEL.AND.(MP(IPLOT)%IPLOT.EQ.1.OR. &
                        MP(IPLOT)%IPLOT.EQ.5))THEN

  !## get idf for mdf file
  LEX=.TRUE.
  IF(MP(IPLOT)%IPLOT.EQ.5)THEN
   FNAME=MP(IPLOT)%IDFNAME
   !## read *.mdf file, only to get selected idf to be plotted
   IF(READMDF(MP(IPLOT)%IDFNAME,N))THEN
    MP(IPLOT)%IDFNAME=MDF(MP(IPLOT)%NLIDF)%FNAME
    CALL MDFDEALLOCATE()
   ENDIF
  ENDIF

  IF(LEX)THEN

   !## reread dimensions ... in case different idf is placed ...
   IF(IDFREAD(MP(IPLOT)%IDF,MP(IPLOT)%IDFNAME,0))THEN

    !## display idf extent
    IF(I.EQ.1)CALL DBL_IGRRECTANGLE(MP(IPLOT)%IDF%XMIN,MP(IPLOT)%IDF%YMIN, &
                                MP(IPLOT)%IDF%XMAX,MP(IPLOT)%IDF%YMAX,IOFFSET=1)
    !## display indices
    IF(J.EQ.1)THEN
 
     !## size of coord. fit in plotwindow
     XMIN=MAX(MP(IPLOT)%IDF%XMIN,MPW%XMIN); XMAX=MIN(MP(IPLOT)%IDF%XMAX,MPW%XMAX)
     YMIN=MAX(MP(IPLOT)%IDF%YMIN,MPW%YMIN); YMAX=MIN(MP(IPLOT)%IDF%YMAX,MPW%YMAX)

     IF(MP(IPLOT)%IDF%IEQ.EQ.0)THEN
      !## get the accuracy of the drawing, stepsize idx,idy
      CALL IDFGETACCURACY(IDX,IDY,MP(IPLOT)%IDF%NCOL,MP(IPLOT)%IDF%NROW,XMAX-XMIN,YMAX-YMIN)
     ELSEIF(MP(IPLOT)%IDF%IEQ.EQ.1)THEN
      IDX=1; IDY=1
     ENDIF

     DO IROW=1,MP(IPLOT)%IDF%NROW,IDY; DO ICOL=1,MP(IPLOT)%IDF%NCOL,IDX
      CALL IDFGETEDGE(MP(IPLOT)%IDF,IROW,ICOL,X1,Y1,X2,Y2)
      IF(X1.GE.XMIN.AND.X2.LE.XMAX.AND.Y2.GE.YMIN.AND.Y1.LE.YMAX)THEN
       X=(X1+X2)/2.0D0; Y=(Y1+Y2)/2.0D0
       STRING='('//TRIM(ITOS(IROW))//'-'//TRIM(ITOS(ICOL))//')'
       CALL DBL_WGRTEXTSTRING(X,Y,TRIM(STRING),IOFFSET=1)
      ENDIF
     ENDDO; ENDDO

    
    ENDIF

    CLOSE(MP(IPLOT)%IDF%IU)
    MP(IPLOT)%IDF%IU=0
    CALL IDFDEALLOCATEX(MP(IPLOT)%IDF)

   ENDIF

  ENDIF

  IF(MP(IPLOT)%IPLOT.EQ.5)MP(IPLOT)%IDFNAME=FNAME

 ENDIF
ENDDO

CALL DBL_WGRTEXTORIENTATION(IALIGN=ALIGNLEFT,ANGLE=0.0D0,IDIR=DIRHORIZ,NALIGN=ALIGNCENTRE)

END SUBROUTINE IDFPLOT_FEATURES_EXTENT

!###======================================================================
SUBROUTINE IDFPLOTAREA(XMIN,YMIN,XMAX,YMAX,I,LPLOT)
!###======================================================================
IMPLICIT NONE
INTEGER,INTENT(IN) :: I
LOGICAL,INTENT(OUT) :: LPLOT
REAL(KIND=DP_KIND),INTENT(IN) :: XMIN,YMIN,XMAX,YMAX
INTEGER :: J

!## always draw first
IF(I.EQ.1)THEN

 LPLOT=.TRUE.
 IPOLACT=0
 
ELSE

 !## no to be drawn unless proven otherwise
 LPLOT=.FALSE.

 DO J=1,SIZE(IPOLACT) 
  IF(IPOLACT(J).EQ.1)THEN 
   IF(XMIN.LT.POLAREAXY(J,1).OR. & 
      YMIN.LT.POLAREAXY(J,2).OR. &
      XMAX.GT.POLAREAXY(J,3).OR. &
      YMAX.GT.POLAREAXY(J,4))THEN 
    LPLOT=.TRUE.
    EXIT  
   ENDIF 
  ENDIF 
 ENDDO

ENDIF

!## add drawable area only if it get drawn
IF(LPLOT)THEN
 POLAREAXY(I,1)=XMIN; POLAREAXY(I,2)=YMIN; POLAREAXY(I,3)=XMAX; POLAREAXY(I,4)=YMAX
 IPOLACT(I)=1
ENDIF

END SUBROUTINE IDFPLOTAREA

!###======================================================================
LOGICAL FUNCTION IDFDRAW(IDF,LEG,UNITS,IP,XMIN,YMIN,XMAX,YMAX,THICKNESS,LPLOT,UMIN,UMAX)
!###======================================================================
IMPLICIT NONE
TYPE(IDFOBJ),INTENT(INOUT) :: IDF
TYPE(LEGENDOBJ),INTENT(INOUT) :: LEG
INTEGER,INTENT(IN) :: UNITS,THICKNESS
INTEGER,INTENT(IN),DIMENSION(4) :: IP
REAL(KIND=DP_KIND),INTENT(IN) :: XMIN,YMIN,XMAX,YMAX
LOGICAL,INTENT(IN) :: LPLOT
REAL(KIND=DP_KIND),INTENT(OUT),OPTIONAL :: UMIN,UMAX
TYPE(WIN_MESSAGE) :: MESSAGE
INTEGER :: NC1,NC2,NR1,NR2,ANROW,ANCOL,IRAT,IRAT1,IDY,IDX,I,IOS,&
           J,IWID,IHGT,JBITMAP,KBITMAP,ITYPE,IROW,ICOL,ICLR,ITNODATA,ITRANS
INTEGER :: IDTYPE,IDHANDLE
CHARACTER(LEN=120) :: WAITTXT
REAL(KIND=DP_KIND) :: AX1,AX2,AY1,AY2,X,DX,DY,X1,X2,Y1,Y2,DMIN,DMAX,OX1,OY1,OX2,OY2
INTEGER,ALLOCATABLE,DIMENSION(:) :: IBMPDATA,KBMPDATA
LOGICAL :: LEX

IDFDRAW=.FALSE.

IDTYPE  =WINFODRAWABLE(DRAWABLETYPE)  ! (1)  TYPE (1=WINDOW 2=BITMAP 3=DIALOG/FIELD 4=METAFILE)
IDHANDLE=WINFODRAWABLE(DRAWABLEID)    ! (2)  HANDLE/IDENTIFIER
OX1     =WINFOGRREAL(GRAPHICSAREAMINX)! (7)  LEFT LIMIT OF MAIN GRAPHICS AREA
OY1     =WINFOGRREAL(GRAPHICSAREAMINY)! (8)  LOWER LIMIT OF MAIN GRAPHICS AREA
OX2     =WINFOGRREAL(GRAPHICSAREAMAXX)! (9)  RIGHT LIMIT OF MAIN GRAPHICS AREA
OY2     =WINFOGRREAL(GRAPHICSAREAMAXY)! (10) UPPER LIMIT OF

CALL WINDOWSELECT(0)
ITNODATA=WMENUGETSTATE(ID_TRANSPARANTNODATAIDF,2)
ITRANS  =WMENUGETSTATE(ID_TRANSPARANTIDF,2)

!## try reading last record:
IF(.NOT.IDFGETVAL_CHECK(IDF,IDF%NROW,IDF%NCOL,X))THEN 
 CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Error reading last record of idf'//CHAR(13)//TRIM(IDF%FNAME),'Error')
 RETURN
ENDIF

CALL UTL_IDFCURDIM(XMIN,YMIN,XMAX,YMAX,IDF,NC1,NC2,NR1,NR2)

LEX=.FALSE.

IF(IP(1).EQ.1.AND.LPLOT)THEN

 WAITTXT='Bitmap Drawing of '//TRIM(IDF%FNAME)//' ...'
 CALL WINDOWSELECT(0); CALL WINDOWOUTSTATUSBAR(2,'Press Escape to stop!'); CALL WINDOWOUTSTATUSBAR(4,TRIM(WAITTXT)//'0%')

 !## active number of columns/row
 IF(IDF%IEQ.EQ.0)THEN
  ANCOL=NC2-NC1+1
  ANROW=NR2-NR1+1
 ELSE
  DX   =IDF%SX(NC2)-IDF%SX(NC1-1)
  DY   =IDF%SY(NR1-1)-IDF%SY(NR2)
  ANCOL=CEILING(DX/IDF%DX)
  ANROW=CEILING(DY/IDF%DY)
 ENDIF

 IF(IDF%IEQ.EQ.0)THEN
  !## get the accuracy of the drawing, stepsize idx,idy
  CALL IDFGETACCURACY(IDX,IDY,ANCOL,ANROW,XMAX-XMIN,YMAX-YMIN)
 ELSEIF(IDF%IEQ.EQ.1)THEN
  IDX=1; IDY=1
 ENDIF

 X=REAL(ANCOL)/REAL(IDX); IWID=CEILING(X)
 X=REAL(ANROW)/REAL(IDY); IHGT=CEILING(X)

 IF(IWID.LE.0.OR.IHGT.LE.0)RETURN

 !## allocate memory for color-plotting in ibmpdata()
 IF(IDF%IEQ.EQ.0)THEN
  ALLOCATE(IBMPDATA(IWID*IHGT),STAT=IOS)
 ELSEIF(IDF%IEQ.EQ.1)THEN
  IWID=MPW%DIX
  IHGT=MPW%DIY
  IOS =0
 ENDIF

 IF(IOS.NE.0)THEN
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'iMOD cannot display current IDF.'//CHAR(13)// &
    'It needs and array of '//TRIM(ITOS(IWID))//' x '//TRIM(ITOS(IHGT))//' elements','Error')
  RETURN
 ENDIF

 JBITMAP=0; CALL WBITMAPCREATE(JBITMAP,IWID,IHGT)

 !## adjust min/max values current window-level
 DMIN=HUGE(DMIN); DMAX=-HUGE(DMAX)

 IRAT1=0

 IF(IDF%IEQ.EQ.0)THEN

  I=0; J=0
  DO IROW=NR1,NR2,IDY
   I=I+1
   CALL WMESSAGEPEEK(ITYPE,MESSAGE)
   IF(ITYPE.EQ.KEYDOWN.AND.MESSAGE%VALUE1.EQ.KEYESCAPE)EXIT
   DO ICOL=NC1,NC2,IDX
    J          =J+1
    IBMPDATA(J)=IDFGETICLR(IDF,LEG,UNITS,IROW,ICOL,DMIN,DMAX)
   END DO
   CALL UTL_WAITMESSAGE(IRAT,IRAT1,I,IHGT,WAITTXT)
  END DO
  CALL WBITMAPGETDATA(JBITMAP,IBMPDATA)
  DEALLOCATE(IBMPDATA)
  
  X  = IDF%XMIN+(NC1-1)*IDF%DX;  AX1=(X-MPW%XMIN)/(MPW%XMAX-MPW%XMIN)
  X  = IDF%XMIN+(NC2   *IDF%DX); AX2=(X-MPW%XMIN)/(MPW%XMAX-MPW%XMIN)
  X  = IDF%YMAX-(NR2   *IDF%DY); AY1=(X-MPW%YMIN)/(MPW%YMAX-MPW%YMIN)
  X  = IDF%YMAX-(NR1-1)*IDF%DY;  AY2=(X-MPW%YMIN)/(MPW%YMAX-MPW%YMIN)

 ELSEIF(IDF%IEQ.EQ.1)THEN

  CALL IGRSELECT(DRAWBITMAP,JBITMAP)
  CALL DBL_IGRAREA(0.0D0,0.0D0,1.0D0,1.0D0)
  CALL DBL_IGRUNITS(IDF%SX(NC1-1),IDF%SY(NR2),IDF%SX(NC2),IDF%SY(NR1-1),IOFFSET=1)

  CALL IGRFILLPATTERN(SOLID)
  I=0
  DO IROW=NR1,NR2
   I=I+1
   CALL WMESSAGEPEEK(ITYPE,MESSAGE)
   IF(ITYPE.EQ.KEYDOWN.AND.MESSAGE%VALUE1.EQ.KEYESCAPE)EXIT

   Y2=IDF%SY(IROW-1); Y1=IDF%SY(IROW)

   DO ICOL=NC1,NC2

    X1=IDF%SX(ICOL-1); X2=IDF%SX(ICOL)

    ICLR=IDFGETICLR(IDF,LEG,UNITS,IROW,ICOL,DMIN,DMAX)
    CALL IGRCOLOURN(ICLR)
    CALL DBL_IGRRECTANGLE(X1,Y1,X2,Y2,IOFFSET=1)

   ENDDO

   CALL UTL_WAITMESSAGE(IRAT,IRAT1,I,IHGT,WAITTXT)
  ENDDO

  CALL IGRSELECT(IDTYPE,IDHANDLE)
  CALL IGRPLOTMODE(MODECOPY)

  X=IDF%SX(NC1-1); AX1=(X-MPW%XMIN)/(MPW%XMAX-MPW%XMIN)
  X=IDF%SX(NC2);   AX2=(X-MPW%XMIN)/(MPW%XMAX-MPW%XMIN)
  X=IDF%SY(NR2);   AY1=(X-MPW%YMIN)/(MPW%YMAX-MPW%YMIN)
  X=IDF%SY(NR1-1); AY2=(X-MPW%YMIN)/(MPW%YMAX-MPW%YMIN)

 ENDIF

 AX1=OX1+AX1*(OX2-OX1)
 AX2=OX1+AX2*(OX2-OX1)
 AY1=OY1+AY1*(OY2-OY1)
 AY2=OY1+AY2*(OY2-OY1)

 !## set target area to be replaced
 CALL DBL_IGRAREA(AX1,AY1,AX2,AY2)

 !## compute new pixel values with transparant nodata values
 IF(ITNODATA.EQ.1)THEN

  CALL IGRSELECT(DRAWBITMAP,MPW%IBITMAP)
  CALL WBITMAPSTRETCHMODE(STRETCHDELETE)
  !## get current window in bitmap (only for area set by DBL_IGRAREA)
  KBITMAP=0
  CALL WBITMAPGET(KBITMAP,2)
  !## size of current images
  IWID=WINFOBITMAP(KBITMAP,BITMAPWIDTH)
  IHGT=WINFOBITMAP(KBITMAP,BITMAPHEIGHT)
  !## resize - for performance
  IWID=IWID/4
  IHGT=IHGT/4
  CALL WBITMAPRESIZE(KBITMAP,IWID,IHGT)
  !## create array
  ALLOCATE(KBMPDATA(IWID*IHGT))
  !## read current bitmap's in memory
  CALL WBITMAPPUTDATA(KBITMAP,KBMPDATA) !## previous image  <--- NEEMT VEEL TIJD!
  CALL WBITMAPDESTROY(KBITMAP)
  !## put new window ...
  CALL WBITMAPPUT(JBITMAP,2,1)
  !## ... destroy bitmap ...
  CALL WBITMAPDESTROY(JBITMAP)
  !## ... and get it again
  JBITMAP=0
  CALL WBITMAPGET(JBITMAP,2)
  !## resize - for performance
  CALL WBITMAPRESIZE(JBITMAP,IWID,IHGT)
  !## create array
  ALLOCATE(IBMPDATA(IWID*IHGT))
  CALL WBITMAPPUTDATA(JBITMAP,IBMPDATA) !## new image <--- NEEMT VEEL TIJD
  CALL IDFCOPYCOLOUR(IWID*IHGT,IBMPDATA,KBMPDATA)
  !## restore memory bitmap after adjustments
  CALL WBITMAPGETDATA(JBITMAP,IBMPDATA)
  !## free memory
  DEALLOCATE(IBMPDATA,KBMPDATA)

 ENDIF

 CALL WBITMAPPLOTMODE(MODECOPY)
 IF(ITRANS.EQ.1)CALL WBITMAPPLOTMODE(MODEAND) !## bitwise and

 CALL WBITMAPSTRETCHMODE(STRETCHAND)
 CALL WBITMAPPUT(JBITMAP,2,1)

 CALL WBITMAPPLOTMODE(MODECOPY)
 CALL WBITMAPDESTROY(JBITMAP)
 LEX=.TRUE.
 
ENDIF

!## contouring/vector/texting
IF(IP(2).NE.0.OR.IP(3).NE.0.OR.IP(4).NE.0)THEN

 !## read part
 IF(.NOT.IDFREADPART(IDF,XMIN,YMIN,XMAX,YMAX))RETURN

 DMIN=HUGE(DMIN); DMAX=-HUGE(DMAX)
 DO IROW=1,IDF%NROW; DO ICOL=1,IDF%NCOL
  IF(IDF%X(ICOL,IROW).NE.IDF%NODATA)THEN
   DMIN=MIN(DMIN,IDF%X(ICOL,IROW))
   DMAX=MAX(DMAX,IDF%X(ICOL,IROW))
  ENDIF
 ENDDO; ENDDO

 CALL IGRPLOTMODE(MODECOPY)
 CALL UTL_PLOT1BITMAP()
 CALL IGRLINEWIDTH(THICKNESS)

 IF(IP(2).EQ.1)THEN
  WAITTXT='Contouring current window for: '//TRIM(IDF%FNAME)//' ...'
  CALL WINDOWSELECT(0); CALL WINDOWOUTSTATUSBAR(4,TRIM(WAITTXT)//'0%')
  CALL IDFPLOT_CONTOUR(IDF,LEG,IP,THICKNESS)
 ENDIF

 !## vector
 IF(IP(3).EQ.1)THEN
  WAITTXT='Vectoring current window for: '//TRIM(IDF%FNAME)//' ...'
  CALL WINDOWSELECT(0); CALL WINDOWOUTSTATUSBAR(4,TRIM(WAITTXT)//'0%')
  CALL IDFPLOT_VECTOR(IDF,LEG,UNITS,XMAX,XMIN,YMAX,YMIN,IP)
 ENDIF

 !## texting
 IF(IP(4).EQ.1)THEN
  WAITTXT='Texting current window for: '//TRIM(IDF%FNAME)//' ...'
  CALL WINDOWSELECT(0); CALL WINDOWOUTSTATUSBAR(4,TRIM(WAITTXT)//'0%')
  CALL IDFPLOT_TEXTING(IDF,XMAX,XMIN,YMAX,YMIN,ABS(MAX(1,THICKNESS)))
 ENDIF

 CALL IGRLINEWIDTH(1)
 CALL IDFDEALLOCATEX(IDF)
 LEX=.TRUE.
 
ENDIF

CALL WINDOWSELECT(0); CALL WINDOWOUTSTATUSBAR(2,''); CALL WINDOWOUTSTATUSBAR(4,'')

IF(LEX.AND.SUM(IP).GT.0)THEN
 IF(PRESENT(UMIN))UMIN=DMIN; IF(PRESENT(UMAX))UMAX=DMAX
ENDIF

IDFDRAW=LEX

END FUNCTION IDFDRAW

!###======================================================================
SUBROUTINE IDFPLOT_TEXTING(IDF,XMAX,XMIN,YMAX,YMIN,THICKNESS)
!###======================================================================
IMPLICIT NONE
INTEGER,INTENT(IN) :: THICKNESS
REAL(KIND=DP_KIND),INTENT(IN) :: XMAX,XMIN,YMAX,YMIN
TYPE(IDFOBJ) :: IDF
INTEGER :: IROW,ICOL,IDX,IDY
REAL(KIND=DP_KIND) :: TWIDTH,THEIGHT,X,Y
CHARACTER(LEN=15) :: STRING

!## get the accuracy of the drawing, stepsize idx,idy
IF(IDF%IEQ.EQ.0)THEN
 CALL IDFGETACCURACY(IDX,IDY,IDF%NCOL,IDF%NROW,XMAX-XMIN,YMAX-YMIN)
ELSEIF(IDF%IEQ.EQ.1)THEN
 IDX=1; IDY=1
ENDIF

CALL UTL_SETTEXTSIZE(TWIDTH,THEIGHT,FCT=REAL(THICKNESS,8))!*0.01D0) 
CALL DBL_WGRTEXTFONT(IFAMILY=FFHELVETICA,TWIDTH=TWIDTH,THEIGHT=THEIGHT,ISTYLE=0)
CALL DBL_WGRTEXTORIENTATION(ALIGNCENTRE,ANGLE=0.0D0)

CALL IGRCOLOURN(WRGB(0,0,0))
DO IROW=1,IDF%NROW,IDY; DO ICOL=1,IDF%NCOL,IDX
 IF(IDF%X(ICOL,IROW).EQ.IDF%NODATA)CYCLE
 CALL IDFGETLOC(IDF,IROW,ICOL,X,Y)
 IF(X.GT.XMIN.AND.X.LT.XMAX.AND.Y.GT.YMIN.AND.Y.LT.YMAX)THEN
  STRING=UTL_REALTOSTRING(IDF%X(ICOL,IROW))
  CALL DBL_WGRTEXTSTRING(X,Y,TRIM(STRING),IOFFSET=1)
 ENDIF
ENDDO; ENDDO

END SUBROUTINE IDFPLOT_TEXTING

!###======================================================================
SUBROUTINE IDFPLOT_VECTOR(IDF,LEG,UNITS,XMAX,XMIN,YMAX,YMIN,IP)
!###======================================================================
IMPLICIT NONE
TYPE(IDFOBJ),INTENT(INOUT) :: IDF
TYPE(LEGENDOBJ),INTENT(INOUT) :: LEG
REAL(KIND=DP_KIND),INTENT(IN) :: XMAX,XMIN,YMAX,YMIN
INTEGER,INTENT(IN),DIMENSION(3) :: IP
INTEGER,INTENT(IN) :: UNITS
INTEGER :: IROW,ICOL,IDX,IDY,ICLR
REAL(KIND=DP_KIND) :: X,DX,Y,DY,F
REAL(KIND=DP_KIND) :: DZDX,DZDY,A

!## get the accuracy of the drawing, stepsize idx,idy
IF(IDF%IEQ.EQ.0)THEN
 CALL IDFGETACCURACY(IDX,IDY,IDF%NCOL,IDF%NROW,XMAX-XMIN,YMAX-YMIN)
ELSEIF(IDF%IEQ.EQ.1)THEN
 IDX=1; IDY=1
ENDIF

CALL IGRCOLOURN(WRGB(50,50,50))
DO IROW=1,IDF%NROW,IDY; DO ICOL=1,IDF%NCOL,IDX

 IF(IDF%X(ICOL,IROW).EQ.IDF%NODATA)CYCLE

 IF(UNITS.EQ.0)THEN
  CALL SOF_COMPUTE_GRAD(IDF,ICOL,IROW,DZDX,DZDY)

!  !## 3IDF
!  IF(IDF%IVF.EQ.1)CALL SOF_COMPUTE_GRAD_3D(IDF,ICOL,IROW,DZDX,DZDY,DZDZ)

  IF(IP(1).EQ.0.AND.IP(2).EQ.0)THEN
   F=DZDX**2.0D0+DZDY**2.0D0; IF(F.NE.0.0D0)F=SQRT(F)
   IF(F.NE.IDF%NODATA)THEN
    ICLR=UTL_IDFGETCLASS(LEG,F)
   ELSE
    ICLR=WRGB(255,255,255)
   ENDIF
   CALL IGRCOLOURN(ICLR)  
  ENDIF   
  !## radians  
  A=ATAN2(-1.0D0*DZDY,DZDX)
 ELSE
  A=IDF%X(ICOL,IROW)
 ENDIF
 CALL IDFGETLOC(IDF,IROW,ICOL,X,Y)
 
 DX= 0.5D0*COS(A)*IDF%DX
 DY= 0.5D0*SIN(A)*IDF%DY
 CALL DBL_IGRJOIN(X,Y,X+DX,Y+DY,IOFFSET=1)
 DX=-0.5D0*COS(A)*IDF%DX
 DY=-0.5D0*SIN(A)*IDF%DY
 CALL DBL_IGRARROWJOIN(X,Y,X+DX,Y+DY,1,IOFFSET=1)

ENDDO; ENDDO

END SUBROUTINE IDFPLOT_VECTOR
 
!###======================================================================
SUBROUTINE IDFCOPYCOLOUR(NDIM,IBMPDATA,KBMPDATA)
!###======================================================================
IMPLICIT NONE
INTEGER,INTENT(IN) :: NDIM
INTEGER,INTENT(OUT),DIMENSION(NDIM) :: IBMPDATA
INTEGER,INTENT(INOUT),DIMENSION(NDIM) :: KBMPDATA
INTEGER :: I,IWHITE!,IU

IWHITE=WRGB(255,255,255)
!## only copy rgb-values if not equal to white = rgb-value=wrgb(255,255,255)0
DO I=1,NDIM
 IF(KBMPDATA(I).NE.IWHITE)IBMPDATA(I)=KBMPDATA(I)
END DO

END SUBROUTINE IDFCOPYCOLOUR

!###======================================================================
SUBROUTINE IDFGETACCURACY(NPX,NPY,NCOL,NROW,DX,DY)
!###======================================================================
IMPLICIT NONE
INTEGER,INTENT(IN) :: NCOL,NROW
INTEGER,INTENT(OUT) :: NPX,NPY
REAL(KIND=DP_KIND),INTENT(IN) :: DX,DY
REAL(KIND=DP_KIND) :: PCX,PCY,ACC

!## pixels neccessary to plot data
PCX=DX*(REAL(MPW%DIX)/(MPW%XMAX-MPW%XMIN))
PCY=DY*(REAL(MPW%DIY)/(MPW%YMAX-MPW%YMIN))
!## step size in x/y direction depending on available pixels
CALL WINDOWSELECT(0)
ACC=1
IF(WMENUGETSTATE(ID_LOWACCURACY,2).EQ.1)       ACC=10
IF(WMENUGETSTATE(ID_MEDIUMACCURACY,2).EQ.1)    ACC=5
IF(WMENUGETSTATE(ID_HIGHACCURACY,2).EQ.1)      ACC=3
IF(WMENUGETSTATE(ID_EXCELLENTACCURACY,2).EQ.1) ACC=1

NPX=MAX(1,INT(REAL(NCOL*ACC)/PCX))
NPY=MAX(1,INT(REAL(NROW*ACC)/PCY))

CALL WINDOWSELECT(0); CALL WINDOWOUTSTATUSBAR(3,'X:'//TRIM(ITOS(NPX))//'/Y:'//TRIM(ITOS(NPY)))

END SUBROUTINE IDFGETACCURACY

!###======================================================================
SUBROUTINE IDFMOVE(IWIN_ID)
!###======================================================================
IMPLICIT NONE
INTEGER,INTENT(IN) :: IWIN_ID
TYPE(WIN_MESSAGE) :: MESSAGE
INTEGER :: ITYPE,IDCURSOR,IMOVED

!## hide dmanager
IF(IWIN_ID.EQ.0)THEN
 CALL WINDOWSELECT(0)
 IF(WMENUGETSTATE(ID_MANAGER,2).EQ.1) THEN
  CALL WDIALOGSELECT(ID_DMANAGER)
  CALL WDIALOGHIDE()
 END IF
ENDIF

CALL IDFMOVEINIT(0,IWIN_ID)

IDCURSOR=ID_CURSORHAND
CALL WCURSORSHAPE(IDCURSOR)

IDOWN=0; IMOVED=0
DO WHILE(.TRUE.)

 CALL WMESSAGE(ITYPE, MESSAGE)

 IF(IWIN_ID.NE.0.AND.MESSAGE%WIN.NE.IWIN_ID)THEN
   
  IF(WINFOMOUSE(MOUSECURSOR).NE.CURHOURGLASS)CALL WCURSORSHAPE(CURHOURGLASS)
  
 ELSE
  
  IF(WINFOMOUSE(MOUSECURSOR).NE.IDCURSOR)CALL WCURSORSHAPE(IDCURSOR)

  SELECT CASE(ITYPE)

   CASE(MOUSEMOVE)
    IF(IDOWN.EQ.1)THEN
     IMOVED=1; CALL IDFMOVEIT(REAL(MESSAGE%GX,8),REAL(MESSAGE%GY,8),IWIN_ID)
    ENDIF
   CASE (MOUSEBUTUP)
    SELECT CASE (MESSAGE%VALUE1)
     CASE (1)
      !## update moved plot
      IF(IMOVED.EQ.1)THEN
       CALL IDFMOVEPLOT(IWIN_ID)
       IDCURSOR=ID_CURSORHAND
       CALL WCURSORSHAPE(IDCURSOR)
       CALL WINDOWSELECT(0)
       CALL WINDOWOUTSTATUSBAR(2,'')
       CALL WINDOWOUTSTATUSBAR(4,'Click your right-mouse button to leave this move-mode')
       IDOWN=0; IMOVED=0
      ENDIF
    END SELECT

   !## mouse button pressed
   CASE (MOUSEBUTDOWN)
    SELECT CASE (MESSAGE%VALUE1)
     CASE (1)
      IDCURSOR=ID_CURSORHANDGREP
      CALL WCURSORSHAPE(IDCURSOR)
      PX=INT(MESSAGE%GX)
      PY=INT(MESSAGE%GY)
      IDOWN=1
     CASE (3)
      EXIT
    END SELECT

   CASE (BITMAPSCROLLED)
    MPW%IX=MESSAGE%VALUE1
    MPW%IY=MESSAGE%VALUE2

  END SELECT
 
 ENDIF
ENDDO

CALL IDFMOVECLOSE(IWIN_ID)

IF(IWIN_ID.EQ.0)THEN

 OFFSETX=MPW%XMIN
 OFFSETY=MPW%YMIN

 !## show dmanager
 IF(WMENUGETSTATE(ID_MANAGER,2).EQ.1) THEN
  CALL WDIALOGSELECT(ID_DMANAGER)
  CALL WDIALOGSHOW(-0,65,0,2)
 ENDIF
ENDIF

END SUBROUTINE IDFMOVE

!###======================================================================
SUBROUTINE IDFMOVEINIT(ITYPE,IWIN_ID)
!###======================================================================
IMPLICIT NONE
INTEGER,INTENT(IN) :: ITYPE,IWIN_ID

IW=WINFOBITMAP(MPW%IBITMAP,BITMAPWIDTH)
IH=WINFOBITMAP(MPW%IBITMAP,BITMAPHEIGHT)

IF(IWIN_ID.EQ.0)THEN
 CALL IGRSELECT(DRAWWIN)
ELSE
 !## moving in profile-dialog
 CALL WDIALOGSELECT(ID_DSERIESTAB1)
 CALL IGRSELECT(DRAWFIELD,IDF_PICTURE1)
ENDIF 

CALL DBL_IGRUNITS(0.0D0,0.0D0,REAL(IW,8),REAL(IH,8))
CALL WBITMAPCREATE(IBITMAP,IW,IH)

CALL WINDOWSELECT(0)
IF(ITYPE.EQ.0)CALL WINDOWOUTSTATUSBAR(4,'Click your right-mouse button to leave this move-mode')
IF(ITYPE.EQ.1)CALL WINDOWOUTSTATUSBAR(4,'Release Ctrl-Left Mouse Button to leave this move-mode')

END SUBROUTINE IDFMOVEINIT

!###======================================================================
SUBROUTINE IDFMOVECLOSE(IWIN_ID)
!###======================================================================
IMPLICIT NONE
INTEGER,INTENT(IN) :: IWIN_ID

CALL WCURSORSHAPE(CURARROW)
CALL WINDOWOUTSTATUSBAR(1,'')
CALL WINDOWOUTSTATUSBAR(4,'')

IF(IWIN_ID.EQ.0)THEN
 CALL IGRSELECT(DRAWWIN)
 CALL DBL_IGRUNITS(MPW%XMIN,MPW%YMIN,MPW%XMAX,MPW%YMAX,IOFFSET=1)
 CALL WBITMAPDESTROY(IBITMAP)
ELSE
 !## moving in profile-dialog
 CALL WDIALOGSELECT(ID_DSERIESTAB1)
 CALL IGRSELECT(DRAWFIELD,IDF_PICTURE1)
 CALL DBL_IGRAREA(AREA(1),AREA(2),AREA(3),AREA(4))
 CALL DBL_IGRUNITS(MPW%XMIN,MPW%YMIN,MPW%XMAX,MPW%YMAX)
ENDIF

END SUBROUTINE IDFMOVECLOSE

!###======================================================================
SUBROUTINE IDFMOVEIT(GX,GY,IWIN_ID)
!###======================================================================
IMPLICIT NONE
INTEGER,INTENT(IN) :: IWIN_ID
REAL(KIND=DP_KIND),INTENT(IN) :: GX,GY
INTEGER :: IXSOUR1,IYSOUR1,IXSOUR2,IYSOUR2,IXDEST,IYDEST

CALL WINDOWSELECT(0)
CALL WINDOWOUTSTATUSBAR(1,'Pixel X:'//TRIM(ITOS(INT(GX)))//' Pixel Y:'//TRIM(ITOS(INT(GY))))

!##moving bitmap
DX=INT(GX-PX)
DY=INT(PY-GY)
CALL WINDOWOUTSTATUSBAR(2,'DP X:'//TRIM(ITOS(DX))//' DP Y:'//TRIM(ITOS(DY)))
!###shifted to the right
IF(DX.GT.0)THEN
 IXSOUR1=    1    !left
 IXSOUR2=  IW-DX  !right
 IXDEST =   DX    !left
ELSE
 IXSOUR1=-1*DX    !left
 IXSOUR2=   IW    !right
 IXDEST =    1    !left
ENDIF
!###shifted to the top
IF(DY.GT.0)THEN
 IYSOUR1=  IH-DY  !top
 IYSOUR2=    1    !bottom
 IYDEST =    IH   !top
ELSE
 IYSOUR1=   IH    !top
 IYSOUR2=  -1*DY  !bottom
 IYDEST =  IH+DY  !top
ENDIF

CALL IGRSELECT(DRAWBITMAP,IBITMAP)
CALL IGRPLOTMODE(MODECOPY)
CALL DBL_IGRAREA(0.0D0,0.0D0,1.0D0,1.0D0)
CALL DBL_IGRUNITS(0.0D0,0.0D0,REAL(IW,8),REAL(IH,8))
CALL IGRFILLPATTERN(SOLID)
CALL IGRCOLOURN(WRGB(255,255,255))
CALL DBL_IGRRECTANGLE(0.0D0,0.0D0,REAL(IW,8),REAL(IH,8))
CALL WBITMAPPUTPART(MPW%IBITMAP,1,IXSOUR1,IYSOUR1,IXSOUR2,IYSOUR2,IXDEST,IYDEST)

CALL IGRSELECT(DRAWWIN)
CALL WINDOWSELECT(MPW%IWIN)
CALL WBITMAPVIEW(IBITMAP,MPW%IX,MPW%IY,MODELESS)

IF(IWIN_ID.NE.0)THEN
 CALL PROFILE_PUTBITMAP(IBITMAP)
ENDIF

CALL DBL_IGRAREA(0.0D0,0.0D0,1.0D0,1.0D0)
CALL DBL_IGRUNITS(0.0D0,0.0D0,REAL(IW,8),REAL(IH,8))

END SUBROUTINE IDFMOVEIT

 !###======================================================================
 SUBROUTINE IDFMOVEPLOT(IWIN_ID)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IWIN_ID
 REAL(KIND=DP_KIND) :: DXC,DYC

 !##compute transformation of pixels onto coordinates
 DXC=REAL(DX,8)*(MPW%XMAX-MPW%XMIN)/REAL(IW,8)
 DYC=REAL(-1.0D0*DY,8)*(MPW%YMAX-MPW%YMIN)/REAL(IH,8)

 DXC=-1.0D0*DXC
 DYC=-1.0D0*DYC

 MPW%XMIN=MPW%XMIN+DXC
 MPW%XMAX=MPW%XMAX+DXC
 MPW%YMIN=MPW%YMIN+DYC
 MPW%YMAX=MPW%YMAX+DYC

 CALL WBITMAPDESTROY(MPW%IBITMAP)

 CALL IDFPLOTFAST(0)

 IF(IWIN_ID.EQ.0)THEN
  CALL IGRSELECT(DRAWWIN)
 ELSE
  !## moving in profile-dialog
  CALL WDIALOGSELECT(ID_DSERIESTAB1)
  CALL IGRSELECT(DRAWFIELD,IDF_PICTURE1)
  !## put bitmap to field ...
  CALL PROFILE_PUTBITMAP(MPW%IBITMAP)
 ENDIF 

 CALL DBL_IGRUNITS(0.0D0,0.0D0,REAL(IW,8),REAL(IH,8))
 CALL WBITMAPCREATE(IBITMAP,IW,IH)

 END SUBROUTINE IDFMOVEPLOT

 !###======================================================================
 SUBROUTINE IDFZOOM(IDZ,GX,GY,IWIN_ID)
 !###======================================================================
 IMPLICIT NONE
 REAL(KIND=DP_KIND),PARAMETER :: FZIN =0.90D0
 REAL(KIND=DP_KIND),PARAMETER :: FZOUT=1.0D0/FZIN
 INTEGER,INTENT(IN) :: IDZ,IWIN_ID
 TYPE(WIN_MESSAGE) :: MESSAGE
 REAL(KIND=DP_KIND),INTENT(IN) :: GX,GY
 INTEGER :: ITYPE,I,IPLOT,IDOWN,IDCURSOR,ITAB,N
 REAL(KIND=DP_KIND) :: FZ,XC1,YC1,XC2,YC2,XC3,YC3,XMIN,XMAX,YMIN,YMAX,DX,DY,F,XA1,YA1,XA2,YA2,MOUSEX,MOUSEY
 LOGICAL :: LEX
 CHARACTER(LEN=256) :: FNAME

 IF(IDZ.EQ.ID_ZOOMINMAP)THEN
  FZ=FZIN
 ELSEIF(IDZ.EQ.ID_ZOOMOUTMAP)THEN
  FZ=FZOUT
 ELSEIF(IDZ.EQ.ID_ZOOMRECTANGLEMAP)THEN
  IDCURSOR=ID_CURSORZOOMRECTANGLE
  FZ=FZIN
 ENDIF

 !## full map-view - selected idf's
 IF(IDZ.EQ.ID_ZOOMFULLMAP)THEN

  CALL WDIALOGSELECT(ID_DMANAGER)
  CALL WDIALOGGETTAB(ID_DMTAB,ITAB)
  I=0
 
  IF(ITAB.EQ.ID_DMANAGERTAB1)THEN
   DO IPLOT=1,MXMPLOT
    IF(ACTLIST(IPLOT).EQ.1)THEN
     SELECT CASE (MP(IPLOT)%IPLOT)
      !## idf,mdf
      CASE (1,5) !##
       !## get idf or mdf file
       LEX=.TRUE.
       IF(MP(IPLOT)%IPLOT.EQ.5)THEN
        FNAME=MP(IPLOT)%IDFNAME
        !## read *.mdf file, only to get selected idf to be plotted
        LEX=READMDF(MP(IPLOT)%IDFNAME,N)
        MP(IPLOT)%IDFNAME=MDF(MP(IPLOT)%NLIDF)%FNAME
        CALL MDFDEALLOCATE()
       ENDIF
       IF(LEX)THEN
        LEX=IDFREAD(MP(IPLOT)%IDF,MP(IPLOT)%IDFNAME,0)
        IF(LEX)THEN
         CLOSE(MP(IPLOT)%IDF%IU)
         IF(I.EQ.0)THEN
          XMIN=MP(IPLOT)%IDF%XMIN; XMAX=MP(IPLOT)%IDF%XMAX
          YMIN=MP(IPLOT)%IDF%YMIN; YMAX=MP(IPLOT)%IDF%YMAX
         ELSE
          XMIN=MIN(XMIN,MP(IPLOT)%IDF%XMIN)
          YMIN=MIN(YMIN,MP(IPLOT)%IDF%YMIN)
          XMAX=MAX(XMAX,MP(IPLOT)%IDF%XMAX)
          YMAX=MAX(YMAX,MP(IPLOT)%IDF%YMAX)
         ENDIF
         I=I+1
        ENDIF
       ENDIF
       IF(MP(IPLOT)%IPLOT.EQ.5)MP(IPLOT)%IDFNAME=FNAME
      !## ipf/iff/gen
      CASE (2,3,6)
       IF(I.EQ.0)THEN
        XMIN=MP(IPLOT)%XMIN; XMAX=MP(IPLOT)%XMAX
        YMIN=MP(IPLOT)%YMIN; YMAX=MP(IPLOT)%YMAX
       ELSE
        IF(MP(IPLOT)%XMIN.NE.0.0D0.OR.MP(IPLOT)%XMAX.NE.0.0D0.OR. &
           MP(IPLOT)%YMIN.NE.0.0D0.OR.MP(IPLOT)%YMAX.NE.0.0D0)THEN
         XMIN=MIN(XMIN,MP(IPLOT)%XMIN); YMIN=MIN(YMIN,MP(IPLOT)%YMIN)
         XMAX=MAX(XMAX,MP(IPLOT)%XMAX); YMAX=MAX(YMAX,MP(IPLOT)%YMAX)
        ENDIF
       ENDIF
       I=I+1
      !## isg
      CASE (4)
       IF(I.EQ.0)THEN
        XMIN=0.0D0; XMAX=0.0D0
        YMIN=0.0D0; YMAX=0.0D0
       ENDIF
       CALL ISGPLOTMINMAX(MP(IPLOT)%IDFNAME,XMIN,XMAX,YMIN,YMAX)
       I=I+1
     END SELECT
    ENDIF
   ENDDO

  !## gen zoom
  ELSEIF(ITAB.EQ.ID_DMANAGERTAB2)THEN

   DO IPLOT=1,MXGEN
    IF(ACTLISTGEN(IPLOT).EQ.1)THEN
     IF(I.EQ.0)THEN
      I=I+1
      XMIN=GEN(IPLOT)%XMIN
      YMIN=GEN(IPLOT)%YMIN
      XMAX=GEN(IPLOT)%XMAX
      YMAX=GEN(IPLOT)%YMAX
     ELSE
      XMIN=MIN(XMIN,GEN(IPLOT)%XMIN)
      YMIN=MIN(YMIN,GEN(IPLOT)%YMIN)
      XMAX=MAX(XMAX,GEN(IPLOT)%XMAX)
      YMAX=MAX(YMAX,GEN(IPLOT)%YMAX)
     ENDIF
    ENDIF
   ENDDO

  !## tag zoom
  ELSEIF(ITAB.EQ.ID_DMANAGERTAB3)THEN

   CALL TAGZOOM(XMIN,YMIN,XMAX,YMAX)

  ENDIF

  !## nothing found - leave current zoom level intact
  IF(I.EQ.0)THEN

   XMIN=MPW%XMIN; XMAX=MPW%XMAX
   YMIN=MPW%YMIN; YMAX=MPW%YMAX

  ENDIF

  IF(XMAX-XMIN.LE.0.0D0)THEN
   XMAX=XMAX+1.0D0; XMIN=XMIN-1.0D0
  ENDIF
  IF(YMAX-YMIN.LE.0.0D0)THEN
   YMAX=YMAX+1.0D0; YMIN=YMIN-1.0D0
  ENDIF

 !## zoom tags
 ELSEIF(IDZ.EQ.ID_ZOOMTAG)THEN

  CALL TAGZOOM(XMIN,YMIN,XMAX,YMAX)

 !## interactive zooming
 ELSEIF(IDZ.EQ.ID_ZOOMINMAP.OR.IDZ.EQ.ID_ZOOMOUTMAP)THEN

  !## get active drawing area
  CALL IDFPLOT_FEATURES_AXES_CRD(XA1,YA1,XA2,YA2)
  DX=XA2-XA1; DY=YA2-YA1
  DX=FZ*DX-DX
  DY=FZ*DY-DY

  XMIN=XA1-DX+OFFSETX
  XMAX=XA2+DX+OFFSETX
  YMIN=YA1-DY+OFFSETY
  YMAX=YA2+DY+OFFSETY

 !## interactive zooming
 ELSEIF(IDZ.EQ.ID_ZOOMRECTANGLEMAP)THEN

  !## rectangle zoom
  CALL IGRPLOTMODE(MODEXOR)
  CALL IGRCOLOURN(WRGB(255,255,255))
  CALL IGRFILLPATTERN(OUTLINE)
  CALL IGRLINETYPE(DASHED)
  CALL IGRLINEWIDTH(1)
  CALL WCURSORSHAPE(IDCURSOR)

  IDOWN=0
  LEX  =.FALSE.
  XC1  =0.0D0
  YC1  =0.0D0
  DO

   CALL WMESSAGE(ITYPE,MESSAGE)

   IF(IWIN_ID.NE.0.AND.MESSAGE%WIN.NE.IWIN_ID)THEN
   
    IF(WINFOMOUSE(MOUSECURSOR).NE.CURHOURGLASS)CALL WCURSORSHAPE(CURHOURGLASS)
  
   ELSE
  
    IF(WINFOMOUSE(MOUSECURSOR).NE.IDCURSOR)CALL WCURSORSHAPE(IDCURSOR)
   
    SELECT CASE(ITYPE)
 
     CASE(MOUSEMOVE)

      MOUSEX=DBLE(MESSAGE%GX)+OFFSETX
      MOUSEY=DBLE(MESSAGE%GY)+OFFSETY
     
      CALL WINDOWSELECT(0)
      CALL WINDOWOUTSTATUSBAR(1,'X:'//TRIM(RTOS(MOUSEX,'G',7))//' m, Y:'// &
                                      TRIM(RTOS(MOUSEY,'G',7))//' m')
      XC2=MOUSEX; YC2=MOUSEY

      IF(IDOWN.EQ.1)CALL WINDOWOUTSTATUSBAR(2,'delta x:'//TRIM(RTOS(XC2-XC1,'G',7))//' m, delta y:'//TRIM(RTOS(YC2-YC1,'G',7))//' m')

      !##first point set!
      IF(IDOWN.EQ.1)THEN
       CALL UTL_PLOT1BITMAP()
       IF(LEX)CALL DBL_IGRRECTANGLE(XC1,YC1,XC3,YC3,IOFFSET=1)
       LEX=.FALSE.
       IF(XC1.NE.XC2.AND.YC1.NE.YC2)LEX=.TRUE.
       IF(LEX)CALL DBL_IGRRECTANGLE(XC1,YC1,XC2,YC2,IOFFSET=1)
       CALL UTL_PLOT2BITMAP()
       !## if profiel zoomrectangle, put bitmap to that dialog too.
       IF(IWIN_ID.NE.0)CALL PROFILE_PUTBITMAP(MPW%IBITMAP)
      ENDIF

      XC3=XC2; YC3=YC2

     !## mouse button pressed
     CASE (MOUSEBUTDOWN)
      SELECT CASE (MESSAGE%VALUE1)

       !## left button
       CASE (1)
        IF(IDOWN.EQ.0)THEN
         XC1=XC2; YC1=YC2; IDOWN=1
        ELSE
         XMIN=MIN(XC1,XC2); XMAX=MAX(XC1,XC2)
         YMIN=MIN(YC1,YC2); YMAX=MAX(YC1,YC2)
         CALL IGRLINETYPE(SOLIDLINE)
         EXIT
        ENDIF

       !## right button
       CASE (3)
        IF(IDOWN.EQ.1)THEN
         CALL UTL_PLOT1BITMAP()
         IF(LEX)CALL DBL_IGRRECTANGLE(XC1,YC1,XC3,YC3,IOFFSET=1)
         CALL UTL_PLOT2BITMAP()
         !## if profiel zoomrectangle, put bitmap to that dialog too.
         IF(IWIN_ID.NE.0)CALL PROFILE_PUTBITMAP(MPW%IBITMAP)
        ENDIF
        RETURN
      END SELECT

     CASE (BITMAPSCROLLED)
      MPW%IX=MESSAGE%VALUE1
      MPW%IY=MESSAGE%VALUE2

    END SELECT
  
   ENDIF
  ENDDO

  CALL WCURSORSHAPE(CURARROW)
  CALL IGRPLOTMODE(MODECOPY)
  CALL IGRLINETYPE(SOLIDLINE)

 !## zoom to previous extent
 ELSEIF(IDZ.EQ.ID_ZOOMPREVIOUS)THEN

  ZM%IZOOM=ZM%IZOOM-1
  XMIN=ZM%ZOOMXY(ZM%IZOOM,1)
  YMIN=ZM%ZOOMXY(ZM%IZOOM,2)
  XMAX=ZM%ZOOMXY(ZM%IZOOM,3)
  YMAX=ZM%ZOOMXY(ZM%IZOOM,4)

 !## zoom to next extent
 ELSEIF(IDZ.EQ.ID_ZOOMNEXT)THEN

  ZM%IZOOM=ZM%IZOOM+1
  XMIN=ZM%ZOOMXY(ZM%IZOOM,1)
  YMIN=ZM%ZOOMXY(ZM%IZOOM,2)
  XMAX=ZM%ZOOMXY(ZM%IZOOM,3)
  YMAX=ZM%ZOOMXY(ZM%IZOOM,4)
 
 ELSEIF(IDZ.EQ.ID_DMODEL)THEN
 
  XMIN=SIMBOX(1)
  YMIN=SIMBOX(2)
  XMAX=SIMBOX(3)
  YMAX=SIMBOX(4)

 ELSEIF(IDZ.EQ.ID_DGOTOXY)THEN
 
  XMIN=MPW%XMIN
  XMAX=MPW%XMAX
  YMIN=MPW%YMIN
  YMAX=MPW%YMAX

 ENDIF

 !## make sure there is something to plot
 IF(XMAX-XMIN.LE.0.0D0)XMAX=XMIN+1.0D0
 IF(YMAX-YMIN.LE.0.0D0)YMAX=YMIN+1.0D0
 
 F=(XMAX-XMIN)*0.025D0; XMIN=XMIN-F; XMAX=XMAX+F
 F=(YMAX-YMIN)*0.025D0; YMIN=YMIN-F; YMAX=YMAX+F

 F=DBLE(MPW%DIX)/DBLE(MPW%DIY)
 DX=(AX_XP2-AX_XP1)
 DY=(AX_YP2-AX_YP1)/F
 CALL UTL_IDFCRDCOR(XMIN,XMAX,YMIN,YMAX,DX,DY)
 
 !## include graphical area
 F=(XMAX-XMIN)/(AX_XP2-AX_XP1)
 MPW%XMIN=XMIN-        AX_XP1 *F
 MPW%XMAX=XMAX+(1.0D0- AX_XP2)*F
 F=(YMAX-YMIN)/(AX_YP2-AX_YP1)
 MPW%YMIN=YMIN-        AX_YP1 *F
 MPW%YMAX=YMAX+(1.0D0- AX_YP2)*F

 !## final check, make sure still viewable extent
 DX=MPW%XMAX-MPW%XMIN; DY=MPW%YMAX-MPW%YMIN
 IF(DX.LE.0.0D0.OR.DY.LE.0.0D0)THEN
  IF(DX.LE.0.0D0.AND.DY.LE.0.0D0)THEN
   MPW%XMAX=MPW%XMIN+1.0D0; MPW%YMAX=MPW%YMIN+1.0D0
  ELSEIF(DX.LE.0.0D0.AND.DY.GT.0.0D0)THEN
   MPW%XMAX=MPW%XMIN+DY
  ELSE
   MPW%YMAX=MPW%YMIN+DX
  ENDIF
 ENDIF

 !## determine new offset to be applied
 OFFSETX=MPW%XMIN
 OFFSETY=MPW%YMIN

 CALL WINDOWSELECT(0); CALL WINDOWOUTSTATUSBAR(2,'')

 !## store current zoom-extent
 IF(IDZ.NE.ID_ZOOMPREVIOUS.AND.IDZ.NE.ID_ZOOMNEXT)CALL UTL_STOREZOOMEXTENT()

 END SUBROUTINE IDFZOOM

END MODULE MOD_IDFPLOT