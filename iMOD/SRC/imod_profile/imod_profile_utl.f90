!!  Copyright (C) Stichting Deltares, 2005-2016.
!!
!!  This file is part of iMOD.
!!
!!  This program is free software: you can redistribute it and/or modify
!!  it under the terms of the GNU General Public License as published by
!!  the Free Software Foundation, either version 3 of the License, or
!!  (at your option) any later version.
!!
!!  This program is distributed in the hope that it will be useful,
!!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!  GNU General Public License for more details.
!!
!!  You should have received a copy of the GNU General Public License
!!  along with this program.  If not, see <http://www.gnu.org/licenses/>.
!!
!!  Contact: imod.support@deltares.nl
!!  Stichting Deltares
!!  P.O. Box 177
!!  2600 MH Delft, The Netherlands.
!!
MODULE MOD_PROFILE_UTL

USE WINTERACTER
USE RESOURCE
USE MOD_UTL, ONLY : RTOS,ITOS,UTL_GDATE,UTL_SETTEXTSIZE,UTL_DRAWLEGENDBOX,JDATETOGDATE,JDATETOFDATE,UTL_GETFORMAT,UTL_GETAXESCALES, &
              SXVALUE,SYVALUE,NSX,NSY
USE MOD_PROF_PAR, ONLY : XY,NXY,XPOS,IWINPROFILE,IBITMAP,AREA,PBITMAP
USE MODPLOT, ONLY : MPW
USE MOD_PREF_PAR, ONLY : PREFVAL

REAL,DIMENSION(:,:),ALLOCATABLE :: GRAPHUNITS 
REAL,DIMENSION(:,:),ALLOCATABLE :: GRAPHAREA

TYPE AXESOBJ
 CHARACTER(LEN=50) :: XTITLE,YTITLE,Y2TITLE   !xtitle,ytitle = AXES
 REAL :: XFACTOR,YFACTOR              !XFACTOR,YFACTOR = mult. factors
 LOGICAL :: LDATE                     !ldate - plot date
 INTEGER :: IFIXX                     !ifix - fixed x-axes
 INTEGER :: IFIXY                     !ifix - fixed y-axes
 INTEGER :: IFIXY2                    !ifix - fixed y2-axes
 REAL :: XINT,YINT,Y2INT              !xint,yint - interval
 INTEGER :: ICLRRASTER                !iclrraster - colour
 INTEGER :: XOFFSET                   !offset for julian dates
 REAL :: XMIN,YMIN,XMAX,YMAX,Y2MIN,Y2MAX     !XMIN,YMIN,XMAX,YMAX = dimensions of current graph
 REAL :: DXAXESL,DXAXESR,DYAXESB,DYAXEST     !1.0/fraction of space occupied by left,right,bottom and top axes
 INTEGER :: TFONT
 INTEGER,DIMENSION(2) :: IAXES  !## left/bottom, and top/right
 REAL :: CHH,CHW                !## characterheight,characterwidth
 INTEGER :: ICLRBACKGROUND !## background color
END TYPE AXESOBJ

TYPE GRAPHOBJ
 REAL,POINTER,DIMENSION(:) :: RX,RY !## x and y values
 INTEGER :: GTYPE !## graph type 1=solid 2=lines 3=histogram
 INTEGER :: NP  !## no. points
 CHARACTER(LEN=50) :: LEGTXT !## legend text
 INTEGER :: ICLR
END TYPE GRAPHOBJ
TYPE(GRAPHOBJ),DIMENSION(:,:),ALLOCATABLE :: GRAPH
CHARACTER(LEN=50),DIMENSION(:),ALLOCATABLE :: GRAPHNAMES
REAL,PRIVATE :: PGXMIN,PGXMAX,PGYMIN,PGYMAX

CONTAINS

 !###======================================================================
 SUBROUTINE PROFILE_BACKGROUND_BITMAP_READ()
 !###======================================================================
 IMPLICIT NONE
 INTEGER :: IW,IH,I
 
 IF(PBITMAP%IBITMAP.GT.0)THEN; CALL WBITMAPDESTROY(PBITMAP%IBITMAP); PBITMAP%IBITMAP=0; ENDIF

 IW=0; IH=0
 DO I=1,SIZE(IWINPROFILE)
  IW=MAX(IW,WINFOBITMAP(IBITMAP(I),BITMAPWIDTH))
  IH=MAX(IH,WINFOBITMAP(IBITMAP(I),BITMAPHEIGHT))
 ENDDO
 
 CALL WBITMAPCREATE(PBITMAP%IBITMAP,IW,IH)
 PBITMAP%IW=IW; PBITMAP%IH=IH
 CALL WBITMAPSTRETCHMODE(STRETCHHALFTONE)
 CALL WBITMAPLOAD(PBITMAP%IBITMAP,PBITMAP%FNAME,1)
 
 PBITMAP%IACT=1
 
 END SUBROUTINE PROFILE_BACKGROUND_BITMAP_READ

 !###====================================================================
 SUBROUTINE PROFILE_PUTBITMAP(IBITMAP2D)
 !###====================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IBITMAP2D
 REAL :: R1,R2,F
 INTEGER :: IW,IH

 CALL WDIALOGSELECT(ID_DSERIESTAB1)
 CALL IGRSELECT(DRAWFIELD,IDF_PICTURE1)

 IW=WINFODIALOGFIELD(IDF_PICTURE1,FIELDWIDTH)
 IH=WINFODIALOGFIELD(IDF_PICTURE1,FIELDHEIGHT)

 R1=REAL(IW)/REAL(IH)
 R2=REAL(MPW%DIX)/REAL(MPW%DIY)

 AREA(1)=0.0
 AREA(2)=0.0
 AREA(3)=1.0
 AREA(4)=1.0

 !## bitmap is wider than window - adjust y
 IF(R2.GT.R1)THEN
  F      = REAL(MPW%DIY)/(REAL(MPW%DIX)/REAL(IW))
  F      = F/REAL(IH)
  F      =(1.0-F)/2.0
  AREA(2)= F       !ymin
  AREA(4)= 1.0-F   !ymax
 !## bitmap is smaller than window - adjust x
 ELSE
  F      = REAL(MPW%DIX)/(REAL(MPW%DIY)/REAL(IH))
  F      = F/REAL(IW)
  F      =(1.0-F)/2.0
  AREA(1)= F       !xmin
  AREA(3)= 1.0-F   !xmax
 ENDIF

 !## plot/update survey crosssection
 CALL PROFILE_PLOTSURVEY(.FALSE.)

 CALL WDIALOGSELECT(ID_DSERIESTAB1)
 CALL IGRSELECT(DRAWFIELD,IDF_PICTURE1)
 CALL IGRAREA(AREA(1),AREA(2),AREA(3),AREA(4))
 CALL WBITMAPPUT(IBITMAP2D,2,1)
 CALL IGRUNITS(MPW%XMIN,MPW%YMIN,MPW%XMAX,MPW%YMAX)

 END SUBROUTINE PROFILE_PUTBITMAP

 !###======================================================================
 SUBROUTINE PROFILE_PLOTSURVEY(LPS)
 !###======================================================================
 IMPLICIT NONE
 LOGICAL ,INTENT(IN) :: LPS
 REAL :: XP1,XP2,YP1,YP2,SX_RATIO,SXYRATIO,BITMAPRATIO
 REAL :: XMARGE,DXMARGE,YMARGE,DX,DY,XA1,XA2,YA1,YA2,XU1,XU2,YU1,YU2
 INTEGER :: IWD,IHD,IWS,ISURVEY,IWINID,ILOC,ISIZE
 CHARACTER(LEN=256) :: FNAME

 !## store previous settings
 XA1=WINFOGRREAL(GRAPHICSAREAMINX); XA2=WINFOGRREAL(GRAPHICSAREAMAXX)
 YA1=WINFOGRREAL(GRAPHICSAREAMINY); YA2=WINFOGRREAL(GRAPHICSAREAMAXY)
 XU1=WINFOGRREAL(GRAPHICSUNITMINX); XU2=WINFOGRREAL(GRAPHICSUNITMAXX)
 YU1=WINFOGRREAL(GRAPHICSUNITMINY); YU2=WINFOGRREAL(GRAPHICSUNITMAXY)

 CALL WDIALOGSELECT(ID_DSERIESPROPTAB3)
 CALL WDIALOGGETCHECKBOX(IDF_CHECK5,ISURVEY)
 IF(ISURVEY.EQ.0)RETURN
 
 CALL WDIALOGGETRADIOBUTTON(IDF_RADIO1,ILOC)
 CALL WDIALOGGETRADIOBUTTON(IDF_RADIO5,ISIZE)

 !## nothing drawn yet, 
 IF(.NOT.ALLOCATED(IWINPROFILE))RETURN
 
 CALL IGRSELECT(DRAWBITMAP,MPW%IBITMAP)
 IWD=WINFODRAWABLE(DRAWABLEWIDTH)
 IHD=WINFODRAWABLE(DRAWABLEHEIGHT)
 BITMAPRATIO=REAL(IHD)/REAL(IWD)

 DO IWINID=1,SIZE(IWINPROFILE)
  CALL IGRSELECT(DRAWWIN,IWINPROFILE(IWINID))
  !## drawable settings
  IWD=WINFODRAWABLE(DRAWABLEWIDTH)
  IHD=WINFODRAWABLE(DRAWABLEHEIGHT)
  !## screen setting
  IWS=WINFOSCREEN(SCREENWIDTH)
  !## ratio's
  SX_RATIO=REAL(IWS)/REAL(IWD)
  SXYRATIO=REAL(IWD)/REAL(IHD)

  CALL IGRSELECT(DRAWBITMAP,IBITMAP(IWINID))

  SELECT CASE (ISIZE)
   CASE (1); DXMARGE=0.35 !## large
   CASE (2); DXMARGE=0.25 !## medium
   CASE (3); DXMARGE=0.15 !## small
  END SELECT
 
  SELECT CASE (ILOC)
   CASE (1); XMARGE=0.975       ; YMARGE=0.90         !## br
   CASE (2); XMARGE=0.975       ; YMARGE=DXMARGE+0.05 !## tr
   CASE (3); XMARGE=DXMARGE+0.05; YMARGE=0.90         !## bl
   CASE (4); XMARGE=DXMARGE+0.05; YMARGE=DXMARGE+0.05 !## tl
  END SELECT

  XP2=XMARGE
  XP1=XP2-(DXMARGE*SX_RATIO)
  YP1=(1.0-YMARGE)*SXYRATIO*BITMAPRATIO
  YP2=(1.0-(YMARGE-DXMARGE*SX_RATIO))*SXYRATIO*BITMAPRATIO

  DX=(XP2-XP1)/50.0
  DY=(YP2-YP1)/50.0*SXYRATIO

  CALL IGRPLOTMODE(MODECOPY)

  CALL IGRAREA(XP1,YP1,XP2,YP2)
  CALL IGRUNITS(0.0,0.0,1.0,1.0)
  CALL IGRFILLPATTERN(SOLID)
  CALL IGRCOLOURN(WRGB(255,255,255))
  CALL IGRRECTANGLE(0.0,0.0,1.0,1.0)
  CALL IGRFILLPATTERN(OUTLINE)
  CALL IGRCOLOURN(WRGB(0,0,0))
  CALL IGRRECTANGLE(0.0,0.0,1.0,1.0)
  CALL IGRAREA(XP1+DX,YP1+DY,XP2-DX,YP2-DY)

  CALL WBITMAPPUT(MPW%IBITMAP,2,1)

  IF(LPS)THEN
   FNAME=TRIM(PREFVAL(1))//'\tmp\tmp.bmp' !Liduin
   CALL WBITMAPSAVE(MPW%IBITMAP,FNAME)
   CALL IGRLOADIMAGE(FNAME)
  ENDIF
  
  CALL IGRSELECT(DRAWWIN,IWINPROFILE(IWINID))
  CALL WBITMAPPUT(IBITMAP(IWINID),0,1)  
 
 ENDDO
 
 CALL IGRAREA(XA1,YA1,XA2,YA2)
 CALL IGRUNITS(XU1,YU1,XU2,YU2)
 
 IF(LPS)CALL IOSDELETEFILE(FNAME)
 
 END SUBROUTINE PROFILE_PLOTSURVEY

 !###======================================================================
 SUBROUTINE PROFILE_PLOTGRAPH(XTXT,YTXT,LDATE)
 !###======================================================================
 IMPLICIT NONE
 LOGICAL ,INTENT(IN) :: LDATE
 CHARACTER(LEN=*),INTENT(IN) :: XTXT,YTXT
 INTEGER :: ITYPE,NG,IBITMAP
 TYPE(WIN_MESSAGE) :: MESSAGE
 
 NG=1
 IBITMAP=0
 
 CALL WDIALOGLOAD(ID_DSCENTOOL_FIGURE,ID_DSCENTOOL_FIGURE)
 CALL WDIALOGTITLE('Graph')
 CALL WDIALOGPUTIMAGE(ID_ZOOMIN,ID_ICONZOOMIN,1)
 CALL WDIALOGPUTIMAGE(ID_ZOOMOUT,ID_ICONZOOMOUT,1)
 CALL WDIALOGPUTIMAGE(ID_ZOOMFULL,ID_ICONZOOMFULL,1)
 CALL WDIALOGPUTIMAGE(ID_ZOOMBOX,ID_ICONZOOMBOX,1)
 CALL WDIALOGPUTIMAGE(ID_MOVE,ID_ICONMOVE,1)
 CALL WDIALOGPUTIMAGE(ID_COPY,ID_ICONCOPY,1)
 NG=1
 IF(SIZE(GRAPH,2).GT.1)THEN
  CALL WDIALOGPUTMENU(IDF_MENU1,GRAPHNAMES,SIZE(GRAPHNAMES),NG)
  CALL WDIALOGFIELDSTATE(IDF_LABEL2,3)
 ELSE
  CALL WDIALOGFIELDSTATE(IDF_MENU1,3)
  CALL WDIALOGFIELDSTATE(IDF_LABEL2,3)
 ENDIF
 CALL WDIALOGPUTSTRING(IDF_LABEL1,'Move your mouse in the graph!')
 !## position graph initially
 IF(ALLOCATED(GRAPHUNITS))DEALLOCATE(GRAPHUNITS)
 IF(ALLOCATED(GRAPHAREA))DEALLOCATE(GRAPHAREA)
 ALLOCATE(GRAPHUNITS(6,1),GRAPHAREA(4,1))
 CALL PROFILE_DRAWGRAPH(ID_DSCENTOOL_FIGURE,IDF_PICTURE1,IBITMAP,NG,XTXT,YTXT,LDATE,.TRUE.)
 CALL WDIALOGSHOW(-1,-1,0,3)

 DO
  CALL WMESSAGE(ITYPE,MESSAGE)
  SELECT CASE (ITYPE)
   CASE (MOUSEMOVE)
    CALL PROFILE_GRAPHMOUSE(MESSAGE,LDATE,0)
   CASE (PUSHBUTTON)
    SELECT CASE (MESSAGE%VALUE1)
     CASE (ID_ZOOMIN,ID_ZOOMOUT,ID_ZOOMFULL,ID_ZOOMBOX,ID_MOVE)
      CALL PROFILE_ZOOMGRAPH(ID_DSCENTOOL_FIGURE,MESSAGE%VALUE1,IBITMAP,LDATE,NG,XTXT,YTXT)
     CASE (ID_COPY)
      CALL WCLIPBOARDPUTBITMAP(IBITMAP)
     CASE (IDHELP)
       CALL IMODGETHELP('5.9.2','TMO.PT.Start')              
     CASE (IDCANCEL)
      EXIT
    END SELECT
   CASE (FIELDCHANGED)
    SELECT CASE (MESSAGE%VALUE2)
     CASE (IDF_MENU1)
      CALL WDIALOGSELECT(ID_DSCENTOOL_FIGURE)
      CALL WDIALOGGETMENU(IDF_MENU1,NG)
      CALL PROFILE_DRAWGRAPH(ID_DSCENTOOL_FIGURE,IDF_PICTURE1,IBITMAP,NG,XTXT,YTXT,LDATE,.TRUE.)
    END SELECT
   CASE (RESIZE,EXPOSE)
    !## refresh graph
    CALL PROFILE_DRAWGRAPH(ID_DSCENTOOL_FIGURE,IDF_PICTURE1,IBITMAP,NG,XTXT,YTXT,LDATE,.FALSE.)
  END SELECT
 END DO

 CALL WBITMAPDESTROY(IBITMAP)

 IF(WINFOMOUSE(MOUSECURSOR).NE.CURARROW)CALL WCURSORSHAPE(CURARROW)
 CALL WDIALOGUNLOAD()
 DEALLOCATE(GRAPHUNITS,GRAPHAREA)
 CALL WINDOWSELECT(MPW%IWIN)
 CALL IGRSELECT(DRAWWIN,MPW%IWIN)
 CALL IGRAREA(0.0,0.0,1.0,1.0)
 CALL IGRUNITS(MPW%XMIN,MPW%YMIN,MPW%XMAX,MPW%YMAX)

 END SUBROUTINE PROFILE_PLOTGRAPH

 !###======================================================================
 SUBROUTINE PROFILE_GRAPHMOUSE(MESSAGE,LDATE,IDOWN)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IDOWN
 LOGICAL,INTENT(IN) :: LDATE
 TYPE(WIN_MESSAGE),INTENT(IN) :: MESSAGE
 
 IF(MESSAGE%WIN.EQ.ID_DSCENTOOL_FIGURE)THEN
  IF(IDOWN.EQ.0.AND.WINFOMOUSE(MOUSECURSOR).NE.CURCROSSHAIR)CALL WCURSORSHAPE(CURCROSSHAIR)
  IF(LDATE)THEN
   CALL WDIALOGPUTSTRING(IDF_LABEL1,'Date='//TRIM(JDATETOGDATE(INT(MESSAGE%GX)))//'; Ycrd='//TRIM(RTOS(MESSAGE%GY,'F',2)))
  ELSE
   CALL WDIALOGPUTSTRING(IDF_LABEL1,'Xcrd='//TRIM(RTOS(MESSAGE%GX,'F',2))//'; Ycrd='//TRIM(RTOS(MESSAGE%GY,'F',2)))
  ENDIF
 ELSE
  IF(IDOWN.EQ.0.AND.WINFOMOUSE(MOUSECURSOR).NE.CURARROW)CALL WCURSORSHAPE(CURARROW)
 ENDIF
 
 END SUBROUTINE PROFILE_GRAPHMOUSE

 !###======================================================================
 SUBROUTINE PROFILE_DRAWGRAPH(IDD,IDF,IBITMAP,NG,XTITLE,YTITLE,LDATE,LINI)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IDD,IDF,NG
 INTEGER,INTENT(INOUT) :: IBITMAP
 LOGICAL,INTENT(IN) :: LDATE,LINI
 CHARACTER(LEN=*),INTENT(IN) :: XTITLE,YTITLE
 INTEGER :: IW,IH,I,J,NP
 REAL :: DX,DY,XMIN,YMIN,XMAX,YMAX,X1,X2,XW1,XW2
 TYPE(AXESOBJ) :: AXES

 !## childwindow - size for the bitmap
 CALL WDIALOGSELECT(IDD)
 CALL IGRSELECT(DRAWFIELD,IDF)
 IW=WINFODRAWABLE(DRAWABLEWIDTH)
 IH=WINFODRAWABLE(DRAWABLEHEIGHT)
 IF(IBITMAP.NE.0)CALL WBITMAPDESTROY(IBITMAP)
 CALL WBITMAPCREATE(IBITMAP,IW,IH)

 !## select proper bitmap
 CALL IGRSELECT(DRAWBITMAP,IBITMAP)
 !## change plotmode
 CALL IGRPLOTMODE(MODECOPY)

 !## plot axis and correct xmin,ymin,xmax,ymax for axes
 CALL IGRCOLOURN(WRGB(255,255,255))
 CALL IGRAREA(0.0,0.0,1.0,1.0)

 IF(LINI)THEN
  AXES%XMIN= 10.0E10
  AXES%XMAX=-10.0E10
  DO I=1,SIZE(GRAPH,1)
   NP=GRAPH(I,NG)%NP
   AXES%XMIN=MIN(AXES%XMIN,MINVAL(GRAPH(I,NG)%RX(1:NP)))
   AXES%XMAX=MAX(AXES%XMAX,MAXVAL(GRAPH(I,NG)%RX(1:NP)))
  ENDDO
  IF(AXES%XMIN.EQ.AXES%XMAX)THEN
   AXES%XMIN=AXES%XMIN-1.0
   AXES%XMAX=AXES%XMAX+1.0
  ENDIF
  AXES%YMIN= 10.0E10
  AXES%YMAX=-10.0E10
  DO I=1,SIZE(GRAPH,1)
   NP=GRAPH(I,NG)%NP
   AXES%YMIN=MIN(AXES%YMIN,MINVAL(GRAPH(I,NG)%RY(1:NP)))
   AXES%YMAX=MAX(AXES%YMAX,MAXVAL(GRAPH(I,NG)%RY(1:NP)))
  ENDDO
  IF(AXES%YMIN.EQ.AXES%YMAX)THEN
   AXES%YMIN=AXES%YMIN-1.0
   AXES%YMAX=AXES%YMAX+1.0
  ENDIF
  PGXMIN=AXES%XMIN
  PGXMAX=AXES%XMAX
  PGYMIN=AXES%YMIN
  PGYMAX=AXES%YMAX
 ELSE
  AXES%XMIN=PGXMIN
  AXES%XMAX=PGXMAX
  AXES%YMIN=PGYMIN
  AXES%YMAX=PGYMAX
 ENDIF
 
 DX=(AXES%XMAX-AXES%XMIN)/10.0
 AXES%XMIN=AXES%XMIN-DX
 AXES%XMAX=AXES%XMAX+DX
 DY=(AXES%YMAX-AXES%YMIN)/10.0
 AXES%YMIN=AXES%YMIN-DY
 AXES%YMAX=AXES%YMAX+DY

 AXES%IFIXX =0
 AXES%IFIXY =0
 AXES%IFIXY2=0
 AXES%XINT  =10
 AXES%YINT  =10
 AXES%IAXES=(/1,0/)       !## left/bottom axes only
 AXES%ICLRRASTER=WRGB(200,200,200)
 AXES%XFACTOR=1.0
 AXES%YFACTOR=1.0
 AXES%DXAXESL=40.0
 AXES%DYAXESB=20.0
 AXES%DYAXEST=75.0
 AXES%DXAXESR=150.0
 AXES%TFONT=FFHELVETICA   !## text-font
 AXES%YTITLE=YTITLE 
 AXES%XTITLE=XTITLE 
 AXES%LDATE=LDATE
 AXES%ICLRBACKGROUND=WRGB(123,152,168)

 !## plot axes and set units
 CALL PROFILE_PLOTAXES(AXES,1)

 DO I=SIZE(GRAPH,1),1,-1

  IF(GRAPH(I,NG)%GTYPE.EQ.1)THEN
   !## draw histogram
   DO J=1,GRAPH(I,NG)%NP !-1

    XW1=0.0
    XW2=0.0
    IF(J.LT.GRAPH(I,NG)%NP)THEN
     XW2=(GRAPH(I,NG)%RX(J+1)-GRAPH(I,NG)%RX(J))/2.0
    ENDIF
    IF(J.GT.1)THEN
     XW1=(GRAPH(I,NG)%RX(J)-GRAPH(I,NG)%RX(J-1))/2.0
    ENDIF
     
    X1=GRAPH(I,NG)%RX(J)-XW1
    X2=GRAPH(I,NG)%RX(J)+XW2

    CALL IGRFILLPATTERN(SOLID)

    IF(MIN(0.0,GRAPH(I,NG)%RY(J)).NE.MAX(0.0,GRAPH(I,NG)%RY(J)))THEN
     
     CALL IGRCOLOURN(GRAPH(I,NG)%ICLR)
     CALL IGRRECTANGLE(X1,MIN(0.0,GRAPH(I,NG)%RY(J)),X2,MAX(0.0,GRAPH(I,NG)%RY(J)))
     CALL IGRFILLPATTERN(OUTLINE)
     CALL IGRCOLOURN(WRGB(0,0,0))
     CALL IGRRECTANGLE(X1,MIN(0.0,GRAPH(I,NG)%RY(J)),X2,MAX(0.0,GRAPH(I,NG)%RY(J)))
    ELSE
     CALL IGRJOIN(X1,MIN(0.0,GRAPH(I,NG)%RY(J)),X2,MAX(0.0,GRAPH(I,NG)%RY(J)))
    ENDIF
   END DO
  ELSEIF(GRAPH(I,NG)%GTYPE.EQ.2)THEN
   !## draw lines
   CALL IGRLINETYPE(SOLIDLINE)
   CALL IGRCOLOURN(GRAPH(I,NG)%ICLR)
   DO J=1,GRAPH(I,NG)%NP-1
    CALL IGRJOIN(GRAPH(I,NG)%RX(J)  ,GRAPH(I,NG)%RY(J),&
                 GRAPH(I,NG)%RX(J+1),GRAPH(I,NG)%RY(J+1))
   END DO
  !## filled per pare (stackhistogram)
  ELSEIF(GRAPH(I,NG)%GTYPE.EQ.3)THEN
   CALL IGRFILLPATTERN(SOLID)
   CALL IGRCOLOURN(GRAPH(I,NG)%ICLR) 
   DO J=2,GRAPH(I,NG)%NP-1,2
    CALL IGRRECTANGLE(GRAPH(I,NG)%RX(J),GRAPH(I,NG)%RY(J),GRAPH(I,NG)%RX(J+1),GRAPH(I,NG)%RY(J+1))
   END DO
  ENDIF

 ENDDO

 CALL WGRTEXTORIENTATION(ALIGNLEFT,0.0,DIRHORIZ)
 DX=AXES%CHW*(AXES%XMAX-AXES%XMIN)
 DY=AXES%CHH*(AXES%YMAX-AXES%YMIN)
 
 XMIN=AXES%XMIN+DX
 XMAX=XMIN+DX*2.0
 YMAX=AXES%YMAX-DY
 !## ipattern:0=solid,1=line,2=points,3=legend
 DO I=1,SIZE(GRAPH,1)
  YMIN=YMAX-DY
  !## plot axes-text
  CALL IGRCOLOURN(WRGB(0,0,0))
  CALL WGRTEXTSTRING(XMAX+DX,(YMAX+YMIN)/2.0,' '//TRIM(GRAPH(I,NG)%LEGTXT))
  SELECT CASE (GRAPH(I,NG)%GTYPE)
   CASE (2)   !## lines
    CALL UTL_DRAWLEGENDBOX(XMIN,YMIN,XMAX,YMAX,GRAPH(I,NG)%ICLR,1,SOLIDLINE,1)
   CASE (1,3) !## filled                                                     
    CALL UTL_DRAWLEGENDBOX(XMIN,YMIN,XMAX,YMAX,GRAPH(I,NG)%ICLR,1,SOLIDLINE,0)
  END SELECT
  YMAX=YMIN
 ENDDO
 CALL IGRLINEWIDTH(2)
 CALL IGRCOLOURN(WRGB(0,0,0))
 CALL IGRJOIN(AXES%XMIN,AXES%YMIN,AXES%XMAX,AXES%YMIN)
 CALL IGRLINEWIDTH(1)

 CALL WDIALOGSELECT(IDD)
 CALL IGRSELECT(DRAWFIELD,IDF)
 CALL WBITMAPPUT(IBITMAP,0,1)
 
 END SUBROUTINE PROFILE_DRAWGRAPH

 !###====================================================================
 SUBROUTINE PROFILE_ZOOMGRAPH(IDD,IDZ,IBITMAP,LDATE,NG,XTXT,YTXT)
 !###====================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: NG
 INTEGER,INTENT(OUT) :: IBITMAP
 CHARACTER(LEN=*),INTENT(IN) :: XTXT,YTXT
 INTEGER,INTENT(IN) :: IDZ,IDD
 LOGICAL,INTENT(IN) :: LDATE
 REAL,PARAMETER :: FZIN =0.75
 REAL,PARAMETER :: FZOUT=1.5
 TYPE(WIN_MESSAGE) :: MESSAGE
 INTEGER :: ITYPE,IDOWN,IDCURSOR,I
 REAL :: FZ,XC1,YC1,XC2,YC2,XC3,YC3,DX,DY
 LOGICAL :: LEX
 INTEGER,DIMENSION(6) :: ID
 DATA ID/ID_ZOOMIN,ID_ZOOMOUT,ID_ZOOMFULL,ID_ZOOMBOX,ID_MOVE,ID_COPY/

 IF(IDZ.EQ.ID_ZOOMIN)THEN
  FZ=FZIN
  IDCURSOR=ID_CURSORPOINTPLUS
 ELSEIF(IDZ.EQ.ID_ZOOMOUT)THEN
  FZ=FZOUT
  IDCURSOR=ID_CURSORPOINTMIN
 ELSEIF(IDZ.EQ.ID_ZOOMBOX)THEN
  IDCURSOR=ID_CURSORZOOMRECTANGLE
 ELSEIF(IDZ.EQ.ID_MOVE)THEN
  IDCURSOR=ID_CURSORHAND
 ELSE
  CALL PROFILE_DRAWGRAPH(ID_DSCENTOOL_FIGURE,IDF_PICTURE1,IBITMAP,NG,XTXT,YTXT,LDATE,.TRUE.)
  RETURN
 ENDIF

 DO I=1,SIZE(ID); IF(ID(I).NE.IDZ)CALL WDIALOGFIELDSTATE(ID(I),0); END DO

 CALL WCURSORSHAPE(IDCURSOR)

 IDOWN=0
 LEX  =.FALSE.
 XC1  =0.0
 YC1  =0.0
 DO

  CALL WMESSAGE(ITYPE,MESSAGE)

  IF(MESSAGE%WIN.EQ.IDD)THEN

   SELECT CASE(ITYPE)

    CASE(MOUSEMOVE)
     CALL PROFILE_GRAPHMOUSE(MESSAGE,LDATE,1)

     XC2=MESSAGE%GX
     YC2=MESSAGE%GY

     IF(IDZ.EQ.ID_MOVE)THEN
      IF(IDOWN.GT.0)THEN
       DX=XC1-XC2
       DY=YC1-YC2
       PGXMAX=PGXMAX+DX
       PGXMIN=PGXMIN+DX
       PGYMAX=PGYMAX+DY
       PGYMIN=PGYMIN+DY
       CALL PROFILE_DRAWGRAPH(ID_DSCENTOOL_FIGURE,IDF_PICTURE1,IBITMAP,NG,XTXT,YTXT,LDATE,.FALSE.)
      ENDIF
     ELSEIF(IDZ.EQ.ID_ZOOMBOX)THEN

      IF(IDOWN.GT.0)THEN

       CALL IGRPLOTMODE(MODEXOR)
       CALL IGRCOLOURN(WRGB(255,255,255))
       CALL IGRFILLPATTERN(OUTLINE)
       CALL IGRLINETYPE(DASHED)

       IF(LEX)CALL IGRRECTANGLE(XC1,YC1,XC3,YC3)
       LEX=.FALSE.

       IF(IDOWN.EQ.1)THEN
        IF(XC1.NE.XC2.AND.YC1.NE.YC2)LEX=.TRUE.
        IF(LEX)CALL IGRRECTANGLE(XC1,YC1,XC2,YC2)
       ENDIF

      ENDIF
     ENDIF

     XC3=XC2
     YC3=YC2

    CASE (RESIZE,EXPOSE)
     !## refresh graph
     CALL PROFILE_DRAWGRAPH(ID_DSCENTOOL_FIGURE,IDF_PICTURE1,IBITMAP,NG,XTXT,YTXT,LDATE,.FALSE.)

    CASE (MOUSEBUTUP)
     IF(IDZ.EQ.ID_MOVE)THEN
      SELECT CASE (MESSAGE%VALUE1)
       CASE (1)
        CALL WCURSORSHAPE(ID_CURSORHAND)
        IDOWN=0
      END SELECT
     ENDIF

    CASE (MOUSEBUTDOWN)

     IF(IDZ.EQ.ID_ZOOMIN.OR.IDZ.EQ.ID_ZOOMOUT)THEN
      SELECT CASE (MESSAGE%VALUE1)
       CASE (1)
        XC2 = XC3
        YC2 = YC3
        DX  = PGXMAX-PGXMIN
        DY  = PGYMAX-PGYMIN
        PGXMAX= XC2+0.5*DX*FZ
        PGXMIN= XC2-0.5*DX*FZ
        PGYMIN= YC2-0.5*DY*FZ
        PGYMAX= YC2+0.5*DY*FZ
        CALL PROFILE_DRAWGRAPH(ID_DSCENTOOL_FIGURE,IDF_PICTURE1,IBITMAP,NG,XTXT,YTXT,LDATE,.FALSE.)
       CASE (3)
        EXIT
      END SELECT
     ELSEIF(IDZ.EQ.ID_MOVE)THEN
      SELECT CASE (MESSAGE%VALUE1)
       CASE (1)
        IF(IDOWN.EQ.0)THEN
         XC1  =XC2
         YC1  =YC2
         IDOWN=1
         CALL WCURSORSHAPE(ID_CURSORHANDGREP)
        ENDIF
       CASE (3)
        EXIT
      END SELECT
     ELSEIF(IDZ.EQ.ID_ZOOMBOX)THEN
      SELECT CASE (MESSAGE%VALUE1)
       CASE (1)
        IF(IDOWN.EQ.0)THEN
         XC1  =XC2
         YC1  =YC2
         IDOWN=1
        ELSE
         PGXMAX=MAX(XC1,XC3)
         PGXMIN=MIN(XC1,XC3)
         PGYMAX=MAX(YC1,YC3)
         PGYMIN=MIN(YC1,YC3)
         EXIT
        ENDIF
      END SELECT
     ENDIF

   END SELECT

  ENDIF
 ENDDO

 CALL WCURSORSHAPE(CURARROW)

 IF(IDZ.EQ.ID_ZOOMBOX)THEN
  CALL IGRPLOTMODE(MODECOPY)
  CALL IGRLINETYPE(SOLIDLINE)
 ENDIF

 CALL PROFILE_DRAWGRAPH(ID_DSCENTOOL_FIGURE,IDF_PICTURE1,IBITMAP,NG,XTXT,YTXT,LDATE,.FALSE.)

 DO I=1,SIZE(ID); IF(ID(I).NE.IDZ)CALL WDIALOGFIELDSTATE(ID(I),1); END DO

 END SUBROUTINE PROFILE_ZOOMGRAPH

 !###====================================================================
 SUBROUTINE PROFILE_ALLGRAPH(NI,NJ)
 !###====================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: NI,NJ
 INTEGER :: I,J

 !## ni=number of lines 
 !## nj=number of seperated graphs
 ALLOCATE(GRAPH(NI,NJ))
 DO I=1,NI
  DO J=1,NJ
   NULLIFY(GRAPH(I,J)%RX,GRAPH(I,J)%RY)
  ENDDO
 ENDDO
 ALLOCATE(GRAPHNAMES(NJ))
 
 END SUBROUTINE PROFILE_ALLGRAPH

 !###====================================================================
 SUBROUTINE PROFILE_DEALLGRAPH()
 !###====================================================================
 IMPLICIT NONE
 INTEGER :: I,J

 IF(ALLOCATED(GRAPH))THEN
  DO I=1,SIZE(GRAPH,1)
   DO J=1,SIZE(GRAPH,2)
    IF(ASSOCIATED(GRAPH(I,J)%RX))DEALLOCATE(GRAPH(I,J)%RX)
    IF(ASSOCIATED(GRAPH(I,J)%RY))DEALLOCATE(GRAPH(I,J)%RY)
   END DO
  END DO
  DEALLOCATE(GRAPH)
 ENDIF
 IF(ALLOCATED(GRAPHNAMES))DEALLOCATE(GRAPHNAMES)
 
 END SUBROUTINE PROFILE_DEALLGRAPH

 !###====================================================================
 SUBROUTINE PROFILE_EXTENT_2DBITMAP()
 !###====================================================================
 IMPLICIT NONE

 !## inside bitmap area=0.0,0.0,1.0,1.0
 CALL IGRSELECT(DRAWBITMAP,MPW%IBITMAP)
 CALL IGRAREA(0.0,0.0,1.0,1.0)
 CALL IGRUNITS(MPW%XMIN,MPW%YMIN,MPW%XMAX,MPW%YMAX)
 CALL IGRCOLOURN(WRGB(255,255,255))
 CALL IGRPLOTMODE(MODEXOR)
 CALL IGRLINETYPE(SOLIDLINE)
! CALL IGRLINEWIDTH(3)

 END SUBROUTINE PROFILE_EXTENT_2DBITMAP

 !###====================================================================
 SUBROUTINE PROFILE_EXTENT_GRAPH(IWINID)
 !###====================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IWINID
 
 CALL WINDOWSELECT(IWINPROFILE(IWINID))
 CALL IGRSELECT(DRAWWIN,IWINPROFILE(IWINID))
 CALL IGRAREA( GRAPHAREA(1,1) ,GRAPHAREA(2,1) ,GRAPHAREA(3,1) ,GRAPHAREA(4,1))
 CALL IGRUNITS(GRAPHUNITS(1,1),GRAPHUNITS(2,1),GRAPHUNITS(3,1),GRAPHUNITS(4,1))
 
 END SUBROUTINE PROFILE_EXTENT_GRAPH

 !###====================================================================
 SUBROUTINE PROFILE_PLOTLOCATION(LINEWIDTHPLOT)
 !###====================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: LINEWIDTHPLOT
 REAL :: X,Y,RADIUS

 IF(XPOS.EQ.0.0)RETURN

 RADIUS=SQRT((MPW%XMAX-MPW%XMIN)**2.0+(MPW%YMAX-MPW%YMIN)**2.0)/100.0
 CALL PROFILE_GETLOCATION(X,Y,XPOS)
 CALL IGRFILLPATTERN(OUTLINE)
 CALL IGRLINEWIDTH(LINEWIDTHPLOT)
 CALL IGRCIRCLE(X,Y,RADIUS)
 CALL IGRLINEWIDTH(1)
 
 END SUBROUTINE PROFILE_PLOTLOCATION

 !###====================================================================
 SUBROUTINE PROFILE_GETLOCATION(X,Y,XP,ISEG)
 !###====================================================================
 !##
 !## based upon the value of xpos, return x,y coordinates
 !##
 IMPLICIT NONE
 REAL,INTENT(IN) :: XP
 REAL,INTENT(OUT) :: X,Y
 INTEGER,INTENT(OUT),OPTIONAL :: ISEG
 REAL :: D,TD,RATIO
 INTEGER :: I

 TD=0.0
 DO I=2,NXY
  D =SQRT((XY(1,I)-XY(1,I-1))**2.0+(XY(2,I)-XY(2,I-1))**2.0)
  TD=TD+D
  !## inside current segment
  IF(TD.GE.XP)THEN
   RATIO=(D-(TD-XP))/D
   IF(RATIO.GT.0.0)THEN
    X=XY(1,I-1)+RATIO*(XY(1,I)-XY(1,I-1))
    Y=XY(2,I-1)+RATIO*(XY(2,I)-XY(2,I-1))
   ELSE
    X=XY(1,I-1)
    Y=XY(2,I-1)
   ENDIF
   IF(PRESENT(ISEG))ISEG=I; EXIT
  ENDIF
 END DO

 END SUBROUTINE PROFILE_GETLOCATION
  
 !###======================================================================
 SUBROUTINE PROFILE_AXES(MINVAL,MAXVAL,OFFSET,NINTV)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,PARAMETER :: NINTERVALS=5
 INTEGER,INTENT(INOUT) :: NINTV
 REAL,INTENT(INOUT) :: MINVAL,MAXVAL
 REAL,INTENT(IN) :: OFFSET
 REAL,DIMENSION(NINTERVALS) :: FINTERVALS
 INTEGER :: TNINTV,I,J,N
 REAL :: TMINVAL,TMAXVAL,FACT,DEL,BEG,END,D
 DATA FINTERVALS/1.0,2.0,2.5,5.0,10.0/
 REAL :: MAXIMUM,MINIMUM,RANGE,RLOG,INCR
 
 MAXIMUM=MAXVAL-OFFSET
 MINIMUM=MINVAL-OFFSET
 RANGE=MAXIMUM-MINIMUM
 MINIMUM=MINIMUM-0.05*RANGE
 MAXIMUM=MAXIMUM+0.05*RANGE
 RANGE=MAXIMUM-MINIMUM;
 
 IF(RANGE.EQ.0.0)RANGE=1.0
 RLOG=LOG10(RANGE)-INT(LOG10(RANGE))
 IF(RANGE.LT.1.0)RLOG=RLOG+1.0
 IF(RLOG.GT.0.6)THEN
  INCR=1.0
 ELSEIF(RLOG.GT.0.3)THEN
  INCR=0.5
 ELSE
  INCR=0.2
 ENDIF
 IF(RANGE.LT.1.0)INCR=INCR/10.0
 I=INT(LOG10(RANGE))
 INCR=INCR*(10**I)
 IF(MINIMUM.LT.0.0)THEN
  MINIMUM=(INT(MINIMUM/INCR)-1)*INCR
 ELSE 
  MINIMUM=INT(MINIMUM/INCR)*INCR
 ENDIF
 IF(MAXIMUM.LT.0)THEN
  MAXIMUM=(INT(MAXIMUM/INCR))*INCR
 ELSE
  MAXIMUM=(INT(MAXIMUM/INCR)+1)*INCR
 ENDIF

 IF(INCR.NE.0.0)THEN

  MINVAL=MINIMUM+OFFSET
  MAXVAL=MAXIMUM+OFFSET
  NINTV=(MAXVAL-MINVAL)/INCR

 ELSE
   
  !copy given parameters
  TNINTV =NINTV
  TMINVAL=MIN(MINVAL,MAXVAL)
  TMAXVAL=MAX(MINVAL,MAXVAL)
  !apply offset
  TMINVAL=TMINVAL-OFFSET
  TMAXVAL=TMAXVAL-OFFSET
  !gues for interval size
  DEL=(TMAXVAL-TMINVAL)/TNINTV
  !place del between 1 and 10 by using a factor
  FACT=INT(LOG10(DEL))
  FACT=10.0**FACT
  DEL =DEL/FACT
  !apply factor to tminval and tminval too
  TMINVAL=TMINVAL/FACT
  TMAXVAL=TMAXVAL/FACT
  !search for a nice value of del (choose values of fintervals) which gives
  !the number of intervals closest to nint (>0)
  J     =0
  TNINTV=0
  DO I=1,NINTERVALS
   D  =FINTERVALS(I)
   BEG=INT(TMINVAL/D)*D
   END=INT(TMAXVAL/D)*D
   IF(BEG.GT.TMINVAL)BEG=BEG-D
   IF(END.LT.TMAXVAL)END=END+D
   N=INT((END-BEG+0.5*D)/D)
  !choose n closest to nintv
   IF(N.GT.0)THEN
    IF(TNINTV.EQ.0)THEN
  !first result
     TNINTV=N
     J     =I  ! save position in fintervals array
    ELSE
     IF(ABS(NINTV-N).LT.ABS(NINTV-TNINTV))THEN
  !current solution is better, save it
      TNINTV=N
      J     =I  ! save position in fintervals array
     ENDIF
    ENDIF
   ENDIF
  ENDDO

  J=MIN(NINTERVALS,J)
  J=MAX(1         ,J)

  !calculate result
  D  =FINTERVALS(J)
  BEG=INT(TMINVAL/D)*D
  END=INT(TMAXVAL/D)*D
  IF(BEG.GT.TMINVAL)BEG=BEG-D
  IF(END.LT.TMAXVAL)END=END+D
  NINTV=INT((END-BEG+0.5*D)/D)

  !scale values back to original magnitude
  TMINVAL=BEG*FACT+OFFSET
  TMAXVAL=END*FACT+OFFSET

  !save result
  NINTV =TNINTV
  MINVAL=TMINVAL
  MAXVAL=TMAXVAL
 
 ENDIF
 
 END SUBROUTINE PROFILE_AXES

 !###======================================================================
 SUBROUTINE PROFILE_PLOTAXES(AXES,IWINID)
 !###======================================================================
 IMPLICIT NONE
 TYPE(AXESOBJ),INTENT(INOUT) :: AXES
 INTEGER,INTENT(IN) :: IWINID
 CHARACTER(LEN=20) :: CDATE
 INTEGER :: I,IWD,IHD,IWS,IHS,NL
 REAL :: DX,DY,DXTIC,DYTIC,X,Y,DMX1,RATIO, &
         DMX2,DMY1,DMY2,TWIDTH,THEIGHT,&
         XASMIN,XASMAX,YASMIN,YASMAX,XASINT,YASINT,SX_RATIO,SY_RATIO, &
         Y2ASMIN,Y2ASMAX,Y2ASINT,D2Y
 REAL :: XJDCOR !## correction for x in case of large numbers caused by julian-date

 !## drawable settings
 IWD=WINFODRAWABLE(DRAWABLEWIDTH)
 IHD=WINFODRAWABLE(DRAWABLEHEIGHT)

 !## screen setting
 IWS=WINFOSCREEN(SCREENWIDTH)
 IHS=WINFOSCREEN(SCREENHEIGHT)

 SX_RATIO=REAL(IWS)/REAL(IWD)
 SY_RATIO=REAL(IHS)/REAL(IHD)

 !## determine axes min/max values
 XASMIN=AXES%XMIN
 XASMAX=AXES%XMAX

 XJDCOR=0.0
 !## correct for large julian-date numbers
 IF(AXES%LDATE)THEN
  XJDCOR=-XASMIN
  XASMIN= XASMIN+XJDCOR
  XASMAX= XASMAX+XJDCOR
 ENDIF
 
 YASMIN=AXES%YMIN
 YASMAX=AXES%YMAX

 !## second y-axes
 IF(AXES%IAXES(2).EQ.1)THEN
  Y2ASMIN=AXES%Y2MIN
  Y2ASMAX=AXES%Y2MAX
  Y2ASINT=AXES%Y2INT
 ENDIF
 
 CALL UTL_GETAXESCALES(XASMIN,YASMIN,XASMAX,YASMAX)

 XASINT=AXES%XINT
 YASINT=AXES%YINT

 IF(AXES%IFIXX.EQ.0)THEN

  XASINT=SXVALUE(2)-SXVALUE(1)
  XASMIN=SXVALUE(1)

 ENDIF

 IF(AXES%IFIXY.EQ.0)THEN

  YASINT=SYVALUE(2)-SYVALUE(1) 
  YASMIN=SYVALUE(1)

 ENDIF

 !## second y-axes
 IF(AXES%IAXES(2).EQ.1)THEN
  IF(AXES%IFIXY2.EQ.0)THEN

   CALL UTL_GETAXESCALES(XASMIN,Y2ASMIN,XASMAX,Y2ASMAX)

   Y2ASINT=SYVALUE(2)-SYVALUE(1)
   Y2ASMIN=SYVALUE(1)

  ENDIF
 ENDIF

 DX=AXES%XMAX-AXES%XMIN
 DY=AXES%YMAX-AXES%YMIN

 IF(AXES%IAXES(2).EQ.1)THEN
  D2Y =AXES%Y2MAX-AXES%Y2MIN
  DMY1=D2Y*(SY_RATIO*(1.0/AXES%DYAXESB))
  DMY2=D2Y*(SY_RATIO*(1.0/AXES%DYAXEST))
  GRAPHUNITS(5,IWINID)=AXES%Y2MIN-DMY1
  GRAPHUNITS(6,IWINID)=AXES%Y2MAX+DMY2
 ENDIF

 !## compute marge - depends on size - textsize depend on these distances!!!
 DMX1=DX*(SX_RATIO*(1.0/AXES%DXAXESL))
 DMX2=DX*(SX_RATIO*(1.0/AXES%DXAXESR))
 DMY1=DY*(SY_RATIO*(1.0/AXES%DYAXESB))
 DMY2=DY*(SY_RATIO*(1.0/AXES%DYAXEST))

 GRAPHUNITS(1,IWINID)=AXES%XMIN-DMX1+XJDCOR
 GRAPHUNITS(3,IWINID)=AXES%XMAX+DMX2+XJDCOR
 GRAPHUNITS(2,IWINID)=AXES%YMIN-DMY1
 GRAPHUNITS(4,IWINID)=AXES%YMAX+DMY2

 !## tic length
 DXTIC=DMX1/8.0
 DYTIC=DMY1/8.0

 NL=1
 IF(AXES%XTITLE.NE.''.OR.AXES%YTITLE.NE.'')NL=NL+1

 !## entire bitmap
 CALL IGRAREACLEAR()
 CALL IGRUNITS(GRAPHUNITS(1,IWINID),GRAPHUNITS(2,IWINID),GRAPHUNITS(3,IWINID),GRAPHUNITS(4,IWINID))
 RATIO=(GRAPHUNITS(3,IWINID)-GRAPHUNITS(1,IWINID))/(GRAPHUNITS(4,IWINID)-GRAPHUNITS(2,IWINID))
 
 !## compute proper textsize as ratio of dy
 CALL UTL_SETTEXTSIZE(TWIDTH,THEIGHT,((AXES%YMIN-GRAPHUNITS(2,IWINID))/(NL+0.5))/(GRAPHUNITS(4,IWINID)-GRAPHUNITS(2,IWINID)))
 CALL WGRTEXTFONT(AXES%TFONT,WIDTH=TWIDTH,HEIGHT=THEIGHT,ISTYLE=0)
 AXES%CHH=THEIGHT
 AXES%CHW=TWIDTH

 !## fill deltares blue colour
 CALL IGRFILLPATTERN(SOLID)
 CALL IGRCOLOURN(AXES%ICLRBACKGROUND)
 CALL IGRRECTANGLE(GRAPHUNITS(1,IWINID),GRAPHUNITS(2,IWINID),GRAPHUNITS(3,IWINID),GRAPHUNITS(4,IWINID))

 !## white drawing area
 CALL IGRFILLPATTERN(SOLID)
 CALL IGRCOLOURN(WRGB(255,255,255))
 CALL IGRRECTANGLE(AXES%XMIN+XJDCOR,AXES%YMIN,AXES%XMAX+XJDCOR,AXES%YMAX)

 CALL IGRLINEWIDTH(1)
 CALL IGRLINETYPE(DASHED)

 !##=== vertical axes ===

 CALL WGRTEXTORIENTATION(ALIGNCENTRE,90.0,DIRHORIZ,ALIGNCENTRE)

 DO
  !## get length of vertical axes
  Y =YASMIN-YASINT
  DY=0.0
  DO
   Y=Y+YASINT
   IF(Y.GE.AXES%YMAX)EXIT
   IF(Y.GT.AXES%YMIN)THEN
    WRITE(CDATE,UTL_GETFORMAT(Y*AXES%YFACTOR)) Y*AXES%YFACTOR
    DY=DY+WGRTEXTLENGTH(TRIM(ADJUSTL(CDATE)))*WINFOGRREAL(GRAPHICSCHHEIGHT)
   ENDIF
  END DO

  DY=DY*REAL(IHD)/REAL(IWD)*1.25
  !## increase interval in case axes is to big
  IF(DY.LT.(AXES%YMAX-AXES%YMIN))EXIT
  YASINT=YASINT*2.0
 ENDDO
 
 !## vertical axes - vertical plotting
 Y =YASMIN-YASINT
 DX=DMX1/REAL(NL+1)
 DO
  Y=Y+YASINT
  IF(Y.GT.AXES%YMAX)EXIT
  IF(Y.GT.AXES%YMIN)THEN
   CALL IGRLINETYPE(DASHED)
   CALL IGRCOLOURN(AXES%ICLRRASTER)
   CALL IGRJOIN(AXES%XMIN+XJDCOR,Y,AXES%XMAX+XJDCOR,Y) !## raster
   CALL IGRLINETYPE(SOLIDLINE)
   CALL IGRCOLOURN(WRGB(256,256,256))
   CALL IGRJOIN((AXES%XMIN+XJDCOR)-DXTIC,Y,(AXES%XMIN+XJDCOR)+DXTIC,Y)
   !## plot right axes in case no secondary y-axes is plotted
   IF(AXES%IAXES(2).EQ.0)CALL IGRJOIN((AXES%XMAX+XJDCOR)-DXTIC,Y,(AXES%XMAX+XJDCOR)+DXTIC,Y)
   !## plot axes-text
   CALL WGRTEXTREAL((AXES%XMIN+XJDCOR)-DX,Y,Y*AXES%YFACTOR,TRIM(UTL_GETFORMAT(Y*AXES%YFACTOR)))
  ENDIF
 END DO

 !## vertical axes
 IF(LEN_TRIM(AXES%YTITLE).NE.0)THEN
  X=(AXES%XMIN+XJDCOR)-(2.0*DX)
  Y=(AXES%YMAX+AXES%YMIN)/2.0
  IF(AXES%YFACTOR.NE.1.0)THEN
   CALL WGRTEXTSTRING(X,Y,TRIM(AXES%YTITLE)//' (x '//TRIM(RTOS(1.0/AXES%YFACTOR,'F',2))//')')
  ELSE
   CALL WGRTEXTSTRING(X,Y,TRIM(AXES%YTITLE))
  ENDIF
 ENDIF

 !## second vertical axes - vertical plotting
 IF(AXES%IAXES(2).EQ.1)THEN

  CALL IGRUNITS(GRAPHUNITS(1,IWINID),GRAPHUNITS(5,IWINID),GRAPHUNITS(3,IWINID),GRAPHUNITS(6,IWINID))

  Y =Y2ASMIN-Y2ASINT
  DX=DMX1/REAL(NL+1)
  DO
   Y=Y+Y2ASINT
   IF(Y.GT.AXES%Y2MAX)EXIT
   IF(Y.GT.AXES%Y2MIN)THEN
    CALL IGRLINETYPE(DOTTED)
    CALL IGRCOLOURN(AXES%ICLRRASTER)
    CALL IGRJOIN(AXES%XMIN+XJDCOR,Y,AXES%XMAX+XJDCOR,Y)
    CALL IGRLINETYPE(SOLIDLINE)
    CALL IGRCOLOURN(WRGB(256,0,0))
    CALL IGRJOIN(AXES%XMAX+DXTIC+XJDCOR,Y,AXES%XMAX-DXTIC+XJDCOR,Y)
    !## plot axes-text
    CALL WGRTEXTREAL(AXES%XMAX+DX+XJDCOR,Y,Y,TRIM(UTL_GETFORMAT(Y)))
   ENDIF
  END DO

  !## vertical axes
  IF(LEN_TRIM(AXES%YTITLE).NE.0)THEN
   X= AXES%XMAX+XJDCOR+(2.0*DX)
   Y=(AXES%Y2MAX+AXES%Y2MIN)/2.0
   CALL WGRTEXTSTRING(X,Y,TRIM(AXES%Y2TITLE))
  ENDIF

  CALL IGRUNITS(GRAPHUNITS(1,1),GRAPHUNITS(2,1),GRAPHUNITS(3,1),GRAPHUNITS(4,1))

 ENDIF

 !##=== horizontal axes ===

 CALL WGRTEXTORIENTATION(ALIGNCENTRE,0.0,DIRHORIZ,ALIGNCENTRE)

 !## now I know the textsize, determine number of classes
 !X =AXES%XMIN-XASINT 
 X =XASMIN-XASINT
 DX=0.0
 DO
  X=X+XASINT
  IF(X.GT.AXES%XMAX+XJDCOR)EXIT
  IF(X.GT.AXES%XMIN+XJDCOR)THEN
   IF(AXES%LDATE)THEN
    CDATE=JDATETOFDATE(X-XJDCOR,AXES%XOFFSET)
    DX=DX+1.75*WGRTEXTLENGTH(TRIM(CDATE))*WINFOGRREAL(GRAPHICSCHWIDTH)
   ELSE
    DX=DX+WGRTEXTLENGTH(TRIM(UTL_GETFORMAT((X+XJDCOR)*AXES%XFACTOR)))*WINFOGRREAL(GRAPHICSCHWIDTH)
   ENDIF
  ENDIF
 END DO

 !## increase interval in case axes is to big
 IF(DX.GT.(AXES%XMAX-AXES%XMIN))XASINT=XASINT*MAX(1,NINT(DX/(AXES%XMAX-AXES%XMIN)))

 !## horizontal axes - horizontal plotting
 X = XASMIN-XASINT
 DY= DMY1/REAL(NL+1)
 DO 
  X=X+XASINT
  IF(X.GT.AXES%XMAX+XJDCOR)EXIT
  IF(X.GT.AXES%XMIN+XJDCOR)THEN
   CALL IGRLINETYPE(DASHED)
   CALL IGRCOLOURN(AXES%ICLRRASTER)
   CALL IGRJOIN(X,AXES%YMIN,X,AXES%YMAX)
   CALL IGRLINETYPE(SOLIDLINE)
   CALL IGRCOLOURN(WRGB(256,256,256))
   CALL IGRJOIN(X,AXES%YMIN-DYTIC,X,AXES%YMIN+DYTIC)
   CALL IGRJOIN(X,AXES%YMAX-DYTIC,X,AXES%YMAX+DYTIC)
   IF(AXES%LDATE)THEN
    CDATE=JDATETOFDATE(X-XJDCOR,AXES%XOFFSET)
    CALL WGRTEXTSTRING(X,AXES%YMIN-DY,TRIM(CDATE))
   ELSE
    CALL WGRTEXTREAL(X,AXES%YMIN-DY,X*AXES%XFACTOR,TRIM(UTL_GETFORMAT((X+XJDCOR)*AXES%XFACTOR)))
   ENDIF
  ENDIF
 END DO

 !## horizontal axes
 IF(LEN_TRIM(AXES%XTITLE).NE.0)THEN
  X=(AXES%XMAX+AXES%XMIN)/2.0
  Y= AXES%YMIN-2.0*DY
  IF(AXES%XFACTOR.NE.1.0)THEN
   CALL WGRTEXTSTRING(X+XJDCOR,Y,TRIM(AXES%XTITLE)//' (x '//TRIM(RTOS(1.0/AXES%XFACTOR,'F',2))//')')
  ELSE
   CALL WGRTEXTSTRING(X+XJDCOR,Y,TRIM(AXES%XTITLE))
  ENDIF
 ENDIF

 CALL IGRCOLOURN(WRGB(256,256,256))
 CALL IGRLINETYPE(SOLIDLINE)

 !## back-translation
 GRAPHUNITS(1,IWINID)=GRAPHUNITS(1,IWINID)-XJDCOR
 GRAPHUNITS(3,IWINID)=GRAPHUNITS(3,IWINID)-XJDCOR
 CALL IGRUNITS(GRAPHUNITS(1,IWINID),GRAPHUNITS(2,IWINID),GRAPHUNITS(3,IWINID),GRAPHUNITS(4,IWINID)) 
 
 !## black axes
 CALL IGRLINETYPE(SOLIDLINE)
 CALL IGRFILLPATTERN(OUTLINE)
 CALL IGRLINEWIDTH(2)
 CALL IGRCOLOURN(WRGB(0,0,0))
 CALL IGRRECTANGLE(AXES%XMIN,AXES%YMIN,AXES%XMAX,AXES%YMAX)
 CALL IGRLINEWIDTH(1)

 CALL PROFILE_PLOTAXES_VIEW(AXES,IWINID)

 END SUBROUTINE PROFILE_PLOTAXES

 !###======================================================================
 SUBROUTINE PROFILE_PLOTAXES_VIEW(AXES,IWINID)
 !###======================================================================
 IMPLICIT NONE
 TYPE(AXESOBJ),INTENT(INOUT) :: AXES
 INTEGER,INTENT(IN) :: IWINID
 REAL :: DX,DY,DXA,DYA
 REAL :: X1V,Y1V,X2V,Y2V

 !## for now - only map active drawing area
 DX = GRAPHUNITS(3,1)-GRAPHUNITS(1,IWINID)
 DY = GRAPHUNITS(4,1)-GRAPHUNITS(2,IWINID)
 !## correct units for marge
 X1V=(AXES%XMIN-GRAPHUNITS(1,IWINID))/DX
 X2V=(AXES%XMAX-GRAPHUNITS(1,IWINID))/DX
 Y1V=(AXES%YMIN-GRAPHUNITS(2,IWINID))/DY
 Y2V=(AXES%YMAX-GRAPHUNITS(2,IWINID))/DY

 DXA=WINFOGRREAL(GRAPHICSAREAMAXX)-WINFOGRREAL(GRAPHICSAREAMINX)
 DYA=WINFOGRREAL(GRAPHICSAREAMAXY)-WINFOGRREAL(GRAPHICSAREAMINY)

 X1V=X1V*DXA
 X2V=X2V*DXA
 Y1V=Y1V*DYA
 Y2V=Y2V*DYA

 X1V=X1V+WINFOGRREAL(GRAPHICSAREAMINX)
 X2V=X2V+WINFOGRREAL(GRAPHICSAREAMINX)
 Y1V=Y1V+WINFOGRREAL(GRAPHICSAREAMINY)
 Y2V=Y2V+WINFOGRREAL(GRAPHICSAREAMINY)

 CALL IGRVIEWPORT(X1V,Y1V,X2V,Y2V)

 END SUBROUTINE PROFILE_PLOTAXES_VIEW

END MODULE MOD_PROFILE_UTL
