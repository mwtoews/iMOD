!!  Copyright (C) Stichting Deltares, 2005-2017.
!!
!!  This file is part of iMOD.
!!
!!  This program is free software: you can redistribute it and/or modify
!!  it under the terms of the GNU General Public License as published by
!!  the Free Software Foundation, either version 3 of the License, or
!!  (at your option) any later version.
!!
!!  This program is distributed in the hope that it will be useful,
!!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!  GNU General Public License for more details.
!!
!!  You should have received a copy of the GNU General Public License
!!  along with this program.  If not, see <http://www.gnu.org/licenses/>.
!!
!!  Contact: imod.support@deltares.nl
!!  Stichting Deltares
!!  P.O. Box 177
!!  2600 MH Delft, The Netherlands.
!!
MODULE MOD_PROFILE_UTL

USE WINTERACTER
USE RESOURCE
USE MOD_UTL, ONLY : RTOS,ITOS,UTL_GDATE,UTL_SETTEXTSIZE,UTL_DRAWLEGENDBOX,JDATETOGDATE,JDATETOFDATE,UTL_GETFORMAT,UTL_GETAXESCALES, &
              SXVALUE,SYVALUE,NSX,NSY
USE MOD_PROFILE_PAR, ONLY : XY,NXY,XPOS,IWINPROFILE,IBITMAP,AREA,PBITMAP
USE MODPLOT, ONLY : MPW
USE MOD_PREF_PAR, ONLY : PREFVAL
USE MOD_GRAPH_PAR, ONLY : AXESOBJ,GRAPHUNITS,GRAPHAREA

CONTAINS

 !###======================================================================
 SUBROUTINE PROFILE_BACKGROUND_BITMAP_READ()
 !###======================================================================
 IMPLICIT NONE
 INTEGER :: IW,IH,I
 
 IF(PBITMAP%IBITMAP.GT.0)THEN; CALL WBITMAPDESTROY(PBITMAP%IBITMAP); PBITMAP%IBITMAP=0; ENDIF

 IW=0; IH=0
 DO I=1,SIZE(IWINPROFILE)
  IW=MAX(IW,WINFOBITMAP(IBITMAP(I),BITMAPWIDTH))
  IH=MAX(IH,WINFOBITMAP(IBITMAP(I),BITMAPHEIGHT))
 ENDDO
 
 CALL WBITMAPCREATE(PBITMAP%IBITMAP,IW,IH)
 PBITMAP%IW=IW; PBITMAP%IH=IH
 CALL WBITMAPSTRETCHMODE(STRETCHHALFTONE)
 CALL WBITMAPLOAD(PBITMAP%IBITMAP,PBITMAP%FNAME,1)
 
 PBITMAP%IACT=1
 
 END SUBROUTINE PROFILE_BACKGROUND_BITMAP_READ

 !###====================================================================
 SUBROUTINE PROFILE_PUTBITMAP(IBITMAP2D)
 !###====================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IBITMAP2D
 REAL :: R1,R2,F
 INTEGER :: IW,IH

 CALL WDIALOGSELECT(ID_DSERIESTAB1)
 CALL IGRSELECT(DRAWFIELD,IDF_PICTURE1)

 IW=WINFODIALOGFIELD(IDF_PICTURE1,FIELDWIDTH)
 IH=WINFODIALOGFIELD(IDF_PICTURE1,FIELDHEIGHT)

 R1=REAL(IW)/REAL(IH)
 R2=REAL(MPW%DIX)/REAL(MPW%DIY)

 AREA(1)=0.0
 AREA(2)=0.0
 AREA(3)=1.0
 AREA(4)=1.0

 !## bitmap is wider than window - adjust y
 IF(R2.GT.R1)THEN
  F      = REAL(MPW%DIY)/(REAL(MPW%DIX)/REAL(IW))
  F      = F/REAL(IH)
  F      =(1.0-F)/2.0
  AREA(2)= F       !ymin
  AREA(4)= 1.0-F   !ymax
 !## bitmap is smaller than window - adjust x
 ELSE
  F      = REAL(MPW%DIX)/(REAL(MPW%DIY)/REAL(IH))
  F      = F/REAL(IW)
  F      =(1.0-F)/2.0
  AREA(1)= F       !xmin
  AREA(3)= 1.0-F   !xmax
 ENDIF

 !## plot/update survey crosssection
 CALL PROFILE_PLOTSURVEY(.FALSE.)

 CALL WDIALOGSELECT(ID_DSERIESTAB1)
 CALL IGRSELECT(DRAWFIELD,IDF_PICTURE1)
 CALL IGRAREA(AREA(1),AREA(2),AREA(3),AREA(4))
 CALL WBITMAPPUT(IBITMAP2D,2,1)
 CALL IGRUNITS(MPW%XMIN,MPW%YMIN,MPW%XMAX,MPW%YMAX)

 END SUBROUTINE PROFILE_PUTBITMAP

 !###======================================================================
 SUBROUTINE PROFILE_PLOTSURVEY(LPS)
 !###======================================================================
 IMPLICIT NONE
 LOGICAL ,INTENT(IN) :: LPS
 REAL :: XP1,XP2,YP1,YP2,SX_RATIO,SXYRATIO,BITMAPRATIO
 REAL :: XMARGE,DXMARGE,YMARGE,DX,DY,XA1,XA2,YA1,YA2,XU1,XU2,YU1,YU2
 INTEGER :: IWD,IHD,IWS,ISURVEY,IWINID,ILOC,ISIZE
 CHARACTER(LEN=256) :: FNAME

 !## store previous settings
 XA1=WINFOGRREAL(GRAPHICSAREAMINX); XA2=WINFOGRREAL(GRAPHICSAREAMAXX)
 YA1=WINFOGRREAL(GRAPHICSAREAMINY); YA2=WINFOGRREAL(GRAPHICSAREAMAXY)
 XU1=WINFOGRREAL(GRAPHICSUNITMINX); XU2=WINFOGRREAL(GRAPHICSUNITMAXX)
 YU1=WINFOGRREAL(GRAPHICSUNITMINY); YU2=WINFOGRREAL(GRAPHICSUNITMAXY)

 CALL WDIALOGSELECT(ID_DSERIESPROPTAB3)
 CALL WDIALOGGETCHECKBOX(IDF_CHECK5,ISURVEY)
 IF(ISURVEY.EQ.0)RETURN
 
 CALL WDIALOGGETRADIOBUTTON(IDF_RADIO1,ILOC)
 CALL WDIALOGGETRADIOBUTTON(IDF_RADIO5,ISIZE)

 !## nothing drawn yet, 
 IF(.NOT.ALLOCATED(IWINPROFILE))RETURN
 
 CALL IGRSELECT(DRAWBITMAP,MPW%IBITMAP)
 IWD=WINFODRAWABLE(DRAWABLEWIDTH)
 IHD=WINFODRAWABLE(DRAWABLEHEIGHT)
 BITMAPRATIO=REAL(IHD)/REAL(IWD)

 DO IWINID=1,SIZE(IWINPROFILE)
  CALL IGRSELECT(DRAWWIN,IWINPROFILE(IWINID))
  !## drawable settings
  IWD=WINFODRAWABLE(DRAWABLEWIDTH)
  IHD=WINFODRAWABLE(DRAWABLEHEIGHT)
  !## screen setting
  IWS=WINFOSCREEN(SCREENWIDTH)
  !## ratio's
  SX_RATIO=REAL(IWS)/REAL(IWD)
  SXYRATIO=REAL(IWD)/REAL(IHD)

  CALL IGRSELECT(DRAWBITMAP,IBITMAP(IWINID))

  SELECT CASE (ISIZE)
   CASE (1); DXMARGE=0.35 !## large
   CASE (2); DXMARGE=0.25 !## medium
   CASE (3); DXMARGE=0.15 !## small
  END SELECT
 
  SELECT CASE (ILOC)
   CASE (1); XMARGE=0.975       ; YMARGE=0.90         !## br
   CASE (2); XMARGE=0.975       ; YMARGE=DXMARGE+0.05 !## tr
   CASE (3); XMARGE=DXMARGE+0.05; YMARGE=0.90         !## bl
   CASE (4); XMARGE=DXMARGE+0.05; YMARGE=DXMARGE+0.05 !## tl
  END SELECT

  XP2=XMARGE
  XP1=XP2-(DXMARGE*SX_RATIO)
  YP1=(1.0-YMARGE)*SXYRATIO*BITMAPRATIO
  YP2=(1.0-(YMARGE-DXMARGE*SX_RATIO))*SXYRATIO*BITMAPRATIO

  DX=(XP2-XP1)/50.0
  DY=(YP2-YP1)/50.0*SXYRATIO

  CALL IGRPLOTMODE(MODECOPY)

  CALL IGRAREA(XP1,YP1,XP2,YP2)
  CALL IGRUNITS(0.0,0.0,1.0,1.0)
  CALL IGRFILLPATTERN(SOLID)
  CALL IGRCOLOURN(WRGB(255,255,255))
  CALL IGRRECTANGLE(0.0,0.0,1.0,1.0)
  CALL IGRFILLPATTERN(OUTLINE)
  CALL IGRCOLOURN(WRGB(0,0,0))
  CALL IGRRECTANGLE(0.0,0.0,1.0,1.0)
  CALL IGRAREA(XP1+DX,YP1+DY,XP2-DX,YP2-DY)

  CALL WBITMAPPUT(MPW%IBITMAP,2,1)

  IF(LPS)THEN
   FNAME=TRIM(PREFVAL(1))//'\tmp\tmp.bmp'
   CALL WBITMAPSAVE(MPW%IBITMAP,FNAME)
   CALL IGRLOADIMAGE(FNAME)
  ENDIF
  
  CALL IGRSELECT(DRAWWIN,IWINPROFILE(IWINID))
  CALL WBITMAPPUT(IBITMAP(IWINID),0,1)  
 
 ENDDO
 
 CALL IGRAREA(XA1,YA1,XA2,YA2)
 CALL IGRUNITS(XU1,YU1,XU2,YU2)
 
 IF(LPS)CALL IOSDELETEFILE(FNAME)
 
 END SUBROUTINE PROFILE_PLOTSURVEY

 !###====================================================================
 SUBROUTINE PROFILE_EXTENT_2DBITMAP()
 !###====================================================================
 IMPLICIT NONE

 !## inside bitmap area=0.0,0.0,1.0,1.0
 CALL IGRSELECT(DRAWBITMAP,MPW%IBITMAP)
 CALL IGRAREA(0.0,0.0,1.0,1.0)
 CALL IGRUNITS(MPW%XMIN,MPW%YMIN,MPW%XMAX,MPW%YMAX)
 CALL IGRCOLOURN(WRGB(255,255,255))
 CALL IGRPLOTMODE(MODEXOR)
 CALL IGRLINETYPE(SOLIDLINE)

 END SUBROUTINE PROFILE_EXTENT_2DBITMAP

 !###====================================================================
 SUBROUTINE PROFILE_EXTENT_GRAPH(IWINID)
 !###====================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IWINID
 
 CALL WINDOWSELECT(IWINPROFILE(IWINID))
 CALL IGRSELECT(DRAWWIN,IWINPROFILE(IWINID))
 CALL IGRAREA( GRAPHAREA(1,1) ,GRAPHAREA(2,1) ,GRAPHAREA(3,1) ,GRAPHAREA(4,1))
 CALL IGRUNITS(GRAPHUNITS(1,1),GRAPHUNITS(2,1),GRAPHUNITS(3,1),GRAPHUNITS(4,1))
 
 END SUBROUTINE PROFILE_EXTENT_GRAPH

 !###====================================================================
 SUBROUTINE PROFILE_PLOTLOCATION(LINEWIDTHPLOT)
 !###====================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: LINEWIDTHPLOT
 REAL :: X,Y,RADIUS

 IF(XPOS.EQ.0.0)RETURN

 RADIUS=SQRT((MPW%XMAX-MPW%XMIN)**2.0+(MPW%YMAX-MPW%YMIN)**2.0)/100.0
 IF(PROFILE_GETLOCATION(X,Y,XPOS))THEN
  CALL IGRFILLPATTERN(OUTLINE)
  CALL IGRLINEWIDTH(LINEWIDTHPLOT)
  CALL IGRCIRCLE(X,Y,RADIUS)
  CALL IGRLINEWIDTH(1)
 ENDIF
 
 END SUBROUTINE PROFILE_PLOTLOCATION

 !###====================================================================
 LOGICAL FUNCTION PROFILE_GETLOCATION(X,Y,XP,ISEG)
 !###====================================================================
 !##
 !## based upon the value of xpos, return x,y coordinates
 !##
 IMPLICIT NONE
 REAL,INTENT(IN) :: XP
 REAL,INTENT(OUT) :: X,Y
 INTEGER,INTENT(OUT),OPTIONAL :: ISEG
 REAL :: D,TD,RATIO
 INTEGER :: I

 PROFILE_GETLOCATION=.FALSE.

 TD=0.0
 DO I=2,NXY
  D =SQRT((XY(1,I)-XY(1,I-1))**2.0+(XY(2,I)-XY(2,I-1))**2.0)
  TD=TD+D
  !## inside current segment
  IF(TD.GE.XP)THEN
   RATIO=(D-(TD-XP))/D
   IF(RATIO.GT.0.0)THEN
    X=XY(1,I-1)+RATIO*(XY(1,I)-XY(1,I-1))
    Y=XY(2,I-1)+RATIO*(XY(2,I)-XY(2,I-1))
   ELSE
    X=XY(1,I-1)
    Y=XY(2,I-1)
   ENDIF
   PROFILE_GETLOCATION=.TRUE.
   IF(PRESENT(ISEG))ISEG=I; EXIT
  ENDIF
 END DO

 END FUNCTION PROFILE_GETLOCATION

END MODULE MOD_PROFILE_UTL
