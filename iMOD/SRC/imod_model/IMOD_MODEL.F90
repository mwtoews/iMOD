!!  Copyright (C) Stichting Deltares, 2005-2019.
!!
!!  This file is part of iMOD.
!!
!!  This program is free software: you can redistribute it and/or modify
!!  it under the terms of the GNU General Public License as published by
!!  the Free Software Foundation, either version 3 of the License, or
!!  (at your option) any later version.
!!
!!  This program is distributed in the hope that it will be useful,
!!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!  GNU General Public License for more details.
!!
!!  You should have received a copy of the GNU General Public License
!!  along with this program.  If not, see <http://www.gnu.org/licenses/>.
!!
!!  Contact: imod.support@deltares.nl
!!  Stichting Deltares
!!  P.O. Box 177
!!  2600 MH Delft, The Netherlands.
!!
MODULE MOD_MODEL

USE WINTERACTER
USE RESOURCE
USE MOD_IDFPLOT
USE IMODVAR, ONLY : DP_KIND,SP_KIND,IDIAGERROR,REPLACESTRING
USE MODPLOT
USE MOD_COLOURS
USE MOD_PREF_PAR, ONLY : PREFVAL
USE MOD_MODEL_PAR
USE MOD_MODEL_UTL
USE MOD_UTL
USE MOD_IDF
USE MOD_IDF_PAR, ONLY : IDFOBJ
USE MOD_OSD, ONLY : OSD_OPEN,OSD_IOSTAT_MSG
USE MOD_IPF_PAR, ONLY : NIPF,IPF
USE MOD_IPF, ONLY : IPFALLOCATE,IPFREAD2,IPFWRITE
USE MOD_PMANAGER_UTL, ONLY: PMANAGER_UTL_SHOW,UTL_PMANAGER_REFRESH
USE MOD_PMANAGER, ONLY: PMANAGERRUN,PMANAGERSTART
USE MOD_PMANAGER_PAR, ONLY: PBMAN
USE MOD_ABOUT, ONLY : IMOD_AGREEMENT
USE MOD_MAIN_UTL

INTEGER,PRIVATE :: IEDGE

CHARACTER(LEN=4),DIMENSION(5),PRIVATE :: EXT
DATA EXT/'.IDF','.IPF','.GEN','.ISG','INP'/

CONTAINS
 
 !###======================================================================
 SUBROUTINE MODEL1MAIN(ITYPE,MESSAGE)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: ITYPE
 TYPE(WIN_MESSAGE),INTENT(IN) :: MESSAGE
 CHARACTER(LEN=20) :: LINE
 INTEGER :: IWIN,I
 LOGICAL :: LEX
 CHARACTER(LEN=256) :: FNAME
 
 SELECT CASE (ITYPE)

  CASE (FIELDCHANGED)
   SELECT CASE (MESSAGE%WIN)
    !## main
    CASE (ID_DMDLTAB1)
     SELECT CASE (MESSAGE%VALUE2)
      !## select new runfile
      CASE (IDF_MENU1)
       CALL MODEL1DRAW_SIMBOX() !## remove previous one
       CALL WDIALOGSELECT(ID_DMDLTAB1)
       IF(UTL_PMANAGER_REFRESH(0))THEN
        SIMBOX=0.0D0
        LEX=MODEL1RUNFILE(); CALL MODEL1TABSTATES(LEX,.TRUE.)
        IF(LEX)THEN
         CALL WINDOWSELECT(0); CALL WMENUSETSTATE(ID_RUNMODEL,2,0)
         CALL IDFZOOM(ID_DMODEL,0.0D0,0.0D0,0); CALL IDFPLOTFAST(1)
         CALL WINDOWSELECT(0); CALL WMENUSETSTATE(ID_RUNMODEL,2,1)
         CALL MODEL1DRAW_SIMBOX() !## draw new one
        ENDIF
       ENDIF
     END SELECT
    !## configuration
    CASE (ID_DMDLTAB2)
     SELECT CASE (MESSAGE%VALUE2)
      !## type of network
      CASE (IDF_RADIO1,IDF_RADIO2)
       CALL MODEL1DRAW_SIMBOX()
       CALL MODEL1GETSIMBOX()
       CALL MODEL1FIELDS()
       CALL MODEL1DRAW_SIMBOX()
      !## nlay
      CASE (IDF_MENU3)
       CALL MODEL1GETSIMBOX()
       !## reset nlayers to be saved!
       NLMDL=0
       CALL MODEL1FILLSAVINGS()
      !## coordinates
      CASE (IDF_REAL1,IDF_REAL2,IDF_REAL4,IDF_REAL5,IDF_REAL7,IDF_REAL8,IDF_REAL9)
       CALL MODEL1DRAW_SIMBOX()
       CALL MODEL1GETSIMBOX()
       CALL MODEL1FIELDS()
       CALL MODEL1DRAW_SIMBOX()
      !## cellsize
      CASE (IDF_MENU1)
       CALL WDIALOGSELECT(ID_DMDLTAB2)
       CALL WDIALOGGETMENU(IDF_MENU1,I,LINE)
       READ(LINE,*) SIMCSIZE
       CALL WDIALOGPUTDOUBLE(IDF_REAL7,SIMCSIZE)
       CALL MODEL1GETSIMBOX()
      !## maxcellsize
      CASE (IDF_MENU4)
       CALL WDIALOGSELECT(ID_DMDLTAB2)
       CALL WDIALOGGETMENU(IDF_MENU4,I,LINE)
       READ(LINE,*) MAXSIMCSIZE
       CALL WDIALOGPUTDOUBLE(IDF_REAL9,MAXSIMCSIZE)
       CALL MODEL1GETSIMBOX()
      !## buffer size
      CASE (IDF_MENU2)
       CALL MODEL1DRAW_SIMBOX()
       CALL WDIALOGSELECT(ID_DMDLTAB2)
       CALL WDIALOGGETMENU(IDF_MENU2,I,LINE)
       READ(LINE,*) MDLBUFFER
       CALL WDIALOGPUTDOUBLE(IDF_REAL8,MDLBUFFER)
       CALL MODEL1GETSIMBOX()
       CALL MODEL1DRAW_SIMBOX()
      !## usage of maxsimcsize
      CASE (IDF_CHECK1)
       CALL MODEL1GETSIMBOX()
       CALL MODEL1FIELDS()
     END SELECT

    !## savings
    CASE (ID_DMDLTAB3)
     SELECT CASE (MESSAGE%VALUE2)
      !## fill savings
      CASE (IDF_MENU1)
       CALL MODEL1FILLSAVINGS()
      !## read savings
      CASE (IDF_MENU2)
       CALL MODEL1GETSAVINGS()
     END SELECT

    !## output directory
    CASE (ID_DMDLTAB4)
     SELECT CASE (MESSAGE%VALUE2)
     END SELECT

    !## set solver settings
    CASE (ID_DMDLTAB6)
     SELECT CASE (MESSAGE%VALUE2)
      CASE (IDF_MENU2,IDF_MENU3)
       CALL MODEL1FIELDS()   
     END SELECT
    END SELECT

  CASE(PUSHBUTTON)
   SELECT CASE (MESSAGE%WIN)

    !## runfile tab
    CASE (ID_DMODEL)
     SELECT CASE (MESSAGE%VALUE1)
      !## help
      CASE (IDHELP)
       CALL UTL_GETHELP('5.7','TMO.ModSim')
      !## cancel modeling
      CASE (IDCANCEL)
       CALL MODEL1CLOSE()
       CALL IDFPLOT(1)
     END SELECT

    !## runfile tab
    CASE (ID_DMDLTAB1)
     SELECT CASE (MESSAGE%VALUE1)
      !## open runfile in projectmanager
      CASE (ID_PRJMANAGER)
       CALL WDIALOGSELECT(ID_DMDLTAB1)
       CALL WDIALOGGETMENU(IDF_MENU1,I,FNAME)
       FNAME=TRIM(PREFVAL(1))//'\RUNFILES\'//TRIM(FNAME)
       IF(UTL_PMANAGER_REFRESH(1))THEN; IF(PMANAGERRUN(ID_OPENRUN,FNAME,0))CALL PMANAGER_UTL_SHOW(1); ENDIF
      !## copy runfile
      CASE (ID_COPY)
       CALL MODEL1COPYRUNFILE(0)
      !## show run-file
      CASE (ID_INFO1)
       CALL WDIALOGSELECT(ID_DMDLTAB1)
       CALL WDIALOGGETMENU(IDF_MENU1,I,FNAME)
       CALL WINDOWOPENCHILD(IWIN,FLAGS=SYSMENUON+MAXBUTTON,WIDTH=1000,HEIGHT=500)
       CALL WINDOWSELECT(IWIN)
       FNAME=TRIM(PREFVAL(1))//'\RUNFILES\'//TRIM(FNAME)
       CALL WEDITFILE(FNAME,ITYPE=MODAL,IDMENU=0,IFONT=COURIERNEW,ISIZE=10)
!       IF(MODEL1FILL_RUNFILES())THEN
!       CALL MODEL1TABSTATES(MODEL1RUNFILE(),.TRUE.)
!       CALL MODEL1DRAW_SIMBOX() !## draw new one
!       CALL WDIALOGPUTOPTION(IDF_MENU1,I)
!       ENDIF
      !## check runfile
      CASE (ID_CHECKRUNFILE)
       CALL WDIALOGSELECT(ID_DMDLTAB1)
       CALL WDIALOGGETMENU(IDF_MENU1,I,FNAME)
       CALL MODEL1CHECKRUNFILE(TRIM(PREFVAL(1))//'\RUNFILES\'//TRIM(FNAME))
      CASE (ID_ZOOMFULL)
       CALL IDFZOOM(ID_DMODEL,0.0D0,0.0D0,0); CALL IDFPLOTFAST(1)
     END SELECT

    !## dimension tab
    CASE (ID_DMDLTAB2)
     SELECT CASE (MESSAGE%VALUE1)
      !## draw area of interest
      CASE (ID_DRAW)
       CALL MODEL1DEFINEBOX()
      CASE (ID_OPEN)
       FNAME=''
       IF(UTL_WSELECTFILE('iMOD IDF-File (*.idf)|*.idf|',LOADDIALOG+PROMPTON+DIRCHANGE+MUSTEXIST, &
                     FNAME,'Select IDF File (*.idf)'))THEN
        BNDFNAME=FNAME
        CALL WDIALOGSELECT(ID_DMDLTAB2)
        CALL WDIALOGPUTSTRING(IDF_STRING1,FNAME)
       ENDIF
     END SELECT

    !## runfile tab
    CASE (ID_DMDLTAB4)
     SELECT CASE (MESSAGE%VALUE1)
      !## start modflow
       CASE (IDOK)
       CALL MODEL1STARTMAIN()
      END SELECT

     !## solver settings tab
    CASE (ID_DMDLTAB6)
     SELECT CASE (MESSAGE%VALUE1)
      !## draw area of interest
      CASE (ID_OPEN)
       FNAME=''
       IF(UTL_WSELECTFILE('iMOD IDF-File (*.idf)|*.idf|',LOADDIALOG+PROMPTON+DIRCHANGE+MUSTEXIST, &
                     FNAME,'Select IDF File (*.idf)'))THEN
        CALL WDIALOGSELECT(ID_DMDLTAB6)
        CALL WDIALOGPUTSTRING(IDF_STRING1,FNAME)
       ENDIF
       MRGFNAME=FNAME
     END SELECT   
      
   END SELECT

 END SELECT

 END SUBROUTINE MODEL1MAIN

 !###======================================================================
 LOGICAL FUNCTION MODEL1FILL_RUNFILES()
 !###======================================================================
 IMPLICIT NONE

 MODEL1FILL_RUNFILES=.FALSE.

 !## fill runfiles
 CALL WDIALOGSELECT(ID_DMDLTAB1)
 CALL UTL_IMODFILLMENU(IDF_MENU1,TRIM(PREFVAL(1))//'\RUNFILES','*.RUN','F',NRUNFILES,0,0)
 IF(NRUNFILES.LE.0)THEN
  CALL MODEL1CLOSE()
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'No runfiles (*.run) found in folder'//CHAR(13)// &
   TRIM(PREFVAL(1))//'\RUNFILES'//CHAR(13)//'Without any runfile(s) it is not possible to use the Model Tool!','Warning')
  RETURN
 ENDIF

 MODEL1FILL_RUNFILES=.TRUE.

 END FUNCTION MODEL1FILL_RUNFILES

 !###======================================================================
 SUBROUTINE MODEL1INIT()
 !###======================================================================
 IMPLICIT NONE
 INTEGER :: I
 CHARACTER,ALLOCATABLE,DIMENSION(:) :: COPTS
 
 CALL WINDOWSELECT(0)
 IF(WMENUGETSTATE(ID_RUNMODEL,2).EQ.1)THEN
  CALL MODEL1CLOSE(); RETURN
 ENDIF

 CALL MAIN_UTL_INACTMODULE(ID_RUNMODEL)

 !## other module no closed, no approvement given
 IF(IDIAGERROR.EQ.1)RETURN

 CALL WDIALOGLOAD(ID_DMODEL,ID_DMODEL)

! IF(TRIM(PREFVAL(8)).EQ.'')THEN
!  CALL MODEL1CLOSE()
!  CALL WMESSAGEBOX(OKONLY,COMMONOK,EXCLAMATIONICON,'Give MODFLOW executable in *.prf-file'//CHAR(13)//CHAR(13)// &
!     'e.g. MODFLOW c:\modflow\imodflow.exe','Error')
!  RETURN
! ENDIF

 CALL WMENUSETSTATE(ID_RUNMODEL,2,1)

 IF(.NOT.IOSDIREXISTS(TRIM(PREFVAL(1))//'\MODELS'))CALL UTL_CREATEDIR(TRIM(PREFVAL(1))//'\MODELS')

 CALL WDIALOGSELECT(ID_DMDLTAB1)
 CALL WDIALOGPUTIMAGE(ID_CHECKRUNFILE,ID_ICONOKAY)
 CALL WDIALOGPUTIMAGE(ID_INFO1,ID_ICONINFO)
 CALL WDIALOGPUTIMAGE(ID_COPY,ID_ICONCOPY)
 CALL WDIALOGPUTIMAGE(ID_PRJMANAGER,ID_ICONOPENRUN)
 CALL WDIALOGPUTIMAGE(ID_ZOOMFULL,ID_ICONZOOMFULL)

 CALL WDIALOGSELECT(ID_DMDLTAB2)
 CALL WDIALOGFIELDOPTIONS(IDF_REAL1,EDITFIELDCHANGED,ENABLED)
 CALL WDIALOGFIELDOPTIONS(IDF_REAL2,EDITFIELDCHANGED,ENABLED)
 CALL WDIALOGFIELDOPTIONS(IDF_REAL4,EDITFIELDCHANGED,ENABLED)
 CALL WDIALOGFIELDOPTIONS(IDF_REAL5,EDITFIELDCHANGED,ENABLED)
 CALL WDIALOGFIELDOPTIONS(IDF_REAL7,EDITFIELDCHANGED,ENABLED)
 CALL WDIALOGFIELDOPTIONS(IDF_REAL8,EDITFIELDCHANGED,ENABLED)
 CALL WDIALOGFIELDOPTIONS(IDF_REAL9,EDITFIELDCHANGED,ENABLED)
 CALL WDIALOGFIELDSTATE(IDF_REAL3,2)
 CALL WDIALOGFIELDSTATE(IDF_REAL6,2)
 CALL WDIALOGPUTIMAGE(ID_OPEN,ID_ICONOPENIDF)
 CALL WDIALOGPUTCHECKBOX(IDF_CHECK2,0)
 
 CALL WDIALOGSELECT(ID_DMDLTAB6)
 CALL WDIALOGPUTIMAGE(ID_OPEN,ID_ICONOPENIDF)
 CALL WDIALOGFIELDSTATE(IDF_INTEGER3,DISABLED)
 CALL WDIALOGFIELDSTATE(IDF_CHECK1,DISABLED)
 CALL WDIALOGFIELDSTATE(IDF_LABEL10,DISABLED)
 
 NRUNFILES =0
 NRESULTDIR=0
 IDRAW     =0
 
 IF(.NOT.MODEL1FILL_RUNFILES())RETURN

 !## fill result-folders
 CALL MODEL1FILL_RESULTS()

 CALL UTL_SYSCOREINFO(NMAXCORES)
 ALLOCATE(COPTS(NMAXCORES))
 DO I=1,NMAXCORES; COPTS(I)=ITOS(I); ENDDO 
 CALL WDIALOGSELECT(ID_DMDLTAB6); CALL WDIALOGPUTMENU(IDF_MENU3,COPTS,NMAXCORES,1)
 DEALLOCATE(COPTS)
 
 CALL WDIALOGSELECT(ID_DMODEL)
 CALL WDIALOGSHOW(-1,-1,0,2)

 !## read selected runfile and adjust and fill in tab-fields/settings
 CALL MODEL1TABSTATES(MODEL1RUNFILE(),.TRUE.)
 CALL MODEL1DRAW_SIMBOX() !## draw new one
 
 END SUBROUTINE MODEL1INIT
 
 !###======================================================================
 LOGICAL FUNCTION MODEL1MOUSEMOVE(MOUSEX,MOUSEY,IDOWN,DOWNX,DOWNY)
 !###======================================================================
 IMPLICIT NONE
 REAL(KIND=DP_KIND),INTENT(IN) :: MOUSEX,MOUSEY
 INTEGER,INTENT(IN) :: IDOWN
 REAL(KIND=DP_KIND),INTENT(INOUT) :: DOWNX,DOWNY
 REAL(KIND=DP_KIND) :: MIND,DX,DY
 INTEGER,DIMENSION(0:5) :: IDCURSOR
 DATA IDCURSOR/CURARROW,ID_CURSORMOVELEFTRIGHT,ID_CURSORMOVEUPDOWN,ID_CURSORMOVELEFTRIGHT, &
               ID_CURSORMOVEUPDOWN,ID_CURSORMOVE/

 MODEL1MOUSEMOVE=.FALSE.

 IF(SIMBOX(3)-SIMBOX(1).EQ.0.0D0.OR. &
    SIMBOX(4)-SIMBOX(2).EQ.0.0D0)RETURN

 MIND=(MPW%XMAX-MPW%XMIN)/500.0D0
    
 SELECT CASE (IDOWN)
  !## no mouse button pressed, see in what neighbourhood
  CASE (0)
   IEDGE=0
   IF(ABS(MOUSEX-SIMBOX(1)).LE.MIND)IEDGE=1 !## west
   IF(ABS(MOUSEY-SIMBOX(2)).LE.MIND)IEDGE=2 !## south
   IF(ABS(MOUSEX-SIMBOX(3)).LE.MIND)IEDGE=3 !## east
   IF(ABS(MOUSEY-SIMBOX(4)).LE.MIND)IEDGE=4 !## north
   IF(IEDGE.EQ.0)THEN
    IF(MOUSEX.GT.SIMBOX(1).AND.MOUSEX.LT.SIMBOX(3).AND. &
       MOUSEY.GT.SIMBOX(2).AND.MOUSEY.LT.SIMBOX(4))IEDGE=5 !## inside
   ENDIF
   IF(WINFOMOUSE(MOUSECURSOR).NE.IDCURSOR(IEDGE))CALL WCURSORSHAPE(IDCURSOR(IEDGE))

  !## left mouse button pressed
  CASE (4)
   
   IF(IEDGE.GT.0)THEN
    !## change only whenever inside rectangle
    IF(MOUSEX.GE.MODBOX(1).AND.MOUSEX.LE.MODBOX(3).AND. &
       MOUSEY.GE.MODBOX(2).AND.MOUSEY.LE.MODBOX(4))THEN
     CALL MODEL1DRAW_SIMBOX() !## remove previous one
     DX=MOUSEX-DOWNX
     DY=MOUSEY-DOWNY
     SELECT CASE (IEDGE)
      CASE (1)
       SIMBOX(IEDGE)=MIN(SIMBOX(3),SIMBOX(IEDGE)+DX) 
      CASE (3)
       SIMBOX(IEDGE)=MAX(SIMBOX(1),SIMBOX(IEDGE)+DX) 
      CASE (2)
       SIMBOX(IEDGE)=MIN(SIMBOX(4),SIMBOX(IEDGE)+DY) 
      CASE (4)
       SIMBOX(IEDGE)=MAX(SIMBOX(2),SIMBOX(IEDGE)+DY) 
      CASE (5)
       SIMBOX(1)=MAX(MODBOX(1),SIMBOX(1)+DX)
       SIMBOX(2)=MAX(MODBOX(2),SIMBOX(2)+DY)
       SIMBOX(3)=MIN(MODBOX(3),SIMBOX(3)+DX)
       SIMBOX(4)=MIN(MODBOX(4),SIMBOX(4)+DY)
     END SELECT
     CALL MODEL1PUTSIMBOX(SIMBOX(1),SIMBOX(2),SIMBOX(3),SIMBOX(4))
     CALL MODEL1GETSIMBOX()
     CALL MODEL1FIELDS()
     CALL MODEL1DRAW_SIMBOX() !## draw new one
     DOWNX=DOWNX+DX
     DOWNY=DOWNY+DY
    ENDIF
   ENDIF

 END SELECT
 
 MODEL1MOUSEMOVE=.TRUE.

 END FUNCTION MODEL1MOUSEMOVE

 !###======================================================================
 SUBROUTINE MODEL1FIELDS()
 !###======================================================================
 IMPLICIT NONE
 INTEGER,PARAMETER :: NID=23
 INTEGER,DIMENSION(NID) :: ID
 INTEGER :: I,J,K
 REAL(KIND=DP_KIND) :: X1,Y1,X2,Y2,DX,DY
 DATA ID/IDF_GROUP3,IDF_LABEL3,IDF_LABEL9,IDF_LABEL13,IDF_LABEL14,IDF_LABEL15,    &
         IDF_MENU1,IDF_MENU2,IDF_MENU4,IDF_REAL7,IDF_REAL8,IDF_REAL9,  &
         IDF_LABEL5,IDF_LABEL7,IDF_REAL1,IDF_REAL2,IDF_REAL3,IDF_REAL4,&
         IDF_REAL5,IDF_REAL6,IDF_LABEL16,IDF_LABEL17,ID_DRAW/

 CALL WDIALOGSELECT(ID_DMDLTAB2)
 CALL WDIALOGGETRADIOBUTTON(IDF_RADIO1,J)
 !## put dimensions of idf file
 IF(J.EQ.2)CALL MODEL1PUTSIMBOX(IDF%XMIN,IDF%YMIN,IDF%XMAX,IDF%YMAX)

 J=ABS(J-2)
 DO I=1,NID
  CALL WDIALOGFIELDSTATE(ID(I),J)
 END DO
 J=ABS(J-1)
 CALL WDIALOGFIELDSTATE(IDF_STRING1,J)
 CALL WDIALOGFIELDSTATE(ID_OPEN,J)

 CALL WDIALOGGETCHECKBOX(IDF_CHECK1,I)
 CALL WDIALOGFIELDSTATE(IDF_MENU4,I)
 CALL WDIALOGFIELDSTATE(IDF_REAL9,I)
 CALL WDIALOGFIELDSTATE(IDF_LABEL15,I)

 CALL WDIALOGGETDOUBLE(IDF_REAL1,X1)
 CALL WDIALOGGETDOUBLE(IDF_REAL4,Y1)
 CALL WDIALOGGETDOUBLE(IDF_REAL2,X2)
 CALL WDIALOGGETDOUBLE(IDF_REAL5,Y2)
 DX=X2-X1
 DY=Y2-Y1
 CALL WDIALOGPUTDOUBLE(IDF_REAL3,DX)
 CALL WDIALOGPUTDOUBLE(IDF_REAL6,DY)

 CALL WDIALOGSELECT(ID_DMODEL)
 
 !## control enabling of load pointer IDF-file
 CALL WDIALOGSELECT(ID_DMDLTAB6)
 
 !## get amount of cores to be used in modelsimulation, selected by user
 CALL WDIALOGGETMENU(IDF_MENU3,NCORES)
 J=0; IF(NCORES.NE.1)J=1
 IF(J.EQ.1)THEN
 !## enable partitioning option + subdomain merge option + disable precondition option
  CALL WDIALOGFIELDSTATE(IDF_LABEL16,J)
  CALL WDIALOGFIELDSTATE(IDF_MENU2,J)
  CALL WDIALOGGETMENU(IDF_MENU2,I)
  CALL WDIALOGFIELDSTATE(IDF_LABEL11,J-1)
  CALL WDIALOGFIELDSTATE(IDF_MENU1,J-1)
  CALL WDIALOGFIELDSTATE(IDF_LABEL6,J-1)
  CALL WDIALOGFIELDSTATE(IDF_REAL4,J-1)
  K=0; IF(I.EQ.2)K=1
  CALL WDIALOGFIELDSTATE(IDF_STRING1,K)
  CALL WDIALOGFIELDSTATE(ID_OPEN,K)
  CALL WDIALOGFIELDSTATE(IDF_LABEL17,K)
  K=0; IF(I.EQ.1.OR.I.EQ.2)K=1
  CALL WDIALOGFIELDSTATE(IDF_CHECK2,K)
  CALL WDIALOGGETSTRING(IDF_STRING1,MRGFNAME)
 ELSE
 !## amount of selected cores is equal to 1; 
 !## parallel simulation is not possible --> all options disabled
 !## enable precondition option
  CALL WDIALOGFIELDSTATE(IDF_LABEL16,J)
  CALL WDIALOGFIELDSTATE(IDF_MENU2,J)
  CALL WDIALOGPUTOPTION(IDF_MENU2,J+1)
  CALL WDIALOGFIELDSTATE(IDF_STRING1,J)
  CALL WDIALOGFIELDSTATE(ID_OPEN,J)
  CALL WDIALOGFIELDSTATE(IDF_LABEL17,J)
  CALL WDIALOGFIELDSTATE(IDF_CHECK2,J)
  CALL WDIALOGFIELDSTATE(IDF_LABEL11,J+1)
  CALL WDIALOGFIELDSTATE(IDF_MENU1,J+1)
  CALL WDIALOGFIELDSTATE(IDF_LABEL6,J+1)
  CALL WDIALOGFIELDSTATE(IDF_REAL4,J+1)
 ENDIF 
 
 CALL WDIALOGSELECT(ID_DMODEL)
 
 END SUBROUTINE MODEL1FIELDS

 !###======================================================================
 SUBROUTINE MODEL1FILLSAVINGS()
 !###======================================================================
 IMPLICIT NONE
 INTEGER :: I,J
 INTEGER,ALLOCATABLE,DIMENSION(:) :: ILIST
 CHARACTER(LEN=10),DIMENSION(:),ALLOCATABLE :: CLAY

 !## maximum number of layers
 CALL WDIALOGSELECT(ID_DMDLTAB2)
 CALL WDIALOGGETMENU(IDF_MENU3,NLAY)
 IF(NLAY.LE.0)RETURN
  
 !## selected item to be saved
 CALL WDIALOGSELECT(ID_DMDLTAB3)
 CALL WDIALOGGETMENU(IDF_MENU1,I)
 !## error occured in runfile
 IF(I.LE.0)RETURN
 
 I=MDL_IPOS(I)
 
 IF(IAMDL(I).LE.0)THEN
  CALL WDIALOGCLEARFIELD(IDF_MENU2)
  CALL WDIALOGPUTSTRING(IDF_LABEL9,'Not active')
  CALL WDIALOGFIELDSTATE(IDF_MENU2,2)
 ELSE
  !## nlay
  IF(ALLOCATED(CLAY))DEALLOCATE(CLAY)
  ALLOCATE(CLAY(NLAY))
  DO J=1,NLAY; WRITE(CLAY(J),'(I10)') J; END DO
  IF(ALLOCATED(ILIST))DEALLOCATE(ILIST); ALLOCATE(ILIST(NLAY)); ILIST=0
  DO J=1,MIN(NLAY,NLMDL(I))
   IF(ILMDL(I,J).EQ.0)THEN
    ILIST=1
   ELSEIF(ILMDL(I,J).GT.0.AND.ILMDL(I,J).LE.NLAY)THEN
    ILIST(ILMDL(I,J))=1
   ENDIF
  END DO
  CALL WDIALOGPUTSTRING(IDF_LABEL9,'Selected Layers')
  CALL WDIALOGFIELDSTATE(IDF_MENU2,1)
  CALL WDIALOGPUTMENU(IDF_MENU2,CLAY,NLAY,ILIST)
  IF(ALLOCATED(ILIST))DEALLOCATE(ILIST); IF(ALLOCATED(CLAY))DEALLOCATE(CLAY)
 ENDIF

 END SUBROUTINE MODEL1FILLSAVINGS

 !###======================================================================
 SUBROUTINE MODEL1GETSAVINGS()
 !###======================================================================
 IMPLICIT NONE
 INTEGER :: I,J,K
 INTEGER,ALLOCATABLE,DIMENSION(:) :: ILIST

 CALL WDIALOGSELECT(ID_DMDLTAB2)
 CALL WDIALOGGETMENU(IDF_MENU3,NLAY)

 CALL WDIALOGSELECT(ID_DMDLTAB3)
 CALL WDIALOGGETMENU(IDF_MENU1,I)
 I=MDL_IPOS(I)
 
 IF(ALLOCATED(ILIST))DEALLOCATE(ILIST)
 ALLOCATE(ILIST(NLAY))
 ILIST=0
 CALL WDIALOGGETMENU(IDF_MENU2,ILIST)
 NLMDL(I)=0
 K=0
 DO J=1,NLAY
  IF(ILIST(J).EQ.1)THEN
   K=K+1
   NLMDL(I)  =NLMDL(I)+1
   ILMDL(I,K)=J
  ENDIF
 END DO

 IF(ALLOCATED(ILIST))DEALLOCATE(ILIST)

 END SUBROUTINE MODEL1GETSAVINGS

 !###======================================================================
 SUBROUTINE MODEL1STARTMAIN()
 !###======================================================================
 IMPLICIT NONE
 CHARACTER(LEN=20) :: SCENDIR
 INTEGER :: I,ILOGFILE
 CHARACTER(LEN=256) :: RUN1,RUN2,RDIR,LINE
 LOGICAL :: LEX
 
 !## Only supported for modflow2005 RUN file
 PBMAN%IFORMAT=1  

 IF(TRIM(PREFVAL(8)).EQ.'')THEN
  CALL WMESSAGEBOX(OKONLY,COMMONOK,EXCLAMATIONICON,'Give MODFLOW executable in *.prf-file'//CHAR(13)//CHAR(13)// &
     'e.g. MODFLOW c:\modflow\imodflow.exe','Error')
  RETURN
 ENDIF

 CALL WDIALOGSELECT(ID_DMDLTAB1)
 !## runfile to be copied!
 CALL WDIALOGGETMENU(IDF_MENU1,I,RUN1)
 IF(LEN_TRIM(RUN1).EQ.0)THEN
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'No Runfile given!','Error')
  RETURN
 ENDIF
 !## selected runfile
 RUN1=TRIM(PREFVAL(1))//'\RUNFILES\'//TRIM(RUN1)
 INQUIRE(FILE=RUN1,EXIST=LEX)
 IF(.NOT.LEX)THEN
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Runfile '//TRIM(RUN1)//' does not exists!','Error')
  RETURN
 ENDIF

 !## get result-directory
 CALL WDIALOGSELECT(ID_DMDLTAB3)
 CALL WDIALOGGETCHECKBOX(IDF_CHECK1,IBUFFER)
 CALL WDIALOGGETCHECKBOX(IDF_CHECK2,IBUDGET)

 SCENDIR='MODELS'

 !## get result-directory
 CALL WDIALOGSELECT(ID_DMDLTAB4)
 CALL WDIALOGGETMENU(IDF_MENU1,I,RDIR)
 IF(LEN_TRIM(RDIR).EQ.0)THEN
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Enter/select a folder in the Result Folder tab','Error')
  RETURN
 ENDIF

 !## check existence of result folder
 IF(IOSDIREXISTS(TRIM(PREFVAL(1))//'\'//TRIM(SCENDIR)//'\'//TRIM(RDIR)))THEN
  CALL WMESSAGEBOX(YESNO,QUESTIONICON,COMMONYES,'Model Output will be saved in existing folder '//CHAR(13)// &
     TRIM(PREFVAL(1))//'\'//TRIM(SCENDIR)//'\'//TRIM(RDIR)//CHAR(13)//'overwrite it and continue?','Question')
 ELSE
  CALL WMESSAGEBOX(YESNO,QUESTIONICON,COMMONYES,'Model Output will be saved in folder '//CHAR(13)// &
     TRIM(PREFVAL(1))//'\'//TRIM(SCENDIR)//'\'//TRIM(RDIR)//CHAR(13)//'Continue?','Question')
 ENDIF
 IF(WINFODIALOG(4).NE.1)RETURN

 !## open runfile to be created
 RUN2=TRIM(PREFVAL(1))//'\'//TRIM(SCENDIR)//'\'//TRIM(RDIR)

 CALL WDIALOGSELECT(ID_DMDLTAB2)
 CALL WDIALOGGETMENU(IDF_MENU3,I,LINE)
 READ(LINE,*) NLAY

 CALL WDIALOGGETCHECKBOX(IDF_CHECK2,IROUND)

 !## xmin/ymax etc. (1) or idf (2)
 CALL WDIALOGGETRADIOBUTTON(IDF_RADIO1,I)
 IF(I.EQ.1)THEN
  !## get coarsening outside area of interest
  CALL WDIALOGGETCHECKBOX(IDF_CHECK1,NSCL)
  NSCL=NSCL+1 !## 1=equi-dist grid; 2=non-equi grid
  NMULT=1
 ELSE
  NSCL=0
  NMULT=0
 ENDIF

 !## model dimensions
 IF(NMULT.EQ.1)CALL MODEL1GETSIMBOX()

 !## solver
 CALL WDIALOGSELECT(ID_DMDLTAB6)
 CALL WDIALOGGETDOUBLE(IDF_REAL1,HCLOSE)
 CALL WDIALOGGETDOUBLE(IDF_REAL2,RCLOSE)
 CALL WDIALOGGETDOUBLE(IDF_REAL3,RELAX)
 CALL WDIALOGGETINTEGER(IDF_INTEGER1,MXITER)
 CALL WDIALOGGETINTEGER(IDF_INTEGER2,NITER)
 CALL WDIALOGGETDOUBLE(IDF_REAL4,MAXWBAL)
 CALL WDIALOGGETMENU(IDF_MENU1,NPCOND)
 CALL WDIALOGGETDOUBLE(IDF_REAL5,MINKD)
 CALL WDIALOGGETDOUBLE(IDF_REAL6,MINC)
 CALL WDIALOGGETMENU(IDF_MENU2,PARTOPT); PARTOPT=PARTOPT-1
 CALL WDIALOGGETCHECKBOX(IDF_CHECK2,IMERGE)

 CALL WDIALOGSELECT(ID_DMDLTAB3)
 CALL WDIALOGGETCHECKBOX(IDF_CHECK3,IDOUBLE)

 IF(.NOT.MODEL1WRITERUNFILE(RUN1,RUN2,0,0,''))RETURN
 
 CALL WDIALOGSELECT(ID_DMDLTAB4)
 CALL WDIALOGGETCHECKBOX(IDF_CHECK1,I)
 CALL WDIALOGGETCHECKBOX(IDF_CHECK2,ILOGFILE)
 IF(I.EQ.0)I=-1
 !## start runfile
 CALL PMANAGERSTART(TRIM(RUN2)//'\IMODFLOW.RUN',I,0,NCORES,ILOGFILE) 

 END SUBROUTINE MODEL1STARTMAIN

 !###======================================================================
 LOGICAL FUNCTION MODEL1WRITERUNFILE(RUN1,RUN2,ISUB,SIMNPER,INIDATE)
 !###======================================================================
 IMPLICIT NONE
 CHARACTER(LEN=*),INTENT(IN) :: RUN1,RUN2,INIDATE
 INTEGER,INTENT(IN) :: ISUB,SIMNPER
 INTEGER :: IU,JU,KU,IOS,NLAY_ORG,NSCL_ORG,I,J,K,KPER,ISAVE,IPER
 CHARACTER(LEN=256) :: LINE,FNAME
 REAL(KIND=DP_KIND) :: DELT,FCT,IMP,DELTCNVG
 CHARACTER(LEN=50) :: CDATE,FRM
 LOGICAL :: LEX,LDATE

 MODEL1WRITERUNFILE=.FALSE.

 CALL UTL_CREATEDIR(RUN2)

 JU=UTL_GETUNIT()
 CALL OSD_OPEN(JU,FILE=TRIM(RUN2)//'\IMODFLOW.RUN',STATUS='REPLACE',ACTION='WRITE,DENYREAD',IOSTAT=IOS)
 IF(IOS.NE.0)THEN
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Modflow is already running, you cannot start '//CHAR(13)// &
   'new run while previous run is still running','Error')
  RETURN
 ENDIF

 !## open runfile to be copied!
 IU=UTL_GETUNIT(); CALL OSD_OPEN(IU,FILE=RUN1,STATUS='OLD',ACTION='READ,DENYWRITE')

 READ(IU,*)
 READ(RUN2,'(A256)') LINE
 WRITE(JU,'(A)') '"'//TRIM(LINE)//'"'
 READ(IU,'(A256)',IOSTAT=IOS) LINE
 READ(LINE,*,IOSTAT=IOS) NLAY_ORG,MXNLAY,NPER,ISS,NSCL_ORG,IFTEST,ICONCHK,IIPF,IUNCONF,IFVDL,IARMSWP
 IF(IOS.NE.0)THEN
  IARMSWP=0
  READ(LINE,*,IOSTAT=IOS) NLAY_ORG,MXNLAY,NPER,ISS,NSCL_ORG,IFTEST,ICONCHK,IIPF,IUNCONF,IFVDL
  IF(IOS.NE.0)THEN
   IFVDL=0
   READ(LINE,*,IOSTAT=IOS) NLAY_ORG,MXNLAY,NPER,ISS,NSCL_ORG,IFTEST,ICONCHK,IIPF,IUNCONF
   IF(IOS.NE.0)THEN
    IUNCONF=0
    READ(LINE,*,IOSTAT=IOS) NLAY_ORG,MXNLAY,NPER,ISS,NSCL_ORG,IFTEST,ICONCHK,IIPF
   ENDIF
  ENDIF
 ENDIF

 IF(NSCL_ORG.GT.2)THEN 
  CLOSE(IU); CLOSE(JU); CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'You cannot run a simulation with NSCL.GT.2','Error')
  RETURN
 ENDIF

 !## no extra testing
 IFTEST=0
 LINE=TRIM(ITOS(NLAY))//','//TRIM(ITOS(MXNLAY))//','//TRIM(ITOS(NPER+SIMNPER))//','//TRIM(ITOS(ISS))//','//TRIM(ITOS(NSCL))//','// &
      TRIM(ITOS(IFTEST))//','//TRIM(ITOS(ICONCHK))//','//TRIM(ITOS(IIPF))//','//TRIM(ITOS(IUNCONF))//','//TRIM(ITOS(IFVDL))//','// &
      TRIM(ITOS(IARMSWP))
 WRITE(JU,'(A)') TRIM(LINE)
 DO I=1,ABS(IIPF); READ(IU,'(A256)') LINE; WRITE(JU,'(A)') TRIM(LINE); ENDDO
 READ(IU,'(A)')  LINE
 LINE=TRIM(ITOS(NMULT))//','//TRIM(ITOS(IDBG))//','//TRIM(ITOS(IDOUBLE))//','//TRIM(ITOS(IPOSWEL))//',' &
           //TRIM(ITOS(0))//','//TRIM(ITOS(IBUDGET))//','//TRIM(RTOS(MINKD,'G',7))//','//TRIM(RTOS(MINC,'G',7))
 WRITE(JU,'(A)') TRIM(LINE)

 READ(IU,*)
 DELTCNVG=0.0D0
 IF(NCORES.GT.1)MXITER=-ABS(MXITER)
 LINE=TRIM(ITOS(MXITER))//','//TRIM(ITOS(NITER))//','// &
      TRIM(RTOS(HCLOSE,'G',7))//','//TRIM(RTOS(RCLOSE,'G',7))//',' &
           //TRIM(RTOS(RELAX,'G',7))
 
 IF(NCORES.GT.1)THEN
  !## PKS options
  LINE=TRIM(LINE)//','//TRIM(ITOS(PARTOPT))//','//TRIM(ITOS(IMERGE))
 ELSE
  !## PCG option
  LINE=TRIM(LINE)//','//TRIM(ITOS(NPCOND))//','//TRIM(RTOS(MAXWBAL,'G',7))
 ENDIF
 
 WRITE(JU,'(A)') TRIM(LINE)
 
 IF(PARTOPT.EQ.1)THEN
  IF(TRIM(MRGFNAME).EQ.'')THEN
   CLOSE(IU); CLOSE(JU); CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'You need to specify a pointer IDF-file when selecting the RCB partition method.','Error')
   RETURN
  ENDIF
  WRITE(JU,'(A)') '"'//TRIM(MRGFNAME)//'"'
 ENDIF

 IF(NSCL_ORG.NE.0)READ(IU,*) !## simbox(1:4),simcsize,mdlbuffer

 DO I=1,NMULT; READ(IU,*); ENDDO
 
 IF(NMULT.EQ.1)THEN

  !## round to nearest snap ...
  IF(IROUND.EQ.1)THEN
   CALL UTL_IDFSNAPTOGRID(SIMBOX(1),SIMBOX(3),SIMBOX(2),SIMBOX(4),SIMCSIZE,I,J)
  ENDIF

  LINE=''; DO I=1,4; LINE=TRIM(LINE)//TRIM(RTOS(SIMBOX(I),'F',3))//','; ENDDO
 
  IF(NSCL.EQ.1)LINE=TRIM(LINE)//TRIM(RTOS(SIMCSIZE,'F',3))//','//TRIM(RTOS(MDLBUFFER,'F',3))
  IF(NSCL.EQ.2)LINE=TRIM(LINE)//TRIM(RTOS(SIMCSIZE,'F',3))//','//TRIM(RTOS(MAXSIMCSIZE,'F',3))//','//TRIM(RTOS(MDLBUFFER,'F',3))

  WRITE(JU,'(A)') TRIM(ADJUSTL(LINE))

 ELSE
  !## something to do with nmult>1

 ENDIF

 READ(IU,*)
 WRITE(JU,'(A)') 'ACTIVE MODULES'

 !## skip original runfile until MODULES FOR EACH LAYER
 DO
  READ(IU,'(A256)') LINE; LINE=UTL_CAP(LINE,'U')
  IF(INDEX(LINE,'MODULES FOR EACH LAYER').GT.0)EXIT
 END DO

 !## write new modules/packages that are active
 DO I=1,NMP_ACT
  K=MDL_IPOS(I)
  IF(NLMDL(K).EQ.0)WRITE(FRM,'(A9)') '(I2,I3,A)'
  IF(NLMDL(K).GT.0)WRITE(FRM,'(A4,I3,A5)') '(I2,',NLMDL(K)+1,'I3,A)'
  WRITE(LINE,FRM,IOSTAT=IOS) IAMDL(K),NLMDL(K),(ILMDL(K,J),J=1,NLMDL(K)),' ('//TRIM(MDLKEYWS(K))//')'
  WRITE(JU,'(A)') TRIM(LINE)
 END DO

 INQUIRE(FILE=PREFVAL(8),EXIST=LEX)
 IF(.NOT.LEX)THEN
  CLOSE(IU)
  CLOSE(JU,STATUS='DELETE')
  CALL WMESSAGEBOX(OKONLY,COMMONOK,EXCLAMATIONICON,'Given MODFLOW executable in *.prf-file: '//CHAR(13)// &
    'MODFLOW=[ '//TRIM(PREFVAL(8))//' ]'//CHAR(13)//' is empty or does not exist!','Error')
  RETURN
 ENDIF

 !## write bndfname
 IF(LEN_TRIM(BNDFNAME).EQ.0)THEN
  FNAME=TRIM(RTOS(IDF%XMIN,'F',2))//','//TRIM(RTOS(IDF%YMIN,'F',2))//','//TRIM(RTOS(IDF%XMAX,'F',2))//','//TRIM(RTOS(IDF%YMAX,'F',2))
  WRITE(JU,'(A)') CHAR(39)//TRIM(FNAME)//CHAR(39)
 ELSE
  FNAME=BNDFNAME
  FNAME=UTL_CAP(FNAME,'U')
  FNAME=UTL_SUBST(FNAME,TRIM(REPLACESTRING),PREFVAL(5))
  WRITE(JU,'(A)') CHAR(39)//TRIM(FNAME)//CHAR(39)
 ENDIF

 WRITE(JU,'(A)') 'MODULES FOR EACH LAYER'

 CALL WINDOWSELECT(0); CALL WINDOWOUTSTATUSBAR(4,'Writing runfile ...')

 !## copy of packages in tmp-runfiles
 KU=0
 IPER=0
 !## copy paste entire runfile
 DO
  READ(IU,'(A256)',IOSTAT=IOS) LINE
  IF(IOS.NE.0)EXIT

  LDATE=.FALSE.
  READ(LINE,*,IOSTAT=IOS) I,FCT,IMP
  !## try date 
  IF(IOS.NE.0)THEN
   READ(LINE,*,IOSTAT=IOS) KPER,DELT,CDATE,ISAVE
   IF(IOS.EQ.0)THEN
    LDATE=.TRUE. 
    IPER=IPER+1
   ENDIF
  ENDIF
  IF(LDATE)THEN 
   IF(IBUFFER.EQ.0)ISAVE=-1*ABS(ISAVE)
   IF(IBUFFER.EQ.1)ISAVE=   ABS(ISAVE)
   IF(ISUB.EQ.0)THEN
    LINE=TRIM(ITOS(KPER))//','//TRIM(RTOS(DELT,'F',2))//','//TRIM(CDATE)//','//TRIM(ITOS(ISAVE))
   ELSE
    LINE=TRIM(ITOS(KPER))//','//TRIM(RTOS(DELT,'F',2))//','//TRIM(INIDATE)//','//TRIM(ITOS(ISAVE))
   ENDIF
   WRITE(JU,'(A)') TRIM(ADJUSTL(LINE))
  ELSE
   !## start of data block found ... see whether runfile need to be copied
   IF(INDEX(LINE,'(').GT.0.AND.INDEX(LINE,')').GT.0.AND.ISUB.EQ.1.AND.IPER.GT.0)THEN 
    !## close previous unit
    IF(KU.GT.0)THEN; INQUIRE(UNIT=KU,OPENED=LEX); IF(LEX)CLOSE(KU); ENDIF
    KU=UTL_GETUNIT()
    CALL OSD_OPEN(KU,FILE=TRIM(RUN2)//'\org_'//LINE(INDEX(LINE,'(')+1:INDEX(LINE,')')-1)//'.RUN',STATUS='REPLACE', &
        ACTION='WRITE,DENYREAD',IOSTAT=IOS)
    IF(IOS.NE.0)THEN
     CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Cannot create '//TRIM(RUN2)//'\org_'// &
       LINE(INDEX(LINE,'(')+1:INDEX(LINE,')')-1)//'.RUN','Error')
     RETURN
    ENDIF
   ENDIF
   LINE=UTL_CAP(LINE,'U')
   LINE=UTL_SUBST(LINE,TRIM(REPLACESTRING),PREFVAL(5))

   !## try find extent ... to put quotes around it (for reasons of security)
   IF(INDEX(LINE,'\',.TRUE.).GT.0)THEN
    I=INDEX(LINE,'.',.TRUE.)
    !## found extent
    IF(I.GT.0)THEN
     J=INDEX(LINE,',',.TRUE.)
     !## found comma ---- BEFORE extent!
     IF(J.GT.0.AND.J.LT.I)THEN
      FNAME=LINE(J+1:)
      !## remove '
      DO
       IF(INDEX(FNAME,CHAR(39)).EQ.0)EXIT
       FNAME=UTL_SUBST(FNAME,CHAR(39),' ')
      ENDDO
      !## remove "
      DO
       IF(INDEX(FNAME,CHAR(34)).EQ.0)EXIT
       FNAME=UTL_SUBST(FNAME,CHAR(34),' ')
      ENDDO   
      !## read without quotes
      READ(FNAME,'(A256)') FNAME
      !## assign quotes if neccessary
      IF(INDEX(TRIM(FNAME),' ').GT.0)THEN
       LINE =LINE(:J-1)//','//CHAR(39)//TRIM(ADJUSTL(FNAME))//CHAR(39)
      ELSE
       LINE =LINE(:J-1)//','//TRIM(ADJUSTL(FNAME))
      ENDIF
     ELSE
      !## read without quotes
      READ(LINE,*) LINE
      IF(INDEX(TRIM(LINE),' ').GT.0)THEN
       LINE =CHAR(39)//TRIM(ADJUSTL(LINE))//CHAR(39)
      ELSE
       LINE =TRIM(ADJUSTL(LINE))
      ENDIF
     ENDIF
    ENDIF
   ENDIF

   WRITE(JU,'(A)') TRIM(ADJUSTL(LINE))
   IF(KU.NE.0)WRITE(KU,'(A)') TRIM(ADJUSTL(LINE))
  ENDIF
 END DO

 CALL WINDOWSELECT(0)
 CALL WINDOWOUTSTATUSBAR(4,'')

 CLOSE(IU)
 CLOSE(JU)
 IF(KU.GT.0)THEN; INQUIRE(UNIT=KU,OPENED=LEX); IF(LEX)CLOSE(KU); ENDIF

 MODEL1WRITERUNFILE=.TRUE.

 END FUNCTION MODEL1WRITERUNFILE

 !###======================================================================
 SUBROUTINE MODEL1COPYRUNFILE(IBATCH)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IBATCH
 INTEGER :: IU,JU,KU,I,II,J,JJ,K,IOS,IROW,ICOL,N
 CHARACTER(LEN=256) :: LINE,FNAMETO,FNAME,FNAME1,FNAME2  
 CHARACTER(LEN=512) :: STRING
 CHARACTER(LEN=52) :: SUBMAP
 CHARACTER(LEN=1) :: YN,QYN
 CHARACTER(LEN=4),DIMENSION(10) :: EXTISG
 LOGICAL :: LEX,LCOPY,LRUN
 DATA EXTISG/'ISG','ISP','ISD1','ISD2','ISC1','ISC2','IST1','IST2','ISQ1','ISQ2'/

 QYN='Y'
 
 IF(IBATCH.EQ.0)THEN

  !## get current simulation window
  CALL MODEL1GETSIMBOX()

  RESDIR=TRIM(PREFVAL(1))
  CALL WSELECTDIR(NONEXPATH+DIRCHANGE+DIRCREATE,RESDIR,'Select/Create Folder to store copy')
  IF(WINFODIALOG(4).NE.1)RETURN

  CALL WDIALOGSELECT(ID_DMDLTAB1)
  CALL WDIALOGGETMENU(IDF_MENU1,I,RUNFILE)
  RUNFILE=TRIM(PREFVAL(1))//'\RUNFILES\'//TRIM(RUNFILE)

 ENDIF

 !## open runfile
 IU=UTL_GETUNIT()
 CALL OSD_OPEN(IU,FILE=RUNFILE,STATUS='OLD',ACTION='READ,DENYWRITE',IOSTAT=IOS)
 IF(IOS.NE.0)THEN
  IF(IBATCH.EQ.0)CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Cannot open selected runfile for reading!','Error')
  IF(IBATCH.EQ.1)WRITE(*,'(A)') 'Cannot open selected runfile ['//TRIM(RUNFILE)//'] for reading!'
  RETURN
 ENDIF

 FNAME=TRIM(RUNFILE(INDEX(RUNFILE,'\',.TRUE.)+1:))
 LRUN=INDEX(UTL_CAP(FNAME,'U'),'.RUN').GT.0
 
 !## create result-folder
 CALL UTL_CREATEDIR(RESDIR)
 
 JU=UTL_GETUNIT()
 CALL OSD_OPEN(JU,FILE=TRIM(RESDIR)//'\'//TRIM(FNAME),STATUS='REPLACE',ACTION='WRITE,DENYREAD',IOSTAT=IOS)
 IF(IOS.NE.0)THEN
  CLOSE(IU)
  IF(IBATCH.EQ.0)CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Cannot open new runfile:'//CHAR(13)// &
    TRIM(RESDIR)//'\'//TRIM(FNAME),'Error')
  IF(IBATCH.EQ.1)WRITE(*,'(A)') 'Cannot open new runfile: ['//TRIM(RESDIR)//'\'//TRIM(FNAME)//']'
  RETURN
 ENDIF

 IF(IBATCH.EQ.0)THEN
  CALL UTL_MESSAGEHANDLE(0)
  CALL WINDOWSELECT(0); CALL WINDOWOUTSTATUSBAR(4,'Copy runfile/content ...')
 ELSE
  WRITE(*,'(A)') 'Copy runfile/content ...'
 ENDIF

 NIPF=1
 CALL IPFALLOCATE()
 IPF(1)%XCOL =1 !## x
 IPF(1)%YCOL =2 !## y
 IPF(1)%ZCOL =1 !## z not used
 IPF(1)%Z2COL=1 !## z not used
 IPF(1)%QCOL =1 !## q not used
 
 !## no window given
 LCOPY=.FALSE.; IF(SIMCSIZE.EQ.0.0D0)LCOPY=.TRUE.

 !## set idf to scale
 IF(.NOT.LCOPY)THEN
  !## scale boundary because otherwise the size of the model becomes too less
  CALL UTL_IDFSNAPTOGRID_LLC(SIMBOX(1),SIMBOX(3),SIMBOX(2),SIMBOX(4),SIMCSIZE,SIMCSIZE,IDFC%NCOL,IDFC%NROW,LLC=.TRUE.) 
  IDFC%XMIN=SIMBOX(1); IDFC%YMIN=SIMBOX(2)
  IDFC%XMAX=SIMBOX(3); IDFC%YMAX=SIMBOX(4); IDFC%DX=SIMCSIZE ;IDFC%DY=IDFC%DX
 ELSE
  SIMBOX(1)=-10.0D10; SIMBOX(3)=10.0D10
  SIMBOX(2)=-10.0D10; SIMBOX(4)=10.0D10
 ENDIF
 
 SUBMAP=''
 K=0
MAINLOOP: DO
  LEX=.TRUE.
  READ(IU,'(A256)',IOSTAT=IOS) LINE
  IF(IOS.NE.0)EXIT
  I=INDEX(LINE,'(')
  J=INDEX(LINE,')')
  IF(I.GT.0.AND.J.GT.0)SUBMAP=UTL_CAP(LINE(I+1:J-1),'U')
  IF(SUBMAP.EQ.'')SUBMAP='GENERAL'
  LINE=UTL_CAP(LINE,'U')
  LINE=UTL_SUBST(LINE,TRIM(REPLACESTRING),PREFVAL(5))
  K=K+1
  !## try find extent
  DO I=1,SIZE(EXT)
   J=INDEX(LINE,EXT(I),.TRUE.)
   !## found extent
   IF(J.GT.0)THEN
    !## found comma (before)
    J=INDEX(LINE(:J),',',.TRUE.)+1
    IF(J.GT.0)THEN
     READ(LINE(J:),*) FNAME 
     INQUIRE(FILE=FNAME,EXIST=LEX)
     IF(.NOT.LEX)THEN
      IF(IBATCH.EQ.0)CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'iMOD cannot find '//CHAR(13)//'['//TRIM(FNAME)//']','Error')
      IF(IBATCH.EQ.1)WRITE(*,'(A)') 'iMOD cannot find ['//TRIM(FNAME)//']'
      EXIT MAINLOOP
     ENDIF
     
     JJ=0
     IF(LEN_TRIM(CLIPDIR).GT.0)THEN
      JJ=INDEX(UTL_CAP(FNAME,'U'),TRIM(UTL_CAP(CLIPDIR,'U')))
      !## clipdir found
      IF(JJ.GT.0)FNAMETO=UTL_SUBST(UTL_CAP(FNAME,'U'),TRIM(UTL_CAP(CLIPDIR,'U')),TRIM(UTL_CAP(RESDIR,'U')))
     ENDIF
     IF(JJ.EQ.0)THEN
      IF(TRIM(SUBMAP).EQ.'')FNAMETO=TRIM(RESDIR)//'\GENERAL\VERSION_1\'//TRIM(FNAME(INDEX(FNAME,'\',.TRUE.)+1:))
      IF(TRIM(SUBMAP).NE.'')FNAMETO=TRIM(RESDIR)//'\'//TRIM(SUBMAP)//'\VERSION_1\'//TRIM(FNAME(INDEX(FNAME,'\',.TRUE.)+1:))
     ENDIF
     
     !## filename already exists
     INQUIRE(FILE=FNAMETO,EXIST=LEX)
     !## boundaries always because of the boundary file that could be used previously
     IF(TRIM(SUBMAP).EQ.'BND')LEX=.FALSE.

     IF(.NOT.LEX)THEN

      !## resize IDF-file
      IF(EXT(I).EQ.'.IDF')THEN
       
       IF(LCOPY)THEN
        CALL UTL_CREATEDIR(FNAMETO(:INDEX(FNAMETO,'\',.TRUE.)-1))
        WRITE(*,'(A)') 'Copying '//TRIM(FNAME)//' ...'
        CALL IOSCOPYFILE(FNAME,FNAMETO)
       ELSE
        IF(IBATCH.EQ.0)CALL WINDOWOUTSTATUSBAR(4,'Processing '//TRIM(FNAME))
        IF(IBATCH.EQ.1)WRITE(*,'(A)') 'Processing '//TRIM(FNAME)
        !## include constant head around it
        IF(TRIM(SUBMAP).EQ.'BND')THEN
         IF(.NOT.IDFREADSCALE(FNAME,IDFC,1,1,0.0D0,0))RETURN
         DO IROW=1,IDFC%NROW
          IF(IDFC%X(1,IROW)        .GT.0)IDFC%X(1,IROW)        =-1
          IF(IDFC%X(IDFC%NCOL,IROW).GT.0)IDFC%X(IDFC%NCOL,IROW)=-1
         ENDDO
         DO ICOL=1,IDFC%NCOL
          IF(IDFC%X(ICOL,1)        .GT.0)IDFC%X(ICOL,1)        =-1
          IF(IDFC%X(ICOL,IDFC%NROW).GT.0)IDFC%X(ICOL,IDFC%NROW)=-1
         ENDDO
        ELSE
         !## read part of idf and store in idf()%x() - create smaller resolution!
         IF(.NOT.IDFREAD(IDFC,FNAME,0))EXIT
         IF(.NOT.IDFREADPART(IDFC,SIMBOX(1),SIMBOX(2),SIMBOX(3),SIMBOX(4)))RETURN
        ENDIF
        IF(.NOT.IDFWRITE(IDFC,FNAMETO,1))RETURN
        CALL IDFDEALLOCATEX(IDFC)
        IF(IDFC%IU.GT.0)CLOSE(IDFC%IU)
       ENDIF
       IF(IBATCH.EQ.0)CALL WINDOWOUTSTATUSBAR(4,'Copy runfile/content ...')
     
      ELSEIF(EXT(I).EQ.'.IPF')THEN

       WRITE(*,'(A)') 'Processing IPF '//TRIM(FNAME)//' ...'

       IPF(1)%FNAME=FNAME
       !## read entire ipf
       IF(.NOT.IPFREAD2(1,1,0))RETURN

       IF(IPF(1)%ACOL.GT.0)THEN
        KU=UTL_GETUNIT()
        CALL OSD_OPEN(KU,FILE=TRIM(PREFVAL(1))//'\TMP\copy.bat',STATUS='REPLACE',ACTION='WRITE,DENYREAD',IOSTAT=IOS)
        IF(IOS.NE.0)THEN
         CLOSE(IU); CLOSE(JU)
         IF(IBATCH.EQ.0)CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Cannot open '//TRIM(PREFVAL(1))//'\tmp\copy.bat','Error')
         IF(IBATCH.EQ.1)WRITE(*,'(A)') 'Cannot open '//TRIM(PREFVAL(1))//'\tmp\copy.bat'
         RETURN
        ENDIF
       ENDIF
       
       !## check points inside area
       N=0
       DO II=1,IPF(1)%NROW
        IF(IPF(1)%XYZ(1,II).GE.SIMBOX(1).AND.IPF(1)%XYZ(1,II).LE.SIMBOX(3).AND. &
           IPF(1)%XYZ(2,II).GE.SIMBOX(2).AND.IPF(1)%XYZ(2,II).LE.SIMBOX(4))THEN
         N=N+1
         IPF(1)%INFO(:,N)=IPF(1)%INFO(:,II)
         !## store associated file to be copied -- if available
         IF(IPF(1)%ACOL.GT.0)THEN
          !## old associated filename      
          FNAME1=FNAME(:INDEX(FNAME,'\',.TRUE.)-1)//'\'//TRIM(IPF(1)%INFO(IPF(1)%ACOL,II))//'.'//TRIM(ADJUSTL(IPF(1)%FEXT))
          INQUIRE(FILE=FNAME1,EXIST=LEX)
          IF(.NOT.LEX)THEN
           IF(IBATCH.EQ.0)CALL WINDOWOUTSTATUSBAR(4,TRIM(FNAME1)//' does not exists!')
           IF(IBATCH.EQ.1)WRITE(*,'(A)') TRIM(FNAME1)//' does not exists!'
           IF(QYN.EQ.'Y')THEN
            WRITE(*,'(A$)') 'This might be an issue if you want a transient simulation, continue ?'
            READ(*,'(A)') YN
            IF(YN.EQ.'Y'.OR.YN.EQ.'y')THEN; QYN='N'; CYCLE; ENDIF; STOP
           ENDIF
          ELSE
           FNAME2=FNAMETO(:INDEX(FNAMETO,'\',.TRUE.)-1)
           FNAME2=TRIM(FNAME2)//'\'//TRIM(IPF(1)%INFO(IPF(1)%ACOL,II))//'.'//TRIM(ADJUSTL(IPF(1)%FEXT))
           CALL UTL_CREATEDIR(FNAME2(:INDEX(FNAME2,'\',.TRUE.)-1))
           !## copy batch
           STRING='copy "'//TRIM(FNAME1)//'" "'//TRIM(FNAME2)//'"'
           IF(STRING(LEN(STRING):LEN(STRING)).NE.' ')THEN
            IF(IBATCH.EQ.0)CALL WINDOWOUTSTATUSBAR(4,'Copy string to short - organise folder differenly with shorter names, max. = '//TRIM(ITOS(LEN(STRING)))//' characters')
            IF(IBATCH.EQ.1)WRITE(*,'(A)') 'Copy string to short - organise folder differenly with shorter names, max. = '//TRIM(ITOS(LEN(STRING)))//' characters'
            PAUSE; STOP
           ENDIF
           WRITE(KU,'(A)') TRIM(STRING)
          ENDIF
         ENDIF     
        ENDIF
       END DO
       CALL UTL_CREATEDIR(FNAMETO(:INDEX(FNAMETO,'\',.TRUE.)-1))
       IPF(1)%NROW=N
       IPF(1)%FNAME=FNAMETO
       IF(.NOT.IPFWRITE(1))RETURN
       !## start copying
       IF(IPF(1)%ACOL.GT.0)THEN
        CLOSE(KU)
        WRITE(*,'(A)') 'Copying txt-files ...'
        CALL IOSCOMMAND(TRIM(PREFVAL(1))//'\TMP\COPY.BAT',PROCSILENT+PROCBLOCKED)
       ENDIF
       
      ELSEIF(EXT(I).EQ.'.ISG')THEN
      
       CALL UTL_CREATEDIR(FNAMETO(:INDEX(FNAMETO,'\',.TRUE.)-1))
       DO II=1,SIZE(EXTISG)
        FNAME1=FNAME  (:INDEX(FNAME  ,'.',.TRUE.))//TRIM(EXTISG(II))
        FNAME2=FNAMETO(:INDEX(FNAMETO,'.',.TRUE.))//TRIM(EXTISG(II))

        WRITE(*,'(A)') 'Copying ISG file '//TRIM(FNAME1)//' ...'

        CALL IOSCOPYFILE(TRIM(FNAME1),TRIM(FNAME2))
       ENDDO
       
      ELSE

       WRITE(*,'(A)') 'Copying '//TRIM(EXT(I))//' file '//TRIM(FNAME)//' ...'

       CALL UTL_CREATEDIR(FNAMETO(:INDEX(FNAMETO,'\',.TRUE.)-1))
       CALL IOSCOPYFILE(TRIM(FNAME),TRIM(FNAMETO))

      ENDIF
     ELSE
      IF(IBATCH.EQ.0)CALL WINDOWOUTSTATUSBAR(4,TRIM(FNAMETO)//' already exists!')
      IF(IBATCH.EQ.1)WRITE(*,'(A)') TRIM(FNAMETO)//' already exists!'
     ENDIF
     LINE=UTL_SUBST(LINE,TRIM(FNAME),TRIM(FNAMETO))
     EXIT
    ENDIF
   ENDIF
  ENDDO
  WRITE(JU,'(A)') TRIM(LINE)
 ENDDO MAINLOOP

 IF(IBATCH.EQ.0)THEN
  CALL UTL_MESSAGEHANDLE(1)
  CALL WINDOWSELECT(0)
  CALL WINDOWOUTSTATUSBAR(4,'')
 ENDIF

 CLOSE(IU)
 IF(.NOT.LEX)THEN
  CLOSE(JU,STATUS='DELETE')
  IF(IBATCH.EQ.0)CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'iMOD cannot copy '//CHAR(13)//TRIM(FNAME),'Error')
  IF(IBATCH.EQ.1)WRITE(*,'(A)') 'iMOD cannot copy '//CHAR(13)//TRIM(FNAME)
 ELSE
  CLOSE(JU)
  IF(IBATCH.EQ.0)THEN
   IF(.NOT.MODEL1FILL_RUNFILES())RETURN
  ENDIF
 ENDIF

 END SUBROUTINE MODEL1COPYRUNFILE

 !###======================================================================
 SUBROUTINE MODEL1CHECKRUNFILE(RUNFNAME)
 !###======================================================================
 IMPLICIT NONE
 CHARACTER(LEN=*),INTENT(IN) :: RUNFNAME
 CHARACTER(LEN=256) :: LINE,FNAME
 INTEGER :: I,J,K,II,IOS,IU,JU,IWIN,NF
 LOGICAL :: LEX

 CALL WINDOWSELECT(0); CALL WINDOWOUTSTATUSBAR(4,'Checking runfile ...')

 !## open runfile
 IU=UTL_GETUNIT()
 CALL OSD_OPEN(IU,FILE=RUNFNAME,STATUS='OLD',ACTION='READ,DENYWRITE',IOSTAT=IOS)
 IF(IOS.NE.0)THEN
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Cannot open runfile:'//CHAR(13)// &
   TRIM(RUNFNAME)//CHAR(13)//'for reading purposes.','Error')
  RETURN
 ENDIF

 JU=UTL_GETUNIT()
 CALL OSD_OPEN(JU,FILE=TRIM(PREFVAL(1))//'\tmp\runfile.log',STATUS='REPLACE',ACTION='WRITE,DENYREAD',IOSTAT=IOS)
 IF(IOS.NE.0)THEN
  CLOSE(IU)
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Cannot open logfile:'//CHAR(13)// &
   TRIM(PREFVAL(1))//'\tmp\runfile.log','Error')
  RETURN
 ENDIF

 CALL UTL_MESSAGEHANDLE(0)
 
 WRITE(JU,'(A)') 'Check-result for:'
 WRITE(JU,'(A)') TRIM(RUNFNAME)
 WRITE(JU,'(/A/)') 'Non-existing files:'
 WRITE(JU,'(A10,1X,A)') 'Line No.','Filename'
 WRITE(JU,'(50A1)') ('-',I=1,50)
 
 K=0; NF=0
 DO
  READ(IU,'(A256)',IOSTAT=IOS) LINE
  IF(IOS.NE.0)EXIT
  LINE=UTL_CAP(LINE,'U')
  K=K+1
  !## try find extent
  DO I=1,SIZE(EXT)
   J=INDEX(LINE,EXT(I),.TRUE.)
   !## found extent
   IF(J.GT.0)THEN
    II=INDEX(LINE(:J),',',.TRUE.)+1
    !## found comma
    IF(II.GT.0)THEN
     FNAME=LINE(II:)
     READ(FNAME,*) FNAME !## remove quotes (if existing)
     FNAME=UTL_SUBST(FNAME,TRIM(REPLACESTRING),PREFVAL(5))
     INQUIRE(FILE=FNAME,EXIST=LEX)
     IF(.NOT.LEX)THEN
      WRITE(JU,'(I10,1X,A)') K,TRIM(FNAME)
      NF=NF+1
     ENDIF
     EXIT
    ENDIF
   ENDIF
  ENDDO
 ENDDO

 IF(NF.EQ.0)WRITE(JU,'(/A/)') 'All files exist !!!'
 
 CLOSE(IU); CLOSE(JU)

 CALL UTL_MESSAGEHANDLE(1)
 CALL WINDOWSELECT(0)
 CALL WINDOWOUTSTATUSBAR(4,'')

 CALL WINDOWOPENCHILD(IWIN,FLAGS=SYSMENUON,WIDTH=1000,HEIGHT=500)
 CALL WINDOWSELECT(IWIN)
 FNAME=TRIM(PREFVAL(1))//'\tmp\runfile.log'
 CALL WEDITFILE(FNAME,ITYPE=MODAL,IDMENU=0,IFONT=COURIERNEW,ISIZE=10)

 END SUBROUTINE MODEL1CHECKRUNFILE

 !###======================================================================
 LOGICAL FUNCTION MODEL1CHECK(FNAME,IU,JU)
 !###======================================================================
 IMPLICIT NONE
 CHARACTER(LEN=*),INTENT(IN) :: FNAME
 INTEGER,INTENT(IN) :: IU,JU
 INTEGER :: IOS
 REAL(KIND=DP_KIND) :: X

 READ(FNAME,*,IOSTAT=IOS) X
 IF(IOS.NE.0)THEN
  INQUIRE(FILE=FNAME,EXIST=MODEL1CHECK)
  IF(.NOT.MODEL1CHECK)THEN
   CLOSE(IU)
   CLOSE(JU,STATUS='DELETE')
   CALL WMESSAGEBOX(OKONLY,COMMONOK,EXCLAMATIONICON,'File '//TRIM(FNAME)//CHAR(13)// &
   'does not exists!','Error')
  ENDIF
 ELSE
  MODEL1CHECK=.TRUE.
 ENDIF

 END FUNCTION MODEL1CHECK

 !###======================================================================
 SUBROUTINE MODEL1DEFINEBOX()
 !###======================================================================
 IMPLICIT NONE
 TYPE(WIN_MESSAGE) :: MESSAGE
 INTEGER :: ITYPE,IDOWN
 REAL(KIND=DP_KIND) :: XC1,YC1,XC2,YC2,MOUSEX,MOUSEY

 CALL UTL_HIDESHOWDIALOG(ID_DMODEL,0)
 CALL WCURSORSHAPE(ID_CURSORNETWORK)
 CALL WINDOWOUTSTATUSBAR(4,'Click your right mouse button to quit')

 IDOWN=0
 DO

  CALL WMESSAGE(ITYPE, MESSAGE)
  
  MOUSEX=DBLE(MESSAGE%GX)+OFFSETX
  MOUSEY=DBLE(MESSAGE%GY)+OFFSETY
  
  SELECT CASE(ITYPE)

   CASE(MOUSEMOVE)

    CALL WINDOWSELECT(0)
    CALL WINDOWOUTSTATUSBAR(1,'X:'//TRIM(RTOS(MOUSEX,'G',7))//' m; Y:'//TRIM(RTOS(MOUSEY,'G',7))//' m')
    XC2=MOUSEX
    YC2=MOUSEY
    
    IF(XC2.LT.MODBOX(1).OR.XC2.GT.MODBOX(3).OR. &
       YC2.LT.MODBOX(2).OR.YC2.GT.MODBOX(4))THEN
     IF(WINFOMOUSE(MOUSECURSOR).NE.CURHOURGLASS)CALL WCURSORSHAPE(CURHOURGLASS)
     CALL WINDOWOUTSTATUSBAR(2,'Outside model domain')
    ELSE
     IF(WINFOMOUSE(MOUSECURSOR).NE.ID_CURSORNETWORK)CALL WCURSORSHAPE(ID_CURSORNETWORK)
     IF(IDOWN.EQ.1)CALL WINDOWOUTSTATUSBAR(2,'DeltaX:'//TRIM(ITOS(INT(XC2-XC1)))//' m; DeltaY:'//TRIM(ITOS(INT(YC2-YC1)))//' m')
    ENDIF  

    !## first point set!
    IF(IDOWN.EQ.1)THEN
     !## remove previous one
     CALL MODEL1DRAW_SIMBOX()
     CALL MODEL1PUTSIMBOX(MIN(XC1,XC2),MIN(YC1,YC2),MAX(XC1,XC2),MAX(YC1,YC2))
     CALL MODEL1GETSIMBOX()
     CALL MODEL1FIELDS()
     !## draw updated one
     CALL MODEL1DRAW_SIMBOX()
    ENDIF

   !## mouse button pressed
   CASE (MOUSEBUTDOWN)
   
    SELECT CASE (MESSAGE%VALUE1)
     !## left button
     CASE (1)
      IF(WINFOMOUSE(MOUSECURSOR).NE.CURHOURGLASS)THEN
       IF(IDOWN.EQ.0)THEN
        XC1=XC2
        YC1=YC2
        IDOWN=1
       ELSEIF(IDOWN.EQ.1)THEN
        EXIT
       ENDIF
      ENDIF
     !## right button
     CASE (3)
      EXIT
    END SELECT
    
   CASE (BITMAPSCROLLED)
    MPW%IX=MESSAGE%VALUE1
    MPW%IY=MESSAGE%VALUE2

  END SELECT
 ENDDO

 CALL WCURSORSHAPE(CURARROW)
 CALL IGRPLOTMODE(MODECOPY)

 CALL WINDOWSELECT(0)
 CALL WINDOWOUTSTATUSBAR(2,'')
 CALL WINDOWOUTSTATUSBAR(4,'')
 CALL UTL_HIDESHOWDIALOG(ID_DMODEL,2)

 END SUBROUTINE MODEL1DEFINEBOX

 !###======================================================================
 SUBROUTINE MODEL1PUTSIMBOX(XMIN,YMIN,XMAX,YMAX)
 !###======================================================================
 IMPLICIT NONE
 REAL(KIND=DP_KIND),INTENT(IN) :: XMIN,XMAX,YMIN,YMAX
 REAL(KIND=DP_KIND) :: DX,DY

 CALL WDIALOGSELECT(ID_DMDLTAB2)
 CALL WDIALOGPUTDOUBLE(IDF_REAL1,MAX(MODBOX(1),XMIN),'(F15.3)')
 CALL WDIALOGPUTDOUBLE(IDF_REAL4,MAX(MODBOX(2),YMIN),'(F15.3)')
 CALL WDIALOGPUTDOUBLE(IDF_REAL2,MIN(MODBOX(3),XMAX),'(F15.3)')
 CALL WDIALOGPUTDOUBLE(IDF_REAL5,MIN(MODBOX(4),YMAX),'(F15.3)')
 DX=MIN(MODBOX(3),XMAX)-MAX(MODBOX(1),XMIN)
 DY=MIN(MODBOX(4),YMAX)-MAX(MODBOX(2),YMIN)
 CALL WDIALOGPUTDOUBLE(IDF_REAL3,DX,'(F15.3)')
 CALL WDIALOGPUTDOUBLE(IDF_REAL6,DY,'(F15.3)')

 END SUBROUTINE MODEL1PUTSIMBOX

 !###======================================================================
 SUBROUTINE MODEL1GETSIMBOX()
 !###======================================================================
 IMPLICIT NONE
 INTEGER :: I 
 REAL(KIND=DP_KIND) :: DX,DY
 CHARACTER(LEN=256) :: LINE

 CALL WDIALOGSELECT(ID_DMDLTAB2)
 CALL WDIALOGGETDOUBLE(IDF_REAL1,SIMBOX(1))
 CALL WDIALOGGETDOUBLE(IDF_REAL4,SIMBOX(2))
 CALL WDIALOGGETDOUBLE(IDF_REAL2,SIMBOX(3))
 CALL WDIALOGGETDOUBLE(IDF_REAL5,SIMBOX(4))
 DX=SIMBOX(3)-SIMBOX(1)
 DY=SIMBOX(4)-SIMBOX(2)

 !## given area of interest
 CALL WDIALOGGETRADIOBUTTON(IDF_RADIO1,I)
 IF(I.EQ.1)THEN

  CALL WDIALOGGETDOUBLE(IDF_REAL7,SIMCSIZE)
  CALL WDIALOGGETDOUBLE(IDF_REAL8,MDLBUFFER)
  CALL WDIALOGGETDOUBLE(IDF_REAL9,MAXSIMCSIZE)

  DX=DX+MDLBUFFER
  DY=DY+MDLBUFFER

 ELSE

  !## put dimensions of idf file
  SIMBOX(1)=IDF%XMIN
  SIMBOX(2)=IDF%YMIN
  SIMBOX(3)=IDF%XMAX
  SIMBOX(4)=IDF%YMAX

 ENDIF

 CALL WDIALOGGETMENU(IDF_MENU3,I,LINE)
 READ(LINE,*) NLAY

 IF(NLAY.LT.MXNLAY)THEN
  CALL WDIALOGPUTSTRING(IDF_LABEL11,'Modellayer '//TRIM(ITOS(NLAY))//' will be modelled as a Constant Head Boundary')
 ELSE
  CALL WDIALOGPUTSTRING(IDF_LABEL11,'')
 ENDIF
 
 !## not possible to compute with nodes more than maxnodes
 CALL WDIALOGSELECT(ID_DMODEL)
 
 END SUBROUTINE MODEL1GETSIMBOX

 !###======================================================================
 LOGICAL FUNCTION MODEL1RUNFILE()
 !###======================================================================
 IMPLICIT NONE
 CHARACTER(LEN=20),ALLOCATABLE,DIMENSION(:) :: CSIZES
 INTEGER :: I
 REAL(KIND=DP_KIND) :: DX
 CHARACTER(LEN=256) :: FNAME

 MODEL1RUNFILE=.FALSE.

 CALL WDIALOGSELECT(ID_DMDLTAB1)
 CALL WDIALOGGETMENU(IDF_MENU1,I,FNAME)
 FNAME=TRIM(PREFVAL(1))//'\RUNFILES\'//TRIM(FNAME)

 !## read selected runfile
 IF(.NOT.MODEL1READRUNFILE(FNAME))RETURN

 !## put save options
 CALL WDIALOGSELECT(ID_DMDLTAB3)
 IF(NMP_ACT.EQ.0)THEN
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'No modules/packages are found in the run-file'//CHAR(13)// &
      'Bracket the keyword, e.g. (bnd), otherwise iMOD cannot find them','Error') 
  RETURN
 ENDIF
 CALL WDIALOGPUTMENU(IDF_MENU1,MDLALIAS_ACT,NMP_ACT,1)

 CALL WDIALOGSELECT(ID_DMDLTAB2)
 !## plot fname of idf
 CALL WDIALOGPUTSTRING(IDF_STRING1,BNDFNAME)
 !## define box
 CALL WDIALOGPUTDOUBLE(IDF_REAL1,MODBOX(1),'(F15.3)')
 CALL WDIALOGPUTDOUBLE(IDF_REAL4,MODBOX(2),'(F15.3)')
 CALL WDIALOGPUTDOUBLE(IDF_REAL2,MODBOX(3),'(F15.3)')
 CALL WDIALOGPUTDOUBLE(IDF_REAL5,MODBOX(4),'(F15.3)')
 !## simcsize
 IF(ALLOCATED(CSIZES))DEALLOCATE(CSIZES)
 ALLOCATE(CSIZES(MAXCSIZES))
 CSIZES(1) ='1.0'
 CSIZES(2) ='5.0'
 CSIZES(3) ='10.0'
 CSIZES(4) ='25.0'
 CSIZES(5) ='50.0'
 CSIZES(6) ='100.0'
 CSIZES(7) ='250.0'
 CSIZES(8) ='500.0'
 CSIZES(9) ='750.0'
 CSIZES(10)='1000.0'
 CSIZES(11)='1250.0'
 CSIZES(12)='2500.0'
 CSIZES(13)='5000.0'
 CSIZES=ADJUSTL(CSIZES)
 CALL WDIALOGPUTMENU(IDF_MENU1,CSIZES,13,4)      !## simcsize
 CALL WDIALOGPUTMENU(IDF_MENU4,CSIZES,13,6)      !## max simcsize
 CALL WDIALOGPUTDOUBLE(IDF_REAL7,SIMCSIZE,'(F15.3)')       !## simcsize
 CALL WDIALOGPUTDOUBLE(IDF_REAL9,4.0D0*SIMCSIZE,'(F15.3)') !## max simcsize

 !## buffer
 DX=-100.0D0
 DO I=1,MAXCSIZES
  DX=DX+100.0D0
  WRITE(CSIZES(I),'(F10.1)') DX
  CSIZES(I)=ADJUSTL(CSIZES(I))
 END DO
 CALL WDIALOGPUTMENU(IDF_MENU2,CSIZES,MAXCSIZES,16)
 IF(ALLOCATED(CSIZES))DEALLOCATE(CSIZES)

 !## nlay
 ALLOCATE(CSIZES(MXNLAY))
 DX=0.0D0
 DO I=1,MXNLAY 
  DX=DX+1.0D0
  WRITE(CSIZES(I),'(I10)') INT(DX)
  CSIZES(I)=ADJUSTL(CSIZES(I))
 END DO
 CALL WDIALOGSELECT(ID_DMDLTAB2)
 CALL WDIALOGPUTMENU(IDF_MENU3,CSIZES,MXNLAY,MXNLAY)
 IF(ALLOCATED(CSIZES))DEALLOCATE(CSIZES)

 CALL WDIALOGPUTDOUBLE(IDF_REAL8,MDLBUFFER,'(F15.3)')

 CALL WDIALOGSELECT(ID_DMDLTAB3)
 CALL WDIALOGPUTCHECKBOX(IDF_CHECK3,IDOUBLE)
 
 !## put iteration options
 CALL WDIALOGSELECT(ID_DMDLTAB6)
 CALL WDIALOGPUTDOUBLE(IDF_REAL1,HCLOSE,'(G15.7)')
 CALL WDIALOGPUTDOUBLE(IDF_REAL2,RCLOSE,'(G15.7)')
 CALL WDIALOGPUTDOUBLE(IDF_REAL3,RELAX,'(G15.7)')
 CALL WDIALOGPUTINTEGER(IDF_INTEGER1,MXITER)
 CALL WDIALOGPUTINTEGER(IDF_INTEGER2,NITER)
 CALL WDIALOGPUTDOUBLE(IDF_REAL4,MAXWBAL,'(F15.3)')
 NPCOND=MAX(1,MIN(2,NPCOND))
 CALL WDIALOGPUTOPTION(IDF_MENU1,NPCOND)
 CALL WDIALOGPUTDOUBLE(IDF_REAL5,MINKD,'(F15.3)')
 CALL WDIALOGPUTDOUBLE(IDF_REAL6,MINC,'(F15.3)')
 CALL WDIALOGPUTCHECKBOX(IDF_CHECK2,IMERGE)
 
 !## initial simulation size is equal to entire model simulation size
 SIMBOX=MODBOX
 !## fill coordinates current model
 CALL MODEL1PUTSIMBOX(SIMBOX(1),SIMBOX(2),SIMBOX(3),SIMBOX(4))
 CALL MODEL1GETSIMBOX()
 !## write save-able topics from runfile
 CALL MODEL1FILLSAVINGS()
 !## update fields
 CALL MODEL1FIELDS()

 MODEL1RUNFILE=.TRUE.

 END FUNCTION MODEL1RUNFILE

 !###======================================================================
 LOGICAL FUNCTION MODEL1READRUNFILE(RUNFNAME)
 !###======================================================================
 IMPLICIT NONE
 CHARACTER(LEN=*),INTENT(IN) :: RUNFNAME
 INTEGER :: IU,IOS,I,J
 CHARACTER(LEN=256) :: FNAME,LINE

 MODEL1READRUNFILE=.FALSE.

 IU=UTL_GETUNIT()
 CALL OSD_OPEN(IU,FILE=RUNFNAME,STATUS='OLD',ACTION='READ,DENYWRITE',IOSTAT=IOS)
 IF(.NOT.MODEL1READRUNFILEERROR(IOS,IU,'Error opening: '//TRIM(RUNFNAME)))RETURN
 READ(IU,*,IOSTAT=IOS)
 IF(.NOT.MODEL1READRUNFILEERROR(IOS,IU,'Error reading: Result directory'))RETURN
 READ(IU,'(A256)',IOSTAT=IOS) LINE
 READ(LINE,*,IOSTAT=IOS) NLAY,MXNLAY,NPER,ISS,NSCL,IFTEST,ICONCHK,IIPF,IUNCONF,IFVDL,IARMSWP
 IF(IOS.NE.0)THEN
  IARMSWP=0
  READ(LINE,*,IOSTAT=IOS) NLAY,MXNLAY,NPER,ISS,NSCL,IFTEST,ICONCHK,IIPF,IUNCONF,IFVDL
  IF(IOS.NE.0)THEN
   IFVDL=0
   READ(LINE,*,IOSTAT=IOS) NLAY,MXNLAY,NPER,ISS,NSCL,IFTEST,ICONCHK,IIPF,IUNCONF
   IF(IOS.NE.0)THEN
    IUNCONF=0
    READ(LINE,*,IOSTAT=IOS) NLAY,MXNLAY,NPER,ISS,NSCL,IFTEST,ICONCHK,IIPF
   ENDIF
  ENDIF
 ENDIF

 IF(.NOT.MODEL1READRUNFILEERROR(IOS,IU,'Error reading: NLAY,MXNLAY,NPER,ISS,NSCL,IFTEST,ICONCHK,IIPF'))RETURN

 !## read/skip ipf files
 DO I=1,ABS(IIPF); READ(IU,'(A256)',IOSTAT=IOS) LINE; ENDDO
 
 READ(IU,'(A256)',IOSTAT=IOS) LINE
 READ(LINE,*,IOSTAT=IOS) NMULT,IDBG,IDOUBLE,IPOSWEL,I,IBUDGET,MINKD,MINC
 IF(IOS.NE.0)THEN
  MINC=0.01D0
  READ(LINE,*,IOSTAT=IOS) NMULT,IDBG,IDOUBLE,IPOSWEL,I,IBUDGET,MINKD
  IF(IOS.NE.0)THEN
   MINKD=0.0D0
   READ(LINE,*,IOSTAT=IOS) NMULT,IDBG,IDOUBLE,IPOSWEL,I,IBUDGET
   IF(IOS.NE.0)THEN
    IBUDGET=0
    READ(LINE,*,IOSTAT=IOS) NMULT,IDBG,IDOUBLE,IPOSWEL
    IF(.NOT.MODEL1READRUNFILEERROR(IOS,IU,'Error reading: NMULT,IDEBUG,IDOUBLE,IPOSWEL'))RETURN
   ENDIF
  ENDIF
 ENDIF

 READ(IU,'(A256)',IOSTAT=IOS) LINE
 READ(LINE,*,IOSTAT=IOS) MXITER,NITER,HCLOSE,RCLOSE,RELAX,NPCOND,MAXWBAL,PARTOPT
 IF(IOS.NE.0)THEN
  PARTOPT=-99
  READ(LINE,*,IOSTAT=IOS) MXITER,NITER,HCLOSE,RCLOSE,RELAX,NPCOND,MAXWBAL
  IF(IOS.NE.0)THEN
   MAXWBAL=0.01D0
   READ(LINE,*,IOSTAT=IOS) MXITER,NITER,HCLOSE,RCLOSE,RELAX,NPCOND
   IF(IOS.NE.0)THEN
    NPCOND=1.0D0
    READ(LINE,*,IOSTAT=IOS) MXITER,NITER,HCLOSE,RCLOSE,RELAX
   ENDIF
  ENDIF
 ENDIF
 MXITER=ABS(MXITER)
 IF(.NOT.MODEL1READRUNFILEERROR(IOS,IU,'Error reading: MXITER,NITER,HCLOSE,RCLOSE,RELAX'))RETURN

 IF(NSCL.GT.2)THEN
  IF(.NOT.MODEL1READRUNFILEERROR(1,IU,'You cannot run an IR computation from iMOD, NSCL.GT.2'))RETURN
 ENDIF

 !## read loading matrix
 IF(PARTOPT.EQ.1)THEN
  READ(IU,*,IOSTAT=IOS) LINE
  MRGFNAME=TRIM(LINE)
 ENDIF
 
 IF(NMULT.EQ.1)THEN
  IF(NSCL.EQ.1)THEN
   READ(IU,*,IOSTAT=IOS) MODBOX(1:4),SIMCSIZE,MDLBUFFER
   IF(.NOT.MODEL1READRUNFILEERROR(IOS,IU,'Error reading: XMIN,YMIN,XMAX,YMAX,CSIZE,LAMBDA'))RETURN
  ENDIF
  IF(NSCL.EQ.2)THEN
   READ(IU,*,IOSTAT=IOS) MODBOX(1:4),SIMCSIZE,MAXSIMCSIZE,MDLBUFFER
   IF(.NOT.MODEL1READRUNFILEERROR(IOS,IU,'Error reading: XMIN,YMIN,XMAX,YMAX,CSIZE,MAXSIMCSIZE,LAMBDA'))RETURN
  ENDIF
 ELSE
  DO I=1,NMULT; READ(IU,*,IOSTAT=IOS); ENDDO
  !## default for nscl=0
  SIMCSIZE =100.0D0
  MDLBUFFER=1500.0D0
 ENDIF

 READ(IU,*,IOSTAT=IOS)
 IF(.NOT.MODEL1READRUNFILEERROR(IOS,IU,'Error reading: ACTIVE MODULES/PACKAGES'))RETURN

 IF(ALLOCATED(IAMDL))DEALLOCATE(IAMDL)
 IF(ALLOCATED(NLMDL))DEALLOCATE(NLMDL)
 IF(ALLOCATED(ILMDL))DEALLOCATE(ILMDL)
 ALLOCATE(IAMDL(MXMDL))
 ALLOCATE(NLMDL(MXMDL))
 ALLOCATE(ILMDL(MXMDL,MXNLAY))
 NLMDL=0
 ILMDL=0
 IAMDL=0
 MDLALIAS_ACT=''
 MDL_IPOS=0
 NMP_ACT=0
 BNDFNAME=''
 
 !## read/identify modules/packages
 DO
  READ(IU,'(A256)',IOSTAT=IOS) LINE
  LINE=UTL_CAP(LINE,'U')
  IF(INDEX(LINE,'(').EQ.0.AND.INDEX(LINE,')').EQ.0)THEN
   IF(TRIM(LINE).EQ.'MODULES FOR EACH LAYER')EXIT
   READ(LINE,*,IOSTAT=IOS) IDF%XMIN,IDF%YMIN,IDF%XMAX,IDF%YMAX 
   IF(IOS.EQ.0)EXIT
   IF(INDEX(LINE,'.IDF',.TRUE.).GT.0)THEN
    !## read bndfile
    READ(LINE,'(A)',IOSTAT=IOS) FNAME
    READ(FNAME,*) FNAME !## remove quotes (if existing)
    IF(.NOT.MODEL1READRUNFILEERROR(IOS,IU,'Error reading: BNDFILE'))RETURN
    FNAME=UTL_CAP(FNAME,'U')
    BNDFNAME=UTL_SUBST(FNAME,TRIM(REPLACESTRING),PREFVAL(5))
    !## read header of bndfile
    IF(.NOT.IDFREAD(IDF,BNDFNAME,0))THEN; CLOSE(IU); BNDFNAME=''; RETURN; ENDIF
    CLOSE(IDF%IU); EXIT
   ENDIF
  ENDIF
  DO I=1,SIZE(MDLKEYWS)
   J=INDEX(LINE,'('//TRIM(MDLKEYWS(I))//')')
   IF(J.NE.0)THEN
    READ(LINE,*,IOSTAT=IOS) IAMDL(I),NLMDL(I),(ILMDL(I,J),J=1,MIN(MXNLAY,NLMDL(I)))
    IF(.NOT.MODEL1READRUNFILEERROR(IOS,IU,'Error reading Module/Package ('//TRIM(MDLKEYWS(I))//')'))RETURN
    IF(IAMDL(I).NE.0)THEN
     NMP_ACT=NMP_ACT+1
     MDL_IPOS(NMP_ACT)=I
     MDLALIAS_ACT(NMP_ACT)=MDLALIAS(I)
    ENDIF
    EXIT
   ENDIF
  END DO
 END DO

 !## take maximum
 MODBOX(1)=IDF%XMIN
 MODBOX(2)=IDF%YMIN
 MODBOX(3)=IDF%XMAX
 MODBOX(4)=IDF%YMAX

 CLOSE(IU)

 MODEL1READRUNFILE=.TRUE.
 IDRAW=1
 
 END FUNCTION MODEL1READRUNFILE

 !###======================================================================
 SUBROUTINE MODEL1FILL_RESULTS()
 !###======================================================================
 IMPLICIT NONE

 CALL WDIALOGSELECT(ID_DMDLTAB4)
 CALL UTL_IMODFILLMENU(IDF_MENU1,TRIM(PREFVAL(1))//'\MODELS','*','D',NRESULTDIR,0,0)
 CALL WDIALOGPUTSTRING(IDF_LABEL4,TRIM(PREFVAL(1))//'\MODELS')
 CALL WDIALOGFIELDSTATE(IDF_MENU1,1)

 END SUBROUTINE MODEL1FILL_RESULTS

END MODULE MOD_MODEL
