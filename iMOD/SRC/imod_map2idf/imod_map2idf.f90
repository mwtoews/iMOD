!!  Copyright (C) Stichting Deltares, 2005-2014.
!!
!!  This file is part of iMOD.
!!
!!  This program is free software: you can redistribute it and/or modify
!!  it under the terms of the GNU General Public License as published by
!!  the Free Software Foundation, either version 3 of the License, or
!!  (at your option) any later version.
!!
!!  This program is distributed in the hope that it will be useful,
!!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!  GNU General Public License for more details.
!!
!!  You should have received a copy of the GNU General Public License
!!  along with this program.  If not, see <http://www.gnu.org/licenses/>.
!!
!!  Contact: imod.support@deltares.nl
!!  Stichting Deltares
!!  P.O. Box 177
!!  2600 MH Delft, The Netherlands.
!!
MODULE MOD_MAP2IDF

USE WINTERACTER
USE MOD_IDF, ONLY : IDFREAD,IDFWRITE,IDFWRITEDIM,IDFOPEN,IDFALLOCATEX,IDFDEALLOCATE,&
                        IDFDEALLOCATESX,IDFWRITECOMMENT,IDFFILLCOMMENT,IDFNULLIFY
USE MOD_MAP2IDF_PAR
USE MOD_UTL, ONLY : UTL_GETUNIT,ITOS 
USE MOD_OSD, ONLY : OSD_OPEN
USE IEEE_ARITHMETIC    
USE ISO_C_BINDING 

CONTAINS

 !#####=================================================================
 SUBROUTINE MAP2IDF_IMPORTMAP(IDFNAME,IERROR)
 !#####=================================================================
 IMPLICIT NONE
 CHARACTER(LEN=*),INTENT(IN) :: IDFNAME
 INTEGER,INTENT(OUT) :: IERROR
 INTEGER :: IOS
 INTEGER :: IU,ICOL,IROW,I,J,I4MINVAL,I4MAXVAL,NCOL,NROW
 REAL    :: NODATA,R4MINVAL,R4MAXVAL,RVAL
 REAL    :: XMIN,XMAX,YMIN,YMAX,CSIZE 
 CHARACTER(LEN=256) :: LINE

 !## Main header
 CHARACTER(LEN=32) :: SIGNATURE
 INTEGER(KIND=4) :: GISFILEID,ATTRTABLE,BYTEORDER
 INTEGER(KIND=2) :: PROJECTION,DATATYPE,VERSION
 !## Raster header
 INTEGER(KIND=2):: VALUESCALE,CELLREPR
 REAL(KIND=8) :: XUL,YUL
 INTEGER(KIND=4) :: NRROWS,NRCOLS
 REAL(KIND=8) :: CELLSIZEX,CELLSIZEY
 INTEGER, DIMENSION(:,:), ALLOCATABLE :: I4A
 
 IERROR=1

 CALL WINDOWSELECT(0); CALL WINDOWOUTSTATUSBAR(4,'IMPORTING '//TRIM(IDFNAME))
  
 !## open and read input file 
 IU=UTL_GETUNIT()
 CALL OSD_OPEN(IU,FILE=IDFNAME,STATUS='OLD',FORM='UNFORMATTED',ACTION='READ',ACCESS='stream',IOSTAT=IOS)
 IF(IOS.NE.0)THEN
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'CAN NOT OPEN FILE: '//CHAR(13)// &
   '['//TRIM(IDFNAME)//']'//CHAR(13)//'FOR READING','ERROR')
  RETURN
 ENDIF
 
 !## Main header
 READ(IU,POS=  0+1) SIGNATURE
 READ(IU,POS= 32+1) VERSION
 READ(IU,POS= 34+1) GISFILEID
 READ(IU,POS= 38+1) PROJECTION
 DO I = 1, NPT
  IF(PTVAL(I).EQ.PROJECTION)THEN
   WRITE(*,*) 'PROJECTION: ',TRIM(PTSTR(I))
  END IF  
 END DO   

 READ(IU,POS= 40+1) ATTRTABLE
 READ(IU,POS= 44+1) DATATYPE
 READ(IU,POS= 46+1) BYTEORDER
 !## Raster header
 READ(IU,POS= 64+1) VALUESCALE
 READ(IU,POS= 66+1) CELLREPR
 
 DO I = 1, NCR
  IF(CRVAL(I).EQ.CELLREPR)THEN
   WRITE(*,*) 'CELL REPRESENTATION: ',TRIM(CRSTR(I))
   CELLREPR=I
   EXIT
  END IF   
 END DO
 
 SELECT CASE(CELLREPR)
 CASE(CR_INT4)
  READ(IU,POS= 68+1) I4MINVAL
  READ(IU,POS= 76+1) I4MAXVAL
 CASE(CR_REAL4)
  READ(IU,POS= 68+1) R4MINVAL
  READ(IU,POS= 76+1) R4MAXVAL
 CASE DEFAULT
  WRITE(*,*) 'NOT SUPPORTED'
  STOP 1
 END SELECT
 
 READ(IU,POS= 84+1) XUL
 READ(IU,POS= 92+1) YUL
 READ(IU,POS=100+1) NRROWS
 READ(IU,POS=104+1) NRCOLS
 READ(IU,POS=108+1) CELLSIZEX
 READ(IU,POS=116+1) CELLSIZEY

 !## nodata is optional
 NODATA = 999.0

 ALLOCATE(IDF(1)); CALL IDFNULLIFY(IDF(1))
 IDF(1)%NCOL=NRCOLS; IDF(1)%NROW=NRROWS
 IDF(1)%XMIN=XUL; IDF(1)%XMAX=XUL+NRCOLS*CELLSIZEX
 IDF(1)%YMIN=YUL; IDF(1)%YMAX=YUL+NRROWS*CELLSIZEY
 IDF(1)%NODATA=NODATA  
 IDF(1)%IEQ=0
 IDF(1)%DX=CELLSIZEX; IDF(1)%DY=CELLSIZEY
 IDF(1)%IXV=INT(0,1); IDF(1)%ITB=INT(0,1)
 IF(.NOT.IDFALLOCATEX(IDF(1)))THEN
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'iMOD cannot allocated enough memory'//CHAR(13)// &
   'ncol/nrow= '//TRIM(ITOS(NRCOLS))//'-'//TRIM(ITOS(NRROWS)),'Error')
  CLOSE(IU); DEALLOCATE(IDF); RETURN
 ENDIF
  
 !## read data block
 SELECT CASE(CELLREPR)
  !## integer map file
  CASE(CR_INT4)
   ALLOCATE(I4A(NRCOLS,NRROWS))
   READ(IU,POS=256+1) ((I4A(ICOL,IROW),IROW=1,NRROWS),ICOL=1,NRCOLS)
   !## copy in IDF object
   IDF(1)%X=REAL(I4A)
   DEALLOCATE(I4A)
  !## real map file   
  CASE(CR_REAL4)
   READ(IU,POS=256+1)((IDF(1)%X(ICOL,IROW),IROW=1,NRROWS),ICOL=1,NRCOLS)  
 END SELECT

 !## replace nan with nodata
 DO IROW=1,NRROWS; DO ICOL=1,NRCOLS
  IF(IEEE_IS_NAN(IDF(1)%X(ICOL,IROW)))IDF(1)%X(ICOL,IROW)=NODATA 
 ENDDO; ENDDO

 CLOSE(IU)

 !## write comment
 CALL IDFFILLCOMMENT(IDF(1),'IMPORTED FROM '//TRIM(IDFNAME))
 J=INDEXNOCASE(IDFNAME,'.',.TRUE.)-1
 !## write idf file
 IF(.NOT.IDFWRITE(IDF(1),IDFNAME(:J)//'.IDF',1))THEN; ENDIF
 
 CALL IDFDEALLOCATE(IDF,SIZE(IDF)); DEALLOCATE(IDF)
 
 IERROR=0
 
 END SUBROUTINE MAP2IDF_IMPORTMAP
 
END MODULE MOD_MAP2IDF  
