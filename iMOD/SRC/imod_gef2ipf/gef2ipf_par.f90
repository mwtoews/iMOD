!!  Copyright (C) Stichting Deltares, 2005-2016.
!!
!!  This file is part of iMOD.
!!
!!  This program is free software: you can redistribute it and/or modify
!!  it under the terms of the GNU General Public License as published by
!!  the Free Software Foundation, either version 3 of the License, or
!!  (at your option) any later version.
!!
!!  This program is distributed in the hope that it will be useful,
!!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!  GNU General Public License for more details.
!!
!!  You should have received a copy of the GNU General Public License
!!  along with this program.  If not, see <http://www.gnu.org/licenses/>.
!!
!!  Contact: imod.support@deltares.nl
!!  Stichting Deltares
!!  P.O. Box 177
!!  2600 MH Delft, The Netherlands.
!!
MODULE MOD_GEF2IPF_PAR

USE WINTERACTER, ONLY : IOSDIRENTRYTYPE,IOSDIRCOUNT
USE MOD_PREF_PAR, ONLY : PREFVAL
USE MOD_UTL, ONLY : ITOS,RTOS,UTL_GETUNIT,UTL_CAP,IOSDIRMAKE,UTL_DIRINFO

CHARACTER(LEN=256),DIMENSION(:),POINTER :: GEFNAMES
CHARACTER(LEN=50),DIMENSION(:),ALLOCATABLE :: ATTRIB1,ATTRIB2
INTEGER,DIMENSION(:),ALLOCATABLE :: IATTRIB
REAL,DIMENSION(:),ALLOCATABLE :: NODATA
REAL,ALLOCATABLE,DIMENSION(:,:) :: GEF
CHARACTER(LEN=52),ALLOCATABLE,DIMENSION(:,:) :: GEF2,GEFEX
CHARACTER(LEN=256) :: GEFDIR,IPFFNAME,GENFNAME
CHARACTER(LEN=50) :: CID
REAL :: X,Y,ZEND,Z
INTEGER :: N,NCOL,NROW,IU,JU
REAL,DIMENSION(:),ALLOCATABLE :: FMULT
INTEGER,DIMENSION(100) :: NCOLLINE

CONTAINS

 !###====================================================================
 LOGICAL FUNCTION LREADGEF_CPT(INAME,ESTRING)
 !###====================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: INAME
 CHARACTER(LEN=*),INTENT(OUT) :: ESTRING
 INTEGER :: I,ICOL,IROW,IOS
 CHARACTER(LEN=50) :: STRING
 CHARACTER(LEN=256) :: LINE
 INTEGER,PARAMETER :: NCOLIPF=5
 
 LREADGEF_CPT=.FALSE.

 IU=UTL_GETUNIT(); OPEN(IU,FILE=GEFNAMES(INAME),STATUS='OLD',ACTION='READ')

 IF(.NOT.LREADKEYWORD('#TESTID=',STRING,0,ESTRING))RETURN
 READ(STRING,*,IOSTAT=IOS) CID
 IF(IOS.NE.0)THEN
  ESTRING='#TESTID NOT READ PROPERLY '//TRIM(GEFNAMES(INAME))
  CLOSE(IU); RETURN
 ENDIF

 IF(.NOT.LREADKEYWORD('#COLUMN=',STRING,0,ESTRING))RETURN
 READ(STRING,*,IOSTAT=IOS) NCOL
 IF(IOS.NE.0)THEN
  ESTRING='#COLUMN NOT READ PROPERLY '//TRIM(GEFNAMES(INAME))
  CLOSE(IU); RETURN
 ENDIF
 ALLOCATE(ATTRIB1(MAX(NCOLIPF,NCOL)),ATTRIB2(MAX(NCOLIPF,NCOL)),IATTRIB(NCOLIPF),NODATA(MAX(NCOLIPF,NCOL)),FMULT(NCOLIPF))
 DO I=1,NCOL
  IF(.NOT.LREADKEYWORD('#COLUMNINFO='//TRIM(ITOS(I))//',',STRING,0,ESTRING))STOP
  READ(STRING,*,IOSTAT=IOS) ATTRIB1(I),ATTRIB2(I)
  IF(IOS.NE.0)THEN
   ESTRING='#COLUMNINFO='//TRIM(ITOS(I))//' NOT READ PROPERLY '//TRIM(GEFNAMES(INAME))
   CLOSE(IU); RETURN
  ENDIF
 END DO

 !## option
 NODATA=-999.99
 DO I=1,NCOL
  IF(LREADKEYWORD('#COLUMNVOID='//TRIM(ITOS(I))//',',STRING,1,ESTRING))THEN
   READ(STRING,*,IOSTAT=IOS) NODATA(I)
   IF(IOS.NE.0)THEN
    ESTRING='#COLUMNVOID='//TRIM(ITOS(I))//' NOT READ PROPERLY '//TRIM(GEFNAMES(INAME))
    CLOSE(IU); RETURN
   ENDIF
  ENDIF
 END DO

 IF(.NOT.LREADKEYWORD('#XYID=',STRING,0,ESTRING))RETURN
 READ(STRING,*,IOSTAT=IOS) X,X,Y
 IF(IOS.NE.0)THEN
  ESTRING='#XYID NOT READ PROPERLY '//TRIM(GEFNAMES(INAME))
  CLOSE(IU); RETURN
 ENDIF
 IF(X.LT.0.0)THEN
  X=X+155000.0
  Y=Y+463000.0
 ENDIF
 IF(.NOT.LREADKEYWORD('#ZID=',STRING,0,ESTRING))RETURN
 READ(STRING,*,IOSTAT=IOS) Z,Z
 IF(IOS.NE.0)THEN
  ESTRING='#ZID NOT READ PROPERLY '//TRIM(GEFNAMES(INAME))
  CLOSE(IU); RETURN
 ENDIF
 IF(.NOT.LREADKEYWORD('#LASTSCAN=',STRING,0,ESTRING))RETURN
 READ(STRING,*) NROW
 IF(IOS.NE.0)THEN
  ESTRING='#LASTSCAN NOT READ PROPERLY '//TRIM(GEFNAMES(INAME))
  CLOSE(IU); RETURN
 ENDIF
 IF(NROW.EQ.0)THEN
  ESTRING='NO DATA IN FILE '//TRIM(GEFNAMES(INAME))
  CLOSE(IU); RETURN
 ENDIF
 ALLOCATE(GEF(NCOL,NROW))

 !## data starts
 IF(.NOT.LREADKEYWORD('EOH=',STRING,0,ESTRING))THEN
  ESTRING='EOH NOT READ PROPERLY '//TRIM(GEFNAMES(INAME))
  CLOSE(IU); RETURN
 ENDIF
 DO IROW=1,NROW
  READ(IU,'(A256)',IOSTAT=IOS) LINE
  IF(IOS.NE.0)THEN
   ESTRING='File not fully available '//TRIM(GEFNAMES(INAME))
   CLOSE(IU); RETURN
  ENDIF

  DO
   I=INDEX(LINE,';')
   IF(I.EQ.0)EXIT
   LINE(I:I)=','
  ENDDO
  
  READ(LINE,*,IOSTAT=IOS) (GEF(ICOL,IROW),ICOL=1,NCOL)
  IF(IOS.NE.0)THEN
   ESTRING='File not fully available '//TRIM(GEFNAMES(INAME))
   CLOSE(IU); RETURN
  ENDIF
 END DO

 CLOSE(IU)

 LREADGEF_CPT=.TRUE.

 END FUNCTION LREADGEF_CPT

 !###====================================================================
 LOGICAL FUNCTION LREADGEF_BORE(INAME,ESTRING)
 !###====================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: INAME
 CHARACTER(LEN=*),INTENT(OUT) :: ESTRING
 INTEGER :: I,ICOL,IROW,IOS
 CHARACTER(LEN=50) :: STRING
 CHARACTER(LEN=256) :: LINE
 INTEGER,PARAMETER :: NCOLIPF=21
 
 LREADGEF_BORE=.FALSE.

 IU=UTL_GETUNIT(); OPEN(IU,FILE=GEFNAMES(INAME),STATUS='OLD',ACTION='READ')

 IF(.NOT.LREADKEYWORD('#TESTID=',STRING,0,ESTRING))RETURN
 READ(STRING,*,IOSTAT=IOS) CID
 IF(IOS.NE.0)THEN
  ESTRING='TESTID NOT READ PROPERLY '//TRIM(GEFNAMES(INAME))
  CLOSE(IU); RETURN
 ENDIF

 IF(.NOT.LREADKEYWORD('#COLUMN=',STRING,0,ESTRING))RETURN
 READ(STRING,*,IOSTAT=IOS) NCOL
 IF(IOS.NE.0)THEN
  ESTRING='#COLUMN NOT READ PROPERLY '//TRIM(GEFNAMES(INAME))
  CLOSE(IU); RETURN
 ENDIF

 ALLOCATE(ATTRIB1(MAX(NCOLIPF,NCOL)),ATTRIB2(MAX(NCOLIPF,NCOL)),IATTRIB(NCOLIPF),NODATA(MAX(NCOLIPF,NCOL)),FMULT(NCOLIPF))
! WRITE(*,*) NCOLIPF
 DO I=1,NCOL
  IF(.NOT.LREADKEYWORD('#COLUMNINFO='//TRIM(ITOS(I))//',',STRING,0,ESTRING))STOP
  READ(STRING,*,IOSTAT=IOS) ATTRIB1(I),ATTRIB2(I)
  IF(IOS.NE.0)THEN
   ESTRING='#COLUMNINFO='//TRIM(ITOS(I))//' NOT READ PROPERLY '//TRIM(GEFNAMES(INAME))
   CLOSE(IU); RETURN
  ENDIF
 END DO

 !## option
 NODATA=-999.99
 DO I=1,NCOL
  IF(LREADKEYWORD('#COLUMNVOID='//TRIM(ITOS(I))//',',STRING,1,ESTRING))THEN
   READ(STRING,*,IOSTAT=IOS) NODATA(I)
   IF(IOS.NE.0)THEN
    ESTRING='#COLUMNVOID='//TRIM(ITOS(I))//' NOT READ PROPERLY '//TRIM(GEFNAMES(INAME))
    CLOSE(IU); RETURN
   ENDIF
  ENDIF
 END DO

 IF(.NOT.LREADKEYWORD('#XYID=',STRING,0,ESTRING))RETURN
 READ(STRING,*,IOSTAT=IOS) X,X,Y
 IF(IOS.NE.0)THEN
  ESTRING='XY NOT READ PROPERLY '//TRIM(GEFNAMES(INAME))
  CLOSE(IU); RETURN
 ENDIF
 IF(X.LT.0.0)THEN
  X=X+155000.0
  Y=Y+463000.0
 ENDIF
 IF(.NOT.LREADKEYWORD('#ZID=',STRING,0,ESTRING))RETURN
 IF(INDEX(UTL_CAP(TRIM(STRING),'U'),'NULL').GT.0)THEN
  Z=0.0
 ELSE
  READ(STRING,*,IOSTAT=IOS) Z,Z
  IF(IOS.NE.0)THEN
   ESTRING='#ZID NOT READ PROPERLY '//TRIM(GEFNAMES(INAME))
   CLOSE(IU); RETURN
  ENDIF
 ENDIF
 IF(.NOT.LREADKEYWORD('#LASTSCAN=',STRING,0,ESTRING))RETURN
 READ(STRING,*) NROW
 IF(IOS.NE.0)THEN
  ESTRING='#LASTSCAN NOT READ PROPERLY '//TRIM(GEFNAMES(INAME))
  CLOSE(IU); RETURN
 ENDIF
 IF(NROW.EQ.0)THEN
  ESTRING='NO DATA IN FILE '//TRIM(GEFNAMES(INAME))
  CLOSE(IU); RETURN
 ENDIF
 ALLOCATE(GEF(NCOL,NROW)) !##Allocate GEF-variable for real valued part IPF-file
 ALLOCATE(GEFEX(10,NROW)) !##Allocate GEF-variable for character valued part IPF-file
 
 GEFEX=''
 
 !## data starts
 IF(.NOT.LREADKEYWORD('EOH=',STRING,0,ESTRING))THEN
  ESTRING='EOH NOT READ PROPERLY '//TRIM(GEFNAMES(INAME))
  CLOSE(IU); RETURN
 ENDIF
 
 NCOLLINE=0
 DO IROW=1,NROW
  READ(IU,'(A256)',IOSTAT=IOS) LINE
  IF(IOS.NE.0)THEN
   ESTRING='File not fully available '//TRIM(GEFNAMES(INAME))
   CLOSE(IU); RETURN
  ENDIF
  
  !## Count number of columns per line and store in a the NCOLLINE variable 
  !## to be able to read all available columns (defined and undefined)
  !## per line into an ipf-file
  DO
   I=INDEX(LINE,';')
   IF(I.EQ.0)EXIT
   NCOLLINE(IROW)=NCOLLINE(IROW)+1
   LINE(I:I)=','
  ENDDO
    
  READ(LINE,*,IOSTAT=IOS) (GEF(ICOL,IROW),ICOL=1,NCOL)
  IF(IOS.NE.0)THEN
   ESTRING='File not fully available '//TRIM(GEFNAMES(INAME))
   CLOSE(IU); RETURN
  ENDIF
  ALLOCATE(GEF2(NCOLLINE(IROW),NROW)) !#GEF2=dummy array for storing whole row into an array and extract only the character part later)  
  READ(LINE,*,IOSTAT=IOS) (GEF2(ICOL,IROW),ICOL=1,NCOLLINE(IROW))
  IF(IOS.NE.0)THEN
   ESTRING='File not fully available '//TRIM(GEFNAMES(INAME))
   CLOSE(IU); RETURN
  ENDIF
  DO I=1,10
   IF((NCOLLINE(IROW)-NCOL).GE.I)THEN
    GEFEX(I,IROW)=GEF2(NCOL+I,IROW)
   ELSE
    EXIT    
   ENDIF
  ENDDO
  DEALLOCATE(GEF2)
 END DO

 DO I=NCOL+1,MAXVAL(NCOLLINE)
  IF(I.EQ.NCOL+1)THEN
   ATTRIB1(I)='[]'; ATTRIB2(I)='Lithology'
  ELSE
   ATTRIB1(I)='[]'; ATTRIB2(I)='Extra Variable'
  ENDIF
 ENDDO
 
 CLOSE(IU)
 
 LREADGEF_BORE=.TRUE.

 END FUNCTION LREADGEF_BORE

 !###====================================================================
 LOGICAL FUNCTION LREADKEYWORD(CKEY,STRING,IOPT,ESTRING)
 !###====================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IOPT
 CHARACTER(LEN=256) :: LINE
 CHARACTER(LEN=*),INTENT(OUT) :: STRING,ESTRING
 CHARACTER(LEN=*),INTENT(IN) :: CKEY
 INTEGER :: I,J,IOS

 LREADKEYWORD=.FALSE.; ESTRING=''

 REWIND(IU)
 DO
  READ(IU,'(A256)',IOSTAT=IOS) LINE
  IF(IOS.NE.0)EXIT
  !## remove spaces
  CALL LCLEAN(LINE)
  I=INDEX(UTL_CAP(LINE,'U'),CKEY)
  IF(I.NE.0)THEN
   J=LEN_TRIM(CKEY)
   STRING=LINE(I+J:)
   LREADKEYWORD=.TRUE.
   EXIT
  ENDIF
 ENDDO

 IF(IOPT.EQ.0.AND..NOT.LREADKEYWORD)THEN
  CLOSE(IU); ESTRING='KEYWORD: [ '//TRIM(CKEY)//' ] not found'
 ENDIF
 
 END FUNCTION LREADKEYWORD

 !###====================================================================
 SUBROUTINE LCLEAN(LINE)
 !###====================================================================
 IMPLICIT NONE
 CHARACTER(LEN=*),INTENT(INOUT) :: LINE
 INTEGER :: I,J

 DO
  J=LEN_TRIM(LINE)
  I=INDEX(LINE(:J),' ')
  IF(I.EQ.0)EXIT
  LINE(I:J-1)=LINE(I+1:J)
  LINE(J:)=' '
 END DO

 END SUBROUTINE LCLEAN

 !###====================================================================
 SUBROUTINE GEFDEALLOCATE()
 !###====================================================================

 IF(ALLOCATED(IATTRIB))DEALLOCATE(IATTRIB)
 IF(ALLOCATED(ATTRIB1))DEALLOCATE(ATTRIB1)
 IF(ALLOCATED(ATTRIB2))DEALLOCATE(ATTRIB2)
 IF(ALLOCATED(NODATA))DEALLOCATE(NODATA)
 IF(ALLOCATED(FMULT))DEALLOCATE(FMULT)
 IF(ALLOCATED(GEF))DEALLOCATE(GEF)
 IF(ALLOCATED(GEF2))DEALLOCATE(GEF2)
 IF(ALLOCATED(GEFEX))DEALLOCATE(GEFEX)

 END SUBROUTINE GEFDEALLOCATE

END MODULE MOD_GEF2IPF_PAR
