!!  Copyright (C) Stichting Deltares, 2005-2014.
!!
!!  This file is part of iMOD.
!!
!!  This program is free software: you can redistribute it and/or modify
!!  it under the terms of the GNU General Public License as published by
!!  the Free Software Foundation, either version 3 of the License, or
!!  (at your option) any later version.
!!
!!  This program is distributed in the hope that it will be useful,
!!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!  GNU General Public License for more details.
!!
!!  You should have received a copy of the GNU General Public License
!!  along with this program.  If not, see <http://www.gnu.org/licenses/>.
!!
!!  Contact: imod.support@deltares.nl
!!  Stichting Deltares
!!  P.O. Box 177
!!  2600 MH Delft, The Netherlands.
!!
MODULE MOD_SOLID

USE WINTERACTER
USE RESOURCE
USE IMODVAR, ONLY : IDIAGERROR
USE MODPLOT, ONLY : MXMPLOT,MP,MPW 
USE MOD_UTL, ONLY : UTL_IMODFILLMENU,ITOS,UTL_CREATEDIR,UTL_GETUNIT,UTL_MESSAGEHANDLE,NEWLINE, &
                    UTL_HIDESHOWDIALOG,UTL_CAP,UTL_READARRAY,UTL_DEL1TREE,UTL_WAITMESSAGE, &
                    UTL_INSIDEPOLYGON,CLOSEUNITS,UTL_IDFSNAPTOGRID,UTL_DIRINFO_POINTER,UTL_SUBST
USE MOD_OSD, ONLY : OSD_OPEN
USE MOD_IDF, ONLY : IDFREAD,IDFOPEN,IDFGETVAL,IDFWRITEDIM,IDFNULLIFY,IDFWRITE, &
                    IDFCOPY,IDFGETLOC,IDFIROWICOL,IDFPUTVAL,IDFALLOCATEX,IDFWRITE, &
                    IDFFILLCOMMENT,IDFREADPART,IDFDEALLOCATEX,IDFEQUAL, &
                    IDFREADSCALE,IDFDEALLOCATESX
USE IMOD, ONLY : IDFINIT
USE MOD_SOLID_PCG, ONLY : SOLID_READIDF,SOLID_CALC
USE MOD_POLYGON, ONLY : POLYGON1MAIN
USE MOD_POLYGON_DRAW, ONLY : POLYGON1DRAWSHAPE
USE MOD_POLYGON_UTL, ONLY : POLYGON1INIT,POLYGON1CLOSE,POLYGON1SAVELOADSHAPE,POLYGON1IMAGES,POLYGON1FIELDS
USE MOD_POLYGON_PAR
USE MOD_SOLID_PAR
USE MOD_SOLID_UTL
USE MOD_PROFILE, ONLY : PROFILE_INIT
USE MOD_PROF_PAR, ONLY : ISOLID 
USE MOD_SOLID_PROFILE, ONLY : SOLIDPROFILEINIT,SOLIDPROFILECLOSE
USE MOD_3D, ONLY : IMOD3D_INIT
USE MOD_MANAGER, ONLY : MANAGERDELETE,MANAGERUPDATE,MANAGERFILL,MANAGERGROUP
USE MOD_COLOURS

CHARACTER(LEN=256),PRIVATE :: SOLDIR
CHARACTER(LEN=256),DIMENSION(:),POINTER,PRIVATE :: REGISFILES

CONTAINS

 !###======================================================================
 SUBROUTINE SOLIDMAIN(ITYPE,MESSAGE)
 !###======================================================================
 IMPLICIT NONE
 TYPE(WIN_MESSAGE),INTENT(IN) :: MESSAGE
 INTEGER,INTENT(IN) :: ITYPE
 INTEGER :: IWIN
 LOGICAL :: LEX
 REAL,PARAMETER :: ZOFFSET=0.0
 
 SELECT CASE(MESSAGE%WIN)

  CASE (ID_DSOLID)
   SELECT CASE(ITYPE)
    CASE(PUSHBUTTON)
     SELECT CASE (MESSAGE%VALUE1)
      CASE (IDCANCEL)
       CALL SOLIDCLOSE()
      CASE (IDHELP)
       CALL IMODGETHELP('5.4','Solid Tool')               
     END SELECT
    CASE(TABCHANGED)
     SELECT CASE (MESSAGE%VALUE2)
      !## new tab is solids
      CASE(ID_DSOLIDTAB1)

       !## read entire sol, incl. spf-files
       IF(SOLIDOPENSOL('W',GETSOLNAME(),IQ=1,TXT='Polygons'))THEN
       ENDIF

       CALL POLYGON1DRAWSHAPE(1,SHPNO)
       !## reread sol file again
       IF(SOLIDOPENSOL('R',GETSOLNAME()))THEN
        IF(SHPNO.GT.0)THEN
         SHPIACT=0
         CALL WDIALOGSELECT(ID_DSOLIDTAB2)
         CALL WDIALOGPUTMENU(IDF_MENU1,SHPNAME,SHPNO,SHPIACT)
        ENDIF
        CALL POLYGON1DRAWSHAPE(1,SHPNO)
        CALL WDIALOGSELECT(ID_DSOLIDTAB3)
        CALL WDIALOGCLEARFIELD(IDF_MENU1)
        IF(NMASK.GT.0)CALL WDIALOGPUTMENU(IDF_MENU1,MASK%ALIAS,NMASK,1)
       ENDIF

     END SELECT
   END SELECT

  CASE (ID_DSOLIDTAB1)
   SELECT CASE(ITYPE)

    CASE(FIELDCHANGED)
     SELECT CASE (MESSAGE%VALUE2)
      !## select different solid in menu
      CASE (IDF_MENU1)
       CALL SOLID_READSOL()

     END SELECT

    CASE(PUSHBUTTON)
     SELECT CASE (MESSAGE%VALUE1)
      CASE (ID_NEW)
       CALL SOLID_NEW()
       CALL SOLID_FIELDS()
       CALL SOLID_READSOL()
      CASE (ID_PROFILE)
       CALL SOLIDPROFILE()
      CASE (ID_INFO)
       CALL WDIALOGSELECT(ID_DSOLIDTAB1)
       CALL WDIALOGGETMENU(IDF_MENU1,IWIN,FNAME)
       INQUIRE(FILE=GETSOLNAME(),EXIST=LEX)
       IF(LEX)THEN
        IWIN=0
        CALL WINDOWOPENCHILD(IWIN,FLAGS=SYSMENUON,WIDTH=1000,HEIGHT=500)
        CALL WINDOWSELECT(IWIN)
        CALL WEDITFILE(GETSOLNAME(),ITYPE=MODAL,IDMENU=0,IFONT=COURIERNEW,ISIZE=10)
       ELSE
        CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'iMOD can not find/open:'//CHAR(13)//TRIM(GETSOLNAME()),'Error')
       ENDIF
      CASE (ID_3D)
       CALL SOLID3D()
      CASE (ID_CALCULATE)
       CALL SOLID_CALC()
       CALL WINDOWSELECT(0); CALL WINDOWOUTSTATUSBAR(4,''); CALL WINDOWOUTSTATUSBAR(3,'')
      !## remove solid (incl. clean manager)
      CASE (ID_DELETE)
       CALL WDIALOGSELECT(ID_DSOLIDTAB1)
       CALL WDIALOGGETMENU(IDF_MENU1,IWIN,FNAME)
       CALL SOLIDCLEANMANAGER() !## clean manager
       CALL UTL_DEL1TREE(TRIM(PREFVAL(1))//'\SOLIDS\'//TRIM(FNAME))
       CALL SOLID_FIELDS()
     END SELECT
   END SELECT

  CASE (ID_DSOLIDTAB2)
   !## check polygon actions
   IACTSHAPES=(/3,3,1,3,3,3/)
   CALL POLYGON1MAIN(ITYPE,MESSAGE)

  !## check masks
  CASE (ID_DSOLIDTAB3)
   SELECT CASE(ITYPE)

    CASE(FIELDCHANGED)
     SELECT CASE (MESSAGE%VALUE2)
     END SELECT

    CASE(PUSHBUTTON)
     SELECT CASE (MESSAGE%VALUE1)
      CASE (ID_NEW)
       IF(SOLID_NEWMASKS(ZOFFSET))THEN; ENDIF
      CASE (ID_OPENIDF)
      CASE (ID_INFO)
       CALL WDIALOGSELECT(ID_DSOLIDTAB3)
       CALL WDIALOGGETMENU(IDF_MENU1,IWIN,FNAME)
      CASE (ID_DELETE)
       CALL WDIALOGSELECT(ID_DSOLIDTAB3)
       CALL WDIALOGGETMENU(IDF_MENU1,IWIN,FNAME)
       CALL SOLID_FIELDS()
     END SELECT
   END SELECT

 END SELECT

 END SUBROUTINE SOLIDMAIN

 !###======================================================================
 LOGICAL FUNCTION SOLID_WVP()
 !###======================================================================
 IMPLICIT NONE
 INTEGER :: I,J,N,IROW,ICOL
 REAL :: T,B
 LOGICAL :: LEX
 
 SOLID_WVP=.FALSE.

 !## use idf settings from first top() idf
 IF(MDLIDF%XMIN.EQ.MDLIDF%XMAX)THEN
  IF(.NOT.IDFREAD(TOPIDF(1),TOPIDF(1)%FNAME,0))THEN; RETURN; ENDIF
  CLOSE(TOPIDF(1)%IU); CALL IDFCOPY(TOPIDF(1),MDLIDF)
  MDLIDF%FNAME=TOPIDF(1)%FNAME
 ENDIF
 
 DO I=1,SIZE(TOPIDF)
  WRITE(*,'(A)') 'Reading '//TRIM(TOPIDF(I)%FNAME)
  CALL IDFCOPY(MDLIDF,TOPIDF(I))
  IF(.NOT.IDFREADSCALE(TOPIDF(I)%FNAME,TOPIDF(I),2,1,0.0,0))RETURN !## scale mean
 ENDDO
 DO I=1,SIZE(BOTIDF)
  WRITE(*,'(A)') 'Reading '//TRIM(BOTIDF(I)%FNAME)
  CALL IDFCOPY(MDLIDF,BOTIDF(I))
  IF(.NOT.IDFREADSCALE(BOTIDF(I)%FNAME,BOTIDF(I),2,1,0.0,0))RETURN !## scale mean
 ENDDO
 DO I=1,SIZE(CIDF)
  WRITE(*,'(A)') 'Reading '//TRIM(CIDF(I)%FNAME)
  CALL IDFCOPY(MDLIDF,CIDF(I))
  IF(.NOT.IDFREADSCALE(CIDF(I)%FNAME,CIDF(I),6,1,0.0,0))RETURN !## scale mean
 ENDDO

 N=SIZE(TOPIDF)
 DO IROW=1,MDLIDF%NROW; DO ICOL=1,MDLIDF%NCOL
  J=1; T=TOPIDF(J)%X(ICOL,IROW); B=BOTIDF(J)%X(ICOL,IROW)
  DO I=2,SIZE(TOPIDF)
   !## no thickness available and agrees minimal resistance
   LEX=TOPIDF(I)%X(ICOL,IROW).GE.BOTIDF(I-1)%X(ICOL,IROW)
   !## resistance less than minimal value (minc)
   IF(.NOT.LEX)LEX=CIDF(I-1)%X(ICOL,IROW).LE.MINC
   !## aquifer continues vertically
   IF(LEX)THEN
    B=BOTIDF(I)%X(ICOL,IROW)
   ELSE
    TOPIDF(J)%X(ICOL,IROW)=T; BOTIDF(J)%X(ICOL,IROW)=B
    J=J+1; T=TOPIDF(I)%X(ICOL,IROW); B=BOTIDF(I)%X(ICOL,IROW)
   ENDIF
  ENDDO
  TOPIDF(J)%X(ICOL,IROW)=T; BOTIDF(J)%X(ICOL,IROW)=B
  !## blank out remaining
  DO I=J+1,N; TOPIDF(I)%X(ICOL,IROW)=TOPIDF(I)%NODATA; BOTIDF(I)%X(ICOL,IROW)=BOTIDF(I)%NODATA; ENDDO
 ENDDO; ENDDO
  
 DO I=1,SIZE(TOPIDF)
  TOPIDF(I)%FNAME=TRIM(OUTPUTFOLDER)//'\top_wvp_l'//TRIM(ITOS(I))//'.idf'
  IF(IDFWRITE(TOPIDF(I),TOPIDF(I)%FNAME,1))THEN; ENDIF
  BOTIDF(I)%FNAME=TRIM(OUTPUTFOLDER)//'\bot_wvp_l'//TRIM(ITOS(I))//'.idf'
  IF(IDFWRITE(BOTIDF(I),BOTIDF(I)%FNAME,1))THEN; ENDIF
 ENDDO
 
 CALL IDFDEALLOCATE(TOPIDF,SIZE(TOPIDF)); DEALLOCATE(TOPIDF)
 CALL IDFDEALLOCATE(BOTIDF,SIZE(BOTIDF)); DEALLOCATE(BOTIDF)
 CALL IDFDEALLOCATE(CIDF  ,SIZE(CIDF  )); DEALLOCATE(CIDF  )
 
 SOLID_WVP=.TRUE.
 
 END FUNCTION SOLID_WVP

 !###======================================================================
 LOGICAL FUNCTION SOLID_GEOTOP()
 !###======================================================================
 IMPLICIT NONE
 INTEGER :: I,J,IROW,ICOL,ILAY,JLAY,IL,IU
 REAL :: D,K,C1,C2,C3,TP,BT
 
 SOLID_GEOTOP=.FALSE.
 
 CALL UTL_CREATEDIR(RESULTFOLDER)
 CALL UTL_CREATEDIR(TRIM(RESULTFOLDER)//'\top')
 CALL UTL_CREATEDIR(TRIM(RESULTFOLDER)//'\bot')
 CALL UTL_CREATEDIR(TRIM(RESULTFOLDER)//'\kdw')
 CALL UTL_CREATEDIR(TRIM(RESULTFOLDER)//'\vcw')
 CALL UTL_CREATEDIR(TRIM(RESULTFOLDER)//'\bnd') 
 CALL UTL_CREATEDIR(TRIM(RESULTFOLDER)//'\shd') 
 
 !## use idf settings from first top() idf
 IF(MDLIDF%XMIN.EQ.MDLIDF%XMAX)THEN
  IF(.NOT.IDFREAD(MDLIDF,TPM(1)%FNAME,0))THEN; RETURN; ENDIF; CLOSE(MDLIDF%IU)
 ELSE
  CALL UTL_IDFSNAPTOGRID(MDLIDF%XMIN,MDLIDF%XMAX,MDLIDF%YMIN,MDLIDF%YMAX,MDLIDF%DX,MDLIDF%NCOL,MDLIDF%NROW)
 ENDIF
 
 !## reading starting head original model
 DO I=1,SIZE(SHM)
  WRITE(*,'(A)') 'Reading '//TRIM(SHM(I)%FNAME); CALL IDFCOPY(MDLIDF,SHM(I))
  IF(.NOT.IDFREADSCALE(SHM(I)%FNAME,SHM(I),2,1,0.0,0))RETURN !## scale mean
 ENDDO
 
 !## reading top original model
 DO I=1,SIZE(TPM)
  WRITE(*,'(A)') 'Reading '//TRIM(TPM(I)%FNAME); CALL IDFCOPY(MDLIDF,TPM(I))
  IF(.NOT.IDFREADSCALE(TPM(I)%FNAME,TPM(I),2,1,0.0,0))RETURN !## scale mean
 ENDDO
 !## reading bottom original model
 DO I=1,SIZE(BTM)
  WRITE(*,'(A)') 'Reading '//TRIM(BTM(I)%FNAME); CALL IDFCOPY(MDLIDF,BTM(I))
  IF(.NOT.IDFREADSCALE(BTM(I)%FNAME,BTM(I),2,1,0.0,0))RETURN !## scale mean
 ENDDO
 !## reading boundary condition original model
 DO I=1,SIZE(IBM)
  WRITE(*,'(A)') 'Reading '//TRIM(IBM(I)%FNAME); CALL IDFCOPY(MDLIDF,IBM(I))
  IF(.NOT.IDFREADSCALE(IBM(I)%FNAME,IBM(I),1,1,0.0,0))RETURN !## scale boundary
 ENDDO
 !## reading horizontal permeability original model
 DO I=1,SIZE(KHM)
  WRITE(*,'(A)') 'Reading '//TRIM(KHM(I)%FNAME); CALL IDFCOPY(MDLIDF,KHM(I))
  IF(.NOT.IDFREADSCALE(KHM(I)%FNAME,KHM(I),3,1,0.0,0))RETURN !## scale geometric
 ENDDO
 !## reading vertical anisotropy original model
 DO I=1,SIZE(KAM)
  WRITE(*,'(A)') 'Reading '//TRIM(KAM(I)%FNAME); CALL IDFCOPY(MDLIDF,KAM(I))
  IF(.NOT.IDFREADSCALE(KAM(I)%FNAME,KAM(I),2,1,0.0,0))RETURN !## scale mean
 ENDDO
 !## reading vertical permeability original model
 DO I=1,NLAYM-1 
  WRITE(*,'(A)') 'Reading '//TRIM(KVM(I)%FNAME); CALL IDFCOPY(MDLIDF,KVM(I))
  IF(.NOT.IDFREADSCALE(KVM(I)%FNAME,KVM(I),3,1,0.0,0))RETURN !## scale geometric
 ENDDO
 CALL IDFNULLIFY(KVM(NLAYM)); CALL IDFCOPY(KVM(1),KVM(NLAYM))
 
 !## reading KH-GeoTOP
 DO I=1,SIZE(KHG)
  WRITE(*,'(A)') 'Reading '//TRIM(KHG(I)%FNAME); CALL IDFCOPY(MDLIDF,KHG(I))
  IF(.NOT.IDFREADSCALE(KHG(I)%FNAME,KHG(I),3,1,0.0,0))RETURN !## scale geometric
 ENDDO
 !## reading KV-GeoTOP
 DO I=1,SIZE(KVG)
  WRITE(*,'(A)') 'Reading '//TRIM(KVG(I)%FNAME); CALL IDFCOPY(MDLIDF,KVG(I))
  IF(.NOT.IDFREADSCALE(KVG(I)%FNAME,KVG(I),3,1,0.0,0))RETURN !!## scale geometric
 ENDDO
 ALLOCATE(IBG(NLAYG),SHG(NLAYG))
 DO I=1,NLAYG; CALL IDFNULLIFY(IBG(I)); CALL IDFCOPY(KVG(1),IBG(I)); ENDDO
 DO I=1,NLAYG; CALL IDFNULLIFY(SHG(I)); CALL IDFCOPY(KVG(1),SHG(I)); ENDDO

 !## determine lower boundary of GeoTOP (voxels)
 DO IROW=1,MDLIDF%NROW; DO ICOL=1,MDLIDF%NCOL
  !## fill in remainder of GeoTOP-voxels on the bottom
  DO I=SIZE(KHG),1,-1
   IF(KHG(I)%X(ICOL,IROW).GT.0.0)EXIT
   DO J=1,SIZE(TPM)
    IF(TPM(J)%X(ICOL,IROW).GE.KHG(I)%BOT.AND.BTM(J)%X(ICOL,IROW).LE.KHG(I)%TOP)THEN
     KHG(I)%X(ICOL,IROW)=KHM(J)%X(ICOL,IROW)
     KVG(I)%X(ICOL,IROW)=KHM(J)%X(ICOL,IROW)*KAM(J)%X(ICOL,IROW)
    ENDIF
   ENDDO
  ENDDO
  !## fill in startingheads/boundary condition for GeoTOP voxels
  DO I=1,SIZE(KHG)
   DO J=1,SIZE(TPM)
    TP=TPM(J)%X(ICOL,IROW)
    IF(J.LT.SIZE(TPM))THEN; BT=TPM(J+1)%X(ICOL,IROW); ELSE; BT=BTM(J)%X(ICOL,IROW); ENDIF
    IF(TP.GE.KHG(I)%BOT.AND.BT.LE.KHG(I)%TOP)THEN
     SHG(I)%X(ICOL,IROW)=SHM(J)%X(ICOL,IROW); SHG(I)%NODATA=SHM(J)%NODATA
     IBG(I)%X(ICOL,IROW)=IBM(J)%X(ICOL,IROW)
    ENDIF
   ENDDO
  ENDDO
  
  !## correct top/bottoms for original model for GeoTOP
  I=NLAYG
  DO J=1,SIZE(TPM)
   !## adjust appropriate top of original model
   IF(TPM(J)%X(ICOL,IROW).GT.KHG(I)%BOT)TPM(J)%X(ICOL,IROW)=KHG(I)%BOT
   IF(BTM(J)%X(ICOL,IROW).GT.KHG(I)%BOT)BTM(J)%X(ICOL,IROW)=KHG(I)%BOT
   !## make khm.eq.0.0 for zero thicknesses
   IF(TPM(J)%X(ICOL,IROW)-BTM(J)%X(ICOL,IROW).LE.0.0)THEN
    KHM(J)%X(ICOL,IROW)=0.0; KVM(J)%X(ICOL,IROW)=0.0; KAM(J)%X(ICOL,IROW)=0.0
   ENDIF
  ENDDO
 ENDDO; ENDDO
 
 IF(.NOT.IDFALLOCATEX(MDLIDF))RETURN; ALLOCATE(IBND(MDLIDF%NCOL,MDLIDF%NROW))
 
 !## search first active modellayer
 ILAY=1
ILLOOP: DO
  DO IROW=1,MDLIDF%NROW; DO ICOL=1,MDLIDF%NCOL; IF(KHG(ILAY)%X(ICOL,IROW).GT.0.0)EXIT ILLOOP; ENDDO; ENDDO
  ILAY=ILAY+1; IF(ILAY.GT.NLAYG)EXIT
 ENDDO ILLOOP
 ILAY=ILAY-1

 WRITE(*,'(A,I3,A)') 'Start with layer ',ILAY+1,' from GeoTOP, assigned first active modellayer'
 
 !## continue until finished
 JLAY=0; IL=0; DO
  ILAY=ILAY+1; IL=IL+1
  IF(JLAY.GE.NLAYM)EXIT
  
  !## process geotop files
  IF(ILAY.LE.NLAYG)THEN

   !## write top
   MDLIDF%X=KHG(ILAY)%TOP; MDLIDF%FNAME=TRIM(RESULTFOLDER)//'\top\top_l'//TRIM(ITOS(IL))//'.idf'
   MDLIDF%NODATA=-999.99; IF(.NOT.IDFWRITE(MDLIDF,MDLIDF%FNAME,1))RETURN
   !## write bottom
   MDLIDF%X=KHG(ILAY)%BOT; MDLIDF%FNAME=TRIM(RESULTFOLDER)//'\bot\bot_l'//TRIM(ITOS(IL))//'.idf'
   MDLIDF%NODATA=-999.99; IF(.NOT.IDFWRITE(MDLIDF,MDLIDF%FNAME,1))RETURN
   !## compute transmissivity
   MDLIDF%NODATA=0.0
   DO IROW=1,MDLIDF%NROW; DO ICOL=1,MDLIDF%NCOL
    MDLIDF%X(ICOL,IROW)=(KHG(ILAY)%TOP-KHG(ILAY)%BOT)*KHG(ILAY)%X(ICOL,IROW)
    IF(KHG(ILAY)%X(ICOL,IROW).EQ.KHG(ILAY)%NODATA)MDLIDF%X(ICOL,IROW)=MDLIDF%NODATA
   ENDDO; ENDDO
   MDLIDF%FNAME=TRIM(RESULTFOLDER)//'\kdw\kdw_l'//TRIM(ITOS(IL))//'.idf'
   MDLIDF%ITB=1; MDLIDF%TOP=KHG(ILAY)%TOP ; MDLIDF%BOT=KHG(ILAY)%BOT
   MDLIDF%NODATA=0.0; IF(.NOT.IDFWRITE(MDLIDF,MDLIDF%FNAME,1))RETURN
   !## compute vertical resistance for previous modellayer
   IF(ILAY.GT.1)THEN
    DO IROW=1,MDLIDF%NROW; DO ICOL=1,MDLIDF%NCOL
     C1=0.0; IF(KVG(ILAY-1)%X(ICOL,IROW).GT.0.0)C1=(KHG(ILAY-1)%TOP-KHG(ILAY-1)%BOT)/KVG(ILAY-1)%X(ICOL,IROW)
     C2=0.0; IF(KVG(ILAY  )%X(ICOL,IROW).GT.0.0)C2=(KHG(ILAY  )%TOP-KHG(ILAY  )%BOT)/KVG(ILAY  )%X(ICOL,IROW)
     MDLIDF%X(ICOL,IROW)=0.5*C1+0.5*C2
    ENDDO; ENDDO
    MDLIDF%FNAME=TRIM(RESULTFOLDER)//'\vcw\vcw_l'//TRIM(ITOS(IL-1))//'.idf'
    MDLIDF%ITB=1; MDLIDF%TOP=(KHG(ILAY-1)%TOP+KHG(ILAY-1)%BOT)/2.0 ; MDLIDF%BOT=(KHG(ILAY)%TOP+KHG(ILAY)%BOT)/2.0
    MDLIDF%NODATA=0.0; IF(.NOT.IDFWRITE(MDLIDF,MDLIDF%FNAME,1))RETURN
   ENDIF

   !## compute boundary based on GeoTop
   IBND=INT(0,1)
   DO IROW=1,MDLIDF%NROW; DO ICOL=1,MDLIDF%NCOL
    IF(KHG(ILAY)%X(ICOL,IROW).GT.0.0.AND.IBG(ILAY)%X(ICOL,IROW).GT.0)IBND(ICOL,IROW)=INT(1,1)
   ENDDO; ENDDO
   DO ICOL=1,MDLIDF%NCOL
    IF(KHG(ILAY)%X(ICOL,1          ).GT.1.0.AND.IBND(ICOL,1          ).GT.0)IBND(ICOL,1          )=INT(-1,1)
    IF(KHG(ILAY)%X(ICOL,MDLIDF%NROW).GT.1.0.AND.IBND(ICOL,MDLIDF%NROW).GT.0)IBND(ICOL,MDLIDF%NROW)=INT(-1,1)
   ENDDO
   DO IROW=1,MDLIDF%NROW
    IF(KHG(ILAY)%X(1,IROW          ).GT.1.0.AND.IBND(1,IROW          ).GT.0)IBND(1,IROW          )=INT(-1,1)
    IF(KHG(ILAY)%X(MDLIDF%NCOL,IROW).GT.1.0.AND.IBND(MDLIDF%NCOL,IROW).GT.0)IBND(MDLIDF%NCOL,IROW)=INT(-1,1)
   ENDDO
   !## make sure that for constant heads, true heads are available
   DO IROW=1,MDLIDF%NROW; DO ICOL=1,MDLIDF%NCOL
    IF(IBND(ICOL,IROW).LT.INT(0,1).AND.SHG(ILAY)%X(ICOL,IROW).EQ.SHG(ILAY)%NODATA)IBND(ICOL,IROW)=INT(1,1)
    IF(IBND(ICOL,IROW).GT.INT(1,1).AND.SHG(ILAY)%X(ICOL,IROW).EQ.SHG(ILAY)%NODATA)SHG(ILAY)%X(ICOL,IROW)=0.0
   ENDDO; ENDDO
   
   MDLIDF%NODATA=0.0; MDLIDF%FNAME=TRIM(RESULTFOLDER)//'\bnd\bnd_l'//TRIM(ITOS(IL))//'.idf'
   MDLIDF%ITB=1; MDLIDF%TOP=KHG(ILAY)%TOP ; MDLIDF%BOT=KHG(ILAY)%BOT
   MDLIDF%X=REAL(IBND); IF(.NOT.IDFWRITE(MDLIDF,MDLIDF%FNAME,1))RETURN
   MDLIDF%NODATA=SHG(ILAY)%NODATA; MDLIDF%FNAME=TRIM(RESULTFOLDER)//'\shd\shd_l'//TRIM(ITOS(IL))//'.idf'
   MDLIDF%X=SHG(ILAY)%X; IF(.NOT.IDFWRITE(MDLIDF,MDLIDF%FNAME,1))RETURN
  
  ELSE

   !## search first active modellayer
   IF(JLAY.EQ.0)THEN
    DO; IF(SUM(KHM(JLAY+1)%X).GT.0.0)EXIT; JLAY=JLAY+1; ENDDO
    WRITE(*,'(A,I3,A)') 'Start with layer ',JLAY+1,' from ORIGINAL model (previous layers filled in by GeoTOP'
   ENDIF
   JLAY=JLAY+1  

   !## write top
   MDLIDF%X=TPM(JLAY)%X; MDLIDF%FNAME=TRIM(RESULTFOLDER)//'\top\top_l'//TRIM(ITOS(IL))//'.idf'
   MDLIDF%ITB=0; MDLIDF%NODATA=-999.99; IF(.NOT.IDFWRITE(MDLIDF,MDLIDF%FNAME,1))RETURN
   !## write bottom 
   MDLIDF%X=BTM(JLAY)%X; MDLIDF%FNAME=TRIM(RESULTFOLDER)//'\bot\bot_l'//TRIM(ITOS(IL))//'.idf'
   MDLIDF%NODATA=-999.99; IF(.NOT.IDFWRITE(MDLIDF,MDLIDF%FNAME,1))RETURN
   !## compute transmissivity
   DO IROW=1,MDLIDF%NROW; DO ICOL=1,MDLIDF%NCOL
    MDLIDF%X(ICOL,IROW)=(TPM(JLAY)%X(ICOL,IROW)-BTM(JLAY)%X(ICOL,IROW))*KHM(JLAY)%X(ICOL,IROW)
   ENDDO; ENDDO
   MDLIDF%FNAME=TRIM(RESULTFOLDER)//'\kdw\kdw_l'//TRIM(ITOS(IL))//'.idf'
   MDLIDF%NODATA=-999.99; IF(.NOT.IDFWRITE(MDLIDF,MDLIDF%FNAME,1))RETURN
   !## compute vertical resistance
   DO IROW=1,MDLIDF%NROW; DO ICOL=1,MDLIDF%NCOL
    IF(ILAY-1.EQ.NLAYG)THEN
     C1=0.0; K=KVG(ILAY-1)%X(ICOL,IROW); IF(K.GT.0.0)C1=(KHG(ILAY-1)%TOP-KHG(ILAY-1)%BOT)/K
    ELSE
     C1=0.0; K=KHM(JLAY-1)%X(ICOL,IROW)*KAM(JLAY-1)%X(ICOL,IROW)
     IF(K.GT.0.0)C1=(TPM(JLAY-1)%X(ICOL,IROW)-BTM(JLAY-1)%X(ICOL,IROW))/K
    ENDIF
    C2=0.0; K=KHM(JLAY)%X(ICOL,IROW)*KAM(JLAY)%X(ICOL,IROW)
    IF(K.GT.0.0)C2=(TPM(JLAY)%X(ICOL,IROW)-BTM(JLAY)%X(ICOL,IROW))/K
    C3=0.0; K=KVM(JLAY)%X(ICOL,IROW)
    IF(K.GT.0.0)C3=(BTM(JLAY-1)%X(ICOL,IROW)-TPM(JLAY)%X(ICOL,IROW))/K
    MDLIDF%X(ICOL,IROW)=0.5*C1+0.5*C2+C3
   ENDDO; ENDDO
   MDLIDF%FNAME=TRIM(RESULTFOLDER)//'\vcw\vcw_l'//TRIM(ITOS(IL-1))//'.idf'
   MDLIDF%NODATA=0.0; IF(.NOT.IDFWRITE(MDLIDF,MDLIDF%FNAME,1))RETURN

   !## compute boundary, constant head around (optional)
   IBND=INT(0,1)
   DO IROW=1,MDLIDF%NROW; DO ICOL=1,MDLIDF%NCOL
    IF(IBM(JLAY)%X(ICOL,IROW).GT.0)IBND(ICOL,IROW)=INT(1,1)
   ENDDO; ENDDO
   DO ICOL=1,MDLIDF%NCOL
    IF(KHM(JLAY)%X(ICOL,1          ).GT.1.0.AND.IBND(ICOL,1          ).GT.0)IBND(ICOL,1          )=INT(-1,1)
    IF(KHM(JLAY)%X(ICOL,MDLIDF%NROW).GT.1.0.AND.IBND(ICOL,MDLIDF%NROW).GT.0)IBND(ICOL,MDLIDF%NROW)=INT(-1,1)
   ENDDO
   DO IROW=1,MDLIDF%NROW
    IF(KHM(JLAY)%X(1,IROW          ).GT.1.0.AND.IBND(1,IROW          ).GT.0)IBND(1,IROW          )=INT(-1,1)
    IF(KHM(JLAY)%X(MDLIDF%NCOL,IROW).GT.1.0.AND.IBND(MDLIDF%NCOL,IROW).GT.0)IBND(MDLIDF%NCOL,IROW)=INT(-1,1)
   ENDDO
   !## make sure that for constant heads, true heads are available
   DO IROW=1,MDLIDF%NROW; DO ICOL=1,MDLIDF%NCOL
    IF(IBND(ICOL,IROW).LT.INT(0,1).AND.SHM(JLAY)%X(ICOL,IROW).EQ.SHM(JLAY)%NODATA)IBND(ICOL,IROW)=INT(1,1)
    IF(IBND(ICOL,IROW).GT.INT(1,1).AND.SHM(JLAY)%X(ICOL,IROW).EQ.SHM(JLAY)%NODATA)SHM(JLAY)%X(ICOL,IROW)=0.0
   ENDDO; ENDDO

   !## writing boundary conditions
   MDLIDF%NODATA=0.0; MDLIDF%X=REAL(IBND); MDLIDF%FNAME=TRIM(RESULTFOLDER)//'\bnd\bnd_l'//TRIM(ITOS(IL))//'.idf'
   IF(.NOT.IDFWRITE(MDLIDF,MDLIDF%FNAME,1))RETURN
   !## write starting heads
   MDLIDF%NODATA=SHM(JLAY)%NODATA; MDLIDF%X=SHM(JLAY)%X; MDLIDF%FNAME=TRIM(RESULTFOLDER)//'\shd\shd_l'//TRIM(ITOS(IL))//'.idf'
   IF(.NOT.IDFWRITE(MDLIDF,MDLIDF%FNAME,1))RETURN

  ENDIF

 ENDDO 

 IL=IL-1; IU=UTL_GETUNIT()
 OPEN(IU,FILE=TRIM(RESULTFOLDER)//'\geotop.run',STATUS='UNKNOWN',ACTION='WRITE')
 WRITE(IU,'(I10,A)') IL,',(BND)'
 DO I=1,IL
  WRITE(IU,'(I10,A)') I,',1.0,0.0,'//TRIM(RESULTFOLDER)//'\BND\BND_L'//TRIM(ITOS(I))//'.IDF'
 ENDDO
 WRITE(IU,'(I10,A)') IL,',(SHD)'
 DO I=1,IL
  WRITE(IU,'(I10,A)') I,',1.0,0.0,'//TRIM(RESULTFOLDER)//'\SHD\SHD_L'//TRIM(ITOS(I))//'.IDF'
 ENDDO
 WRITE(IU,'(I10,A)') IL,',(TOP)'
 DO I=1,IL
  WRITE(IU,'(I10,A)') I,',1.0,0.0,'//TRIM(RESULTFOLDER)//'\TOP\TOP_L'//TRIM(ITOS(I))//'.IDF'
 ENDDO
 WRITE(IU,'(I10,A)') IL,',(BOT)'
 DO I=1,IL
  WRITE(IU,'(I10,A)') I,',1.0,0.0,'//TRIM(RESULTFOLDER)//'\BOT\BOT_L'//TRIM(ITOS(I))//'.IDF'
 ENDDO
 WRITE(IU,'(I10,A)') IL,',(KDW)'
 DO I=1,IL
  WRITE(IU,'(I10,A)') I,',1.0,0.0,'//TRIM(RESULTFOLDER)//'\KDW\KDW_L'//TRIM(ITOS(I))//'.IDF'
 ENDDO
 WRITE(IU,'(I10,A)') IL-1,',(VCW)'
 DO I=1,IL-1
  WRITE(IU,'(I10,A)') I,',1.0,0.0,'//TRIM(RESULTFOLDER)//'\VCW\VCW_L'//TRIM(ITOS(I))//'.IDF'
 ENDDO
 CLOSE(IU)
 
 SOLID_GEOTOP=.TRUE.
 
 END FUNCTION SOLID_GEOTOP

 !###======================================================================
 SUBROUTINE SOLID_GEOTOP_DEALLOCATE()
 !###======================================================================
 IMPLICIT NONE
 
 IF(ALLOCATED(KHG))THEN; CALL IDFDEALLOCATE(KHG,SIZE(KHG)); DEALLOCATE(KHG); ENDIF
 IF(ALLOCATED(KVG))THEN; CALL IDFDEALLOCATE(KVG,SIZE(KVG)); DEALLOCATE(KVG); ENDIF
 IF(ALLOCATED(SHG))THEN; CALL IDFDEALLOCATE(SHG,SIZE(SHG)); DEALLOCATE(SHG); ENDIF
 IF(ALLOCATED(IBG))THEN; CALL IDFDEALLOCATE(IBG,SIZE(IBG)); DEALLOCATE(IBG); ENDIF
 IF(ALLOCATED(KHM))THEN; CALL IDFDEALLOCATE(KHM,SIZE(KHM)); DEALLOCATE(KHM); ENDIF
 IF(ALLOCATED(KVM))THEN; CALL IDFDEALLOCATE(KVM,SIZE(KVM)); DEALLOCATE(KVM); ENDIF
 IF(ALLOCATED(KAM))THEN; CALL IDFDEALLOCATE(KAM,SIZE(KAM)); DEALLOCATE(KAM); ENDIF
 IF(ALLOCATED(SHM))THEN; CALL IDFDEALLOCATE(SHM,SIZE(SHM)); DEALLOCATE(SHM); ENDIF
 IF(ALLOCATED(IBM))THEN; CALL IDFDEALLOCATE(IBM,SIZE(IBM)); DEALLOCATE(IBM); ENDIF
 IF(ALLOCATED(TPM))THEN; CALL IDFDEALLOCATE(TPM,SIZE(TPM)); DEALLOCATE(TPM); ENDIF
 IF(ALLOCATED(BTM))THEN; CALL IDFDEALLOCATE(BTM,SIZE(BTM)); DEALLOCATE(BTM); ENDIF
 IF(ALLOCATED(IBND))DEALLOCATE(IBND)
 
 END SUBROUTINE SOLID_GEOTOP_DEALLOCATE

 !###======================================================================
 LOGICAL FUNCTION SOLID_NEWMASKS(ZOFFSET)
 !###======================================================================
 IMPLICIT NONE
 REAL,INTENT(IN) :: ZOFFSET
 INTEGER :: I,IROW,ICOL,IRAT,IRAT1
 REAL :: T,B
 INTEGER,ALLOCATABLE,DIMENSION(:) :: NMSK
 CHARACTER(LEN=256) :: SOLNAME,STRING

 SOLID_NEWMASKS=.FALSE.

 IF(IBATCH.EQ.0)THEN
  !## refresh memory
  CALL SOLID_DEALLOCATE()
  SOLNAME=GETSOLNAME()
  !## read all idf-files in to memory
  IF(.NOT.SOLIDOPENSOL('R',SOLNAME))RETURN
  OUTPUTFOLDER=SOLNAME(:INDEX(SOLNAME,'\',.TRUE.)-1)
 ENDIF

 !## read top/bottom idf files, determine mdlidf()
 IF(.NOT.SOLID_READIDF())RETURN
 
 NMASK=NTBSOL
 IF(ALLOCATED(MASK))THEN
  DO I=1,SIZE(MASK); CALL IDFDEALLOCATEX(MASK(I)%IDF); ENDDO; DEALLOCATE(MASK)
 ENDIF
 ALLOCATE(MASK(NMASK),NMSK(NMASK))
 DO I=1,SIZE(MASK)
  CALL IDFNULLIFY(MASK(I)%IDF)
  !## copy mdlidf setting to masks
  CALL IDFCOPY(MDLIDF,MASK(I)%IDF)
  NMSK(I)=0
 ENDDO

 !## read/scale/cut idf files for mdlidf() extent
 DO I=1,SIZE(SOLIDF)
  IF(.NOT.IDFREADSCALE(SOLIDF(I)%FNAME,MASK(I)%IDF,2,1,0.0,0))RETURN !## scale mean
 ENDDO
 
 !## process all existing aquitards to get extinction
 IRAT=0; IRAT1=IRAT
 DO IROW=1,MDLIDF%NROW
  DO ICOL=1,MDLIDF%NCOL
   DO I=2,SIZE(SOLIDF)-2,2
    !## starting heads --- top/bot sequence
    T=MASK(I)  %IDF%X(ICOL,IROW)
    B=MASK(I+1)%IDF%X(ICOL,IROW)
    MASK(I  )%IDF%X(ICOL,IROW)=1
    MASK(I+1)%IDF%X(ICOL,IROW)=1
    IF(T.NE.MASK(I)%IDF%NODATA.AND.B.NE.MASK(I+1)%IDF%NODATA)THEN
     IF(T-B.GT.ZOFFSET)THEN !## thickness aquitard
      MASK(I  )%IDF%X(ICOL,IROW)=-1
      MASK(I+1)%IDF%X(ICOL,IROW)=-1
      NMSK(I)  =NMSK(I)+1
      NMSK(I+1)=NMSK(I+1)+1
     ENDIF
    ENDIF
   END DO
  END DO
  IF(IBATCH.EQ.0)CALL UTL_WAITMESSAGE(IRAT,IRAT1,IROW,MDLIDF%NROW,'Constructing Masks ... ')
  IF(IBATCH.EQ.1)WRITE(*,'(A,I10,A)') 'Constructing Masks',(IROW*100)/MDLIDF%NROW,'%'
 ENDDO
 !## get max extinction top/bot system (use layer 1 and layer nlay to distinghuish max. size system)
 DO IROW=1,MDLIDF%NROW
  DO ICOL=1,MDLIDF%NCOL
   !## starting heads --- top/bot sequence
   T=MASK(1)     %IDF%X(ICOL,IROW)
   B=MASK(NTBSOL)%IDF%X(ICOL,IROW)
   MASK(1)%IDF%X(ICOL,IROW)=1.0
   MASK(NTBSOL)%IDF%X(ICOL,IROW)=1.0
   IF(T.NE.MASK(1)%IDF%NODATA.AND.B.NE.MASK(NTBSOL)%IDF%NODATA)THEN
    IF(T-B.LE.0.0)THEN; DO I=1,SIZE(SOLIDF); MASK(I)%IDF%X(ICOL,IROW)=0; ENDDO; ENDIF
   ELSE
    DO I=1,SIZE(SOLIDF); MASK(I)%IDF%X(ICOL,IROW)=0; ENDDO
   ENDIF
  END DO
 END DO
 DO I=1,SIZE(MASK)
  MASK(I)%FNAME=TRIM(OUTPUTFOLDER)//'\MASK\MASK_L'//TRIM(ITOS(I))//'.IDF'
  MASK(I)%ALIAS='MASK\MASK_L'//TRIM(ITOS(I))//'.IDF'
  IF(.NOT.IDFWRITE(MASK(I)%IDF,MASK(I)%FNAME,1))THEN
  ENDIF
 END DO

 CALL IDFDEALLOCATE(SOLIDF,SIZE(SOLIDF)); DEALLOCATE(SOLIDF)
 DO I=1,SIZE(MASK); CALL IDFDEALLOCATEX(MASK(I)%IDF); CALL IDFDEALLOCATESX(MASK(I)%IDF); ENDDO
 
 CALL CLOSEUNITS()

 IF(IBATCH.EQ.0)THEN
  CALL UTL_MESSAGEHANDLE(1)
  CALL WDIALOGSELECT(ID_DSOLIDTAB3)
  CALL WDIALOGCLEARFIELD(IDF_MENU1)
  IF(NMASK.GT.0)CALL WDIALOGPUTMENU(IDF_MENU1,MASK%ALIAS,NMASK,1)
 ENDIF
 STRING='Summary of masks (number of cell with thickness of aquitards):'//CHAR(13)
 IF(IBATCH.EQ.1)WRITE(*,'(A)') TRIM(STRING)
 DO I=2,SIZE(NMSK)-1,2
  IF(IBATCH.EQ.0)THEN
   STRING=TRIM(STRING)//'mask '//TRIM(ITOS(I))//'+'//TRIM(ITOS(I+1))//': '//TRIM(ITOS(NMSK(I)))//' points'//CHAR(13)
  ELSEIF(IBATCH.EQ.1)THEN
   STRING='mask '//TRIM(ITOS(I))//'+'//TRIM(ITOS(I+1))//': '//TRIM(ITOS(NMSK(I)))//' points'
   WRITE(*,'(A)') TRIM(STRING)
  ENDIF
 ENDDO
 IF(IBATCH.EQ.0)CALL WMESSAGEBOX(OKONLY,INFORMATIONICON,COMMONOK,TRIM(STRING),'Information')
 
 SOLID_NEWMASKS=.TRUE.

 END FUNCTION SOLID_NEWMASKS

 !###======================================================================
 SUBROUTINE SOLIDINIT()
 !###======================================================================
 IMPLICIT NONE

 CALL WINDOWSELECT(0)
 IF(WMENUGETSTATE(ID_SOLIDS,2).EQ.1)THEN
  CALL SOLIDCLOSE()
  RETURN
 ENDIF

 CALL MAIN1INACTMODULE(ID_SOLIDS)
 !other module no closed, no approvement given
 IF(IDIAGERROR.EQ.1)RETURN

 CALL WMENUSETSTATE(ID_SOLIDS,2,1)

 IF(.NOT.IOSDIREXISTS(TRIM(PREFVAL(1))//'\SOLIDS'))CALL UTL_CREATEDIR(TRIM(PREFVAL(1))//'\SOLIDS')

 !## initialize sld()-pointer
 CALL SOLIDINITSLD(0)
 !## initialize spf()-pointer
 CALL SOLIDINITSPF(0)

 !## initialize polygon
 CALL POLYGON1INIT()

 CALL WDIALOGLOAD(ID_DSOLID,ID_DSOLID)

 CALL WDIALOGSELECT(ID_DSOLIDTAB1)
 CALL WDIALOGPUTIMAGE(ID_NEW,ID_ICONNEW,1)
 CALL WDIALOGPUTIMAGE(ID_PROFILE,ID_ICONPROFILE,1)
 CALL WDIALOGPUTIMAGE(ID_3D,ID_ICON3DTOOL,1)
 CALL WDIALOGPUTIMAGE(ID_CALCULATE,ID_ICONCALC,1)
 CALL WDIALOGPUTIMAGE(ID_INFO,ID_ICONINFO,1)
 CALL WDIALOGPUTIMAGE(ID_DELETE,ID_ICONDELETE,1)

 CALL WDIALOGSELECT(ID_DSOLIDTAB3)
 CALL WDIALOGPUTIMAGE(ID_NEW,ID_ICONNEW,1)
 CALL WDIALOGPUTIMAGE(ID_OPENIDF,ID_ICONOPENIDF,1)
 CALL WDIALOGPUTIMAGE(ID_INFO,ID_ICONPROPERTIES,1)
 CALL WDIALOGPUTIMAGE(ID_DELETE,ID_ICONDELETE,1)

 CALL WDIALOGSELECT(ID_DSOLID)
 CALL WDIALOGTABSTATE(IDF_TAB1,ID_DSOLIDTAB2,0)
 CALL WDIALOGTABSTATE(IDF_TAB1,ID_DSOLIDTAB3,0)
 CALL WDIALOGPUTCHECKBOX(IDF_CHECK1,0) !1)
 
 CALL SOLID_FIELDS()

 !## fill polygonimages
 CALL POLYGON1IMAGES(ID_DSOLIDTAB2)
 CALL POLYGON1FIELDS(ID_DSOLIDTAB2)

 IBATCH=0
 
 CALL WDIALOGSELECT(ID_DSOLID)
 CALL WDIALOGSHOW(-1,-1,0,2)

 END SUBROUTINE SOLIDINIT

 !###======================================================================
 SUBROUTINE SOLID_READSOL()
 !###======================================================================
 IMPLICIT NONE
 INTEGER :: I,IFILL

 CALL WDIALOGSELECT(ID_DSOLID)
 CALL WDIALOGGETCHECKBOX(IDF_CHECK1,IFILL)
 
 IF(IFILL.EQ.1)CALL SOLIDCLEANMANAGER() !## clean manager
 CALL WDIALOGSELECT(ID_DSOLIDTAB2)
 CALL WDIALOGCLEARFIELD(IDF_MENU1)
 CALL WDIALOGSELECT(ID_DSOLIDTAB3)
 CALL WDIALOGCLEARFIELD(IDF_MENU1)
 I=0
 IF(SOLIDOPENSOL('R',GETSOLNAME()))THEN
  IF(SHPNO.GT.0)THEN
   CALL WDIALOGSELECT(ID_DSOLIDTAB2)
   CALL WDIALOGPUTMENU(IDF_MENU1,SHPNAME,SHPNO,SHPIACT)
  ENDIF
  CALL WDIALOGSELECT(ID_DSOLIDTAB3)
  CALL WDIALOGCLEARFIELD(IDF_MENU1)
  IF(NMASK.GT.0)CALL WDIALOGPUTMENU(IDF_MENU1,MASK%ALIAS,NMASK,1)
  !## fill imod-manager with appropriate idf files
  I=1
  IF(IFILL.EQ.1)THEN
   IF(.NOT.SOLIDFILLMANAGER())THEN
    I=0
   ELSE
    !## zoom full extent
    CALL IDFZOOM(ID_ZOOMFULLMAP,(MPW%XMAX+MPW%XMIN)/2.0,(MPW%YMAX+MPW%YMIN)/2.0,0)
    CALL IDFPLOTFAST(1)
   ENDIF
  ENDIF
 ENDIF
 
 CALL WDIALOGSELECT(ID_DSOLIDTAB1)
 CALL WDIALOGFIELDSTATE(ID_PROFILE,I)
 CALL WDIALOGFIELDSTATE(ID_3D,I)
 CALL WDIALOGFIELDSTATE(ID_CALCULATE,I)
 CALL WDIALOGSELECT(ID_DSOLID)
 CALL WDIALOGTABSTATE(IDF_TAB1,ID_DSOLIDTAB2,I)
 CALL WDIALOGTABSTATE(IDF_TAB1,ID_DSOLIDTAB3,I)

 END SUBROUTINE SOLID_READSOL

 !###======================================================================
 SUBROUTINE SOLIDCLOSE()
 !###======================================================================
 IMPLICIT NONE

 IDIAGERROR=1

 CALL POLYGON1DRAWSHAPE(1,SHPNO)
 CALL POLYGON1CLOSE()

 CALL WDIALOGSELECT(ID_DSOLID)
 CALL WDIALOGUNLOAD()
 CALL WINDOWSELECT(0)
 CALL WMENUSETSTATE(ID_SOLIDS,2,0)

 IDIAGERROR=0

 END SUBROUTINE SOLIDCLOSE

 !###======================================================================
 SUBROUTINE SOLID_FIELDS()
 !###======================================================================
 IMPLICIT NONE
 INTEGER :: N

 CALL WDIALOGSELECT(ID_DSOLIDTAB1)
 CALL UTL_IMODFILLMENU(IDF_MENU1,TRIM(PREFVAL(1))//'\SOLIDS','*','D',N,0,0)
 IF(N.EQ.0)THEN
  CALL WDIALOGFIELDSTATE(ID_PROFILE,0)
  CALL WDIALOGFIELDSTATE(ID_CALCULATE,0)
  CALL WDIALOGFIELDSTATE(ID_INFO,0)
  CALL WDIALOGFIELDSTATE(ID_3D,0)
  CALL WDIALOGFIELDSTATE(ID_DELETE,0)
 ELSE
  CALL WDIALOGFIELDSTATE(ID_INFO,1)
  CALL WDIALOGFIELDSTATE(ID_PROFILE,1)
  CALL WDIALOGFIELDSTATE(ID_CALCULATE,1)
  CALL WDIALOGFIELDSTATE(ID_3D,1)
  CALL WDIALOGFIELDSTATE(ID_DELETE,1)
 ENDIF

 END SUBROUTINE SOLID_FIELDS

 !###======================================================================
 SUBROUTINE SOLIDCLEANMANAGER()
 !###======================================================================
 IMPLICIT NONE
 INTEGER :: I,L

 IF(.NOT.ALLOCATED(SLD))RETURN

 !## nothing selected
 MP%ISEL=.FALSE.
 !## select old occurences in list
 DO I=1,SIZE(SLD)
  DO L=1,MXMPLOT
   IF(TRIM(UTL_CAP(MP(L)%IDFNAME,'U')).EQ.UTL_CAP(TRIM(PREFVAL(1))//'\TMP\'//TRIM(SLD(I)%SNAME)//'.MDF','U'))THEN
    MP(L)%ISEL=.TRUE.
   ENDIF
  ENDDO
 ENDDO

 !## select boreholes
 DO I=1,NBOREHOLES
  DO L=1,MXMPLOT
   IF(TRIM(UTL_CAP(MP(L)%IDFNAME,'U')).EQ.TRIM(UTL_CAP(FBOREHOLES(I),'U')))THEN
    MP(L)%ISEL=.TRUE.
   ENDIF
  ENDDO
 ENDDO

 !## remove existing idf from manager (to be able to put them in the right order)
 CALL MANAGERDELETE(IQ=0)

 END SUBROUTINE SOLIDCLEANMANAGER

 !###======================================================================
 LOGICAL FUNCTION SOLIDFILLMANAGER()
 !###======================================================================
 IMPLICIT NONE
 INTEGER :: I,J,K,L,II
 CHARACTER(LEN=256) :: LINE

 SOLIDFILLMANAGER=.TRUE.

 IF(.NOT.ALLOCATED(SLD))RETURN

 SOLIDFILLMANAGER=.FALSE.

 CALL SOLIDCLEANMANAGER()

 J=0; DO I=1,SIZE(SLD); J=J+SLD(I)%NLAY; ENDDO
 K=0; DO I=1,SIZE(MP); IF(MP(I)%IACT)K=K+1; ENDDO
 IF(J+K.GT.MXMPLOT)THEN
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'iMOD wants to store '//TRIM(ITOS(J+K))//' files.'//CHAR(13)// &
    'However, iMOD can store maximal '//TRIM(ITOS(MXMPLOT))//' files'//CHAR(13)//'in the iMOD Manager!','Error')
  RETURN
 ENDIF
 !## fill in manager with idf's
 DO I=1,SIZE(SLD)
  DO J=1,SLD(I)%NLAY
   !## add top
   CALL IDFINIT(SLD(I)%INTNAME(J),LPLOT=.FALSE.)
!   !## add kd (optional)
!   IF(SLD(I)%KDCLR(J).NE.0)CALL IDFINIT(SLD(I)%KDNAME(J),LPLOT=.FALSE.,LEGNAME=TRIM(KLEGEND))
!   !## add bot
!   CALL IDFINIT(SLD(I)%INTNAME(J+1),LPLOT=.FALSE.)
!   !## add c (optional)
!   IF(J.LT.SLD(I)%NLAY)THEN; IF(SLD(I)%CCLR(J).NE.0) &
!     CALL IDFINIT(SLD(I)%CNAME(J),LPLOT=.FALSE.,LEGNAME=TRIM(KLEGEND)); ENDIF
  END DO
 ENDDO
 !## select appropriate occurences in list and group them
 DO I=1,SIZE(SLD)
  !## nothing selected
  MP%ISEL=.FALSE.
  DO J=1,SLD(I)%NLAY
!   DO K=1,2
!    IF(K.EQ.1.AND.SLD(I)%KDCLR(J).NE.0)THEN
!     !## search for kd
!     DO L=1,MXMPLOT
!      IF(MP(L)%IACT)THEN
!       IF(TRIM(UTL_CAP(MP(L)%IDFNAME,'U')).EQ.TRIM(UTL_CAP(SLD(I)%KDNAME(J),'U')))THEN
!        MP(L)%ISEL=.TRUE.
!        MP(L)%SCOLOR=WRGB(255,255,255)  !## color number for serie-plotting
!        II=INDEX(SLD(I)%KDNAME(J),'\',.TRUE.)-1; II=INDEX(SLD(I)%KDNAME(J)(:II),'\',.TRUE.)+1
!        MP(L)%ALIAS=TRIM(SLD(I)%KDNAME(J)(II:))
!        CALL UTL_READARRAY((/1,0,0,0,1,0,0/),7,MP(L)%PRFTYPE) !## solid --- kd plotting!
!        EXIT
!       ENDIF
!      ENDIF
!     ENDDO
!    ENDIF
!    IF(J.LT.SLD(I)%NLAY)THEN
!     IF(K.EQ.2.AND.SLD(I)%CCLR(J).NE.0)THEN
!      !## search for c
!      DO L=1,MXMPLOT
!       IF(MP(L)%IACT)THEN
!        IF(TRIM(UTL_CAP(MP(L)%IDFNAME,'U')).EQ.TRIM(UTL_CAP(SLD(I)%CNAME(J),'U')))THEN
!         MP(L)%ISEL=.TRUE.
!         MP(L)%SCOLOR=WRGB(255,255,255)   !## color number for serie-plotting
!         II=INDEX(SLD(I)%CNAME(J),'\',.TRUE.)-1; II=INDEX(SLD(I)%CNAME(J)(:II),'\',.TRUE.)+1
!         MP(L)%ALIAS=TRIM(SLD(I)%CNAME(J)(II:))
!         CALL UTL_READARRAY((/1,0,0,0,1,1,0/),7,MP(L)%PRFTYPE) !## solid --- c plotting!
!         EXIT
!        ENDIF
!       ENDIF
!      ENDDO
!     ENDIF
!    ENDIF
   DO L=1,MXMPLOT
    IF(MP(L)%IACT)THEN
     IF(TRIM(UTL_CAP(MP(L)%IDFNAME,'U')).EQ.TRIM(UTL_CAP(SLD(I)%INTNAME(J),'U')))THEN
      MP(L)%ISEL=.TRUE.
      MP(L)%SCOLOR=SLD(I)%INTCLR(J)  !## color number for serie-plotting
      II=INDEX(SLD(I)%INTNAME(J),'\',.TRUE.)-1; LINE=SLD(I)%INTNAME(J)(:II); II=INDEX(LINE,'\',.TRUE.)+1
      LINE=SLD(I)%INTNAME(J)(II:)
      MP(L)%ALIAS=TRIM(LINE)
      IF(SLD(I)%KDCLR(J).EQ.0)THEN
       CALL UTL_READARRAY((/1,0,0,1,0,0,0/),7,MP(L)%PRFTYPE) !## solid
      ELSE
       CALL UTL_READARRAY((/1,0,0,0,0,0,0/),7,MP(L)%PRFTYPE) !## solid
      ENDIF
      EXIT
     ENDIF
    ENDIF
   ENDDO

!   ENDDO
  ENDDO

  !## group them into mdf-file
  IF(.NOT.MANAGERGROUP(INFILE=TRIM(PREFVAL(1))//'\TMP\'//TRIM(SLD(I)%SNAME)//'.MDF',LPLOT=.FALSE.))RETURN
  IF(I.EQ.1)THEN
   !## zoom full extent
   CALL IDFZOOM(ID_ZOOMFULLMAP,(MPW%XMAX+MPW%XMIN)/2.0,(MPW%YMAX+MPW%YMIN)/2.0,0)
   CALL IDFPLOTFAST(1)
  ENDIF
 ENDDO

 IF(NMASK.GT.0)THEN
  !## fill in manager with masks (why?) and group them
  DO I=1,NMASK; CALL IDFINIT(MASK(I)%FNAME,LPLOT=.FALSE.); ENDDO
  !## nothing selected
  MP%ISEL=.FALSE.
  !## select appropriate occurences in list and group them
  DO I=1,SIZE(MASK)
   DO L=1,MXMPLOT
    IF(TRIM(UTL_CAP(MP(L)%IDFNAME,'U')).EQ.TRIM(UTL_CAP(MASK(I)%FNAME,'U')))THEN
     MP(L)%ISEL=.TRUE.
    ENDIF
   ENDDO
  ENDDO
  !## group them into mdf-file
  IF(.NOT.MANAGERGROUP(INFILE=TRIM(PREFVAL(1))//'\TMP\MASK.MDF',LPLOT=.FALSE.))RETURN
 ENDIF

 !## fill in manager with boreholes
 DO I=1,NBOREHOLES; CALL IDFINIT(FBOREHOLES(I),LPLOT=.FALSE.); ENDDO
 !## select boreholes
 MP%ISEL=.FALSE.
 DO I=1,NBOREHOLES
  DO L=1,MXMPLOT
   IF(TRIM(UTL_CAP(MP(L)%IDFNAME,'U')).EQ.TRIM(UTL_CAP(FBOREHOLES(I),'U')))THEN
    MP(L)%ISEL=.TRUE.
   ENDIF
  ENDDO
 ENDDO
 !## select all group_solid{i}.mdf
 DO I=1,SIZE(SLD)
  DO L=1,MXMPLOT
   IF(TRIM(UTL_CAP(MP(L)%IDFNAME,'U')).EQ.TRIM(UTL_CAP(TRIM(PREFVAL(1))// &
     '\TMP\'//TRIM(SLD(I)%SNAME)//'.MDF','U')))THEN
    MP(L)%ISEL=.TRUE.
   ENDIF
  ENDDO
 ENDDO

 CALL MANAGERFILL()
 CALL MANAGERUPDATE()

 SOLIDFILLMANAGER=.TRUE.

 END FUNCTION SOLIDFILLMANAGER

 !###======================================================================
 SUBROUTINE SOLIDPROFILE()
 !###======================================================================
 IMPLICIT NONE

 ISOLID=0

 !## read entire sol, incl. spf-files/polygons
 IF(SOLIDOPENSOL('R',GETSOLNAME()))THEN
  CALL UTL_HIDESHOWDIALOG(ID_DSOLID,0)
  IF(SOLIDPROFILEINIT())THEN
   ISOLID=1
   CALL PROFILE_INIT()
   CALL SOLIDPROFILECLOSE()
  ENDIF
  CALL UTL_HIDESHOWDIALOG(ID_DSOLID,2)
 ENDIF

 CALL IDFPLOT(1)

 END SUBROUTINE SOLIDPROFILE

 !###======================================================================
 SUBROUTINE SOLID3D()
 !###======================================================================
 IMPLICIT NONE

 !## read entire sol, incl. spf-files
 IF(SOLIDOPENSOL('R',GETSOLNAME()))THEN
  CALL UTL_HIDESHOWDIALOG(ID_DSOLID,0)
  CALL IMOD3D_INIT(1)
!  CALL SOLIDPROFILEINIT()
!  ISOLID=1
!  CALL PROFILE_INIT()
!  CALL SOLIDPROFILECLOSE()
  CALL UTL_HIDESHOWDIALOG(ID_DSOLID,2)
 ENDIF

 END SUBROUTINE SOLID3D

 !###======================================================================
 SUBROUTINE SOLID_NEW()
 !###======================================================================
 IMPLICIT NONE
 TYPE(WIN_MESSAGE) :: MESSAGE
 INTEGER :: ITYPE,I

 CALL WDIALOGLOAD(ID_DCREATESOLID,ID_DCREATESOLID)
 CALL WDIALOGTITLE('Create New Solid')
 CALL WDIALOGPUTSTRING(IDF_GROUP2,'Select the files to be included')
 CALL WDIALOGPUTSTRING(IDF_LABEL3,'Select *.IDF-files to be included in the Solid')
 CALL WDIALOGPUTSTRING(IDF_LABEL1,'Give the name for the Solid')

 CALL WDIALOGPUTREAL(IDF_REAL1,MPW%XMIN,'(F10.2)')
 CALL WDIALOGPUTREAL(IDF_REAL2,MPW%YMIN,'(F10.2)')
 CALL WDIALOGPUTREAL(IDF_REAL3,MPW%XMAX,'(F10.2)')
 CALL WDIALOGPUTREAL(IDF_REAL4,MPW%YMAX,'(F10.2)')

 !## free all resource
 CALL SOLID_DEALLOCATE()

 !## initialize concensus modelling (if available filling sld() variables)
 IF(SOLIDINITFILES())THEN
  ISEL_SOLID=1
  ALLOCATE(JSEL_SOLID(SIZE(SLD)))
  JSEL_SOLID=0
  CALL WDIALOGPUTMENU(IDF_MENU1,SLD%SNAME,SIZE(SLD),ISEL_SOLID) !## source
  CALL WDIALOGPUTMENU(IDF_MENU2,SLD%SNAME,SIZE(SLD),JSEL_SOLID) !## support
 ELSE
  CALL WDIALOGFIELDSTATE(IDF_RADIO1,0)
  ALLOCATE(JSEL_SOLID(1)); JSEL_SOLID=-1
 ENDIF
 CALL UTL_MESSAGEHANDLE(1)

 !## idf(s) to be selected
 ALLOCATE(ILIST(MXMPLOT))
 ILIST=0

 DO I=1,MXMPLOT; IF(MP(I)%IPLOT.EQ.1)ILIST(I)=1; END DO

 IF(SUM(ILIST).EQ.0)THEN
  IF(.NOT.ALLOCATED(SLD))THEN
   CALL SOLID_DEALLOCATE()
   CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'You should open at least two IDF(s) to create a Solid file and/or'//CHAR(13)//&
     'add the keyword SOLIDTOOL in the preference file.'//CHAR(13)// &
     'See manual for more information about concensus modelling','Error')
   RETURN
  ENDIF
  !## else deactivate scratch modelling as sum(ilist)=0
  CALL WDIALOGFIELDSTATE(IDF_RADIO2,2)
  CALL WDIALOGPUTRADIOBUTTON(IDF_RADIO1)
  CALL WDIALOGCLEARFIELD(IDF_MENU3)
 ELSE
  CALL WDIALOGPUTMENU(IDF_MENU3,MP%ALIAS,MPW%NACT,ILIST)
 ENDIF

 CALL SOLID_NEW_FIELDS()
 CALL WDIALOGSHOW(-1,-1,0,3)
 DO

  CALL WMESSAGE(ITYPE,MESSAGE)
  SELECT CASE(ITYPE)

   CASE(FIELDCHANGED)
    SELECT CASE (MESSAGE%VALUE2)
     CASE (IDF_RADIO1,IDF_RADIO2,IDF_CHECK1)
      CALL SOLID_NEW_FIELDS()
    END SELECT

   CASE(PUSHBUTTON)
    SELECT CASE (MESSAGE%VALUE1)
     CASE (IDOK)
      CALL WDIALOGSELECT(ID_DCREATESOLID)
      CALL WDIALOGGETSTRING(IDF_STRING1,SOLDIR)
      IF(LEN_TRIM(SOLDIR).EQ.0)THEN
       CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'You should give a name for the Solid!','Warning')
      ELSE
       IF(SOLID_CREATE())EXIT
       CALL WMESSAGEBOX(YESNO,EXCLAMATIONICON,COMMONNO,'Solid not created, process terminated.'//CHAR(13)// &
        'Remove progress upto now?','Error')
       IF(WINFODIALOG(4).EQ.1)CALL UTL_DEL1TREE(TRIM(SOLDIR))
       !## close all files
       CALL CLOSEUNITS()
       IF(SOLIDINITFILES())THEN
       ENDIF
       CALL UTL_MESSAGEHANDLE(1)
      ENDIF
     CASE (IDCANCEL)
      EXIT
     CASE (IDHELP)
       CALL IMODGETHELP('5.4.1','Create a Solid')
    END SELECT
  END SELECT

 ENDDO

 CALL SOLID_DEALLOCATE()

 CALL WDIALOGSELECT(ID_DCREATESOLID)
 CALL WDIALOGUNLOAD()

 END SUBROUTINE SOLID_NEW

 !###======================================================================
 SUBROUTINE SOLID_NEW_FIELDS()
 !###======================================================================
 IMPLICIT NONE
 INTEGER :: I,J

 !## consensus modelling/scratch modelling
 CALL WDIALOGGETRADIOBUTTON(IDF_RADIO1,J)
 I=J-1
 CALL WDIALOGFIELDSTATE(IDF_LABEL2,J)
 CALL WDIALOGFIELDSTATE(IDF_LABEL4,J)
 CALL WDIALOGFIELDSTATE(IDF_MENU1,J)
 CALL WDIALOGFIELDSTATE(IDF_MENU2,J)
 CALL WDIALOGFIELDSTATE(IDF_LABEL3,I)
 CALL WDIALOGFIELDSTATE(IDF_MENU3,I)

 !## consensus modelling
 IF(J.EQ.1)THEN
  CALL WDIALOGPUTCHECKBOX(IDF_CHECK1,1)
  CALL WDIALOGFIELDSTATE(IDF_CHECK1,0)
  I=1
 !## scratch modelling
 ELSE
  CALL WDIALOGFIELDSTATE(IDF_CHECK1,1)
  CALL WDIALOGGETCHECKBOX(IDF_CHECK1,I)
 ENDIF

 CALL WDIALOGFIELDSTATE(IDF_REAL1,I)
 CALL WDIALOGFIELDSTATE(IDF_REAL2,I)
 CALL WDIALOGFIELDSTATE(IDF_REAL3,I)
 CALL WDIALOGFIELDSTATE(IDF_REAL4,I)
 CALL WDIALOGFIELDSTATE(IDF_LABEL5,I)
 CALL WDIALOGFIELDSTATE(IDF_LABEL6,I)
 CALL WDIALOGFIELDSTATE(IDF_LABEL7,I)
 CALL WDIALOGFIELDSTATE(IDF_LABEL8,I)
 CALL WDIALOGFIELDSTATE(IDF_LABEL9,I)
 CALL WDIALOGFIELDSTATE(IDF_LABEL10,I)

 END SUBROUTINE SOLID_NEW_FIELDS

 !###======================================================================
 LOGICAL FUNCTION SOLID_CREATE()
 !###======================================================================
 IMPLICIT NONE
 CHARACTER(LEN=50) :: FNAME
 INTEGER :: I,II,JJ,J,K,ICLIP,ISUP,IC,IR,ICLR
 REAL :: XMIN,YMIN,XMAX,YMAX
 LOGICAL :: LEX,LEQUAL

 SOLID_CREATE=.FALSE.

 CALL WDIALOGGETRADIOBUTTON(IDF_RADIO1,ISUP)
 !## consensus modelling
 IF(ISUP.EQ.1)THEN
  CALL WDIALOGGETMENU(IDF_MENU1,ISEL_SOLID)
  CALL WDIALOGGETMENU(IDF_MENU2,JSEL_SOLID)
  IF(JSEL_SOLID(ISEL_SOLID).EQ.1)THEN
   CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Do not select a SUPPORT model to be equal to the SOURCE model','Warning')
   RETURN
  ENDIF
  IF(ALLOCATED(ILIST))DEALLOCATE(ILIST)
  K=MAXVAL(SLD%NLAY)
  ALLOCATE(ILIST(2*K))
  ILIST=1
 !## scratch modeling
 ELSEIF(ISUP.EQ.2)THEN
  ILIST=0
  CALL WDIALOGGETMENU(IDF_MENU3,ILIST)
  IF(MOD(SUM(ILIST),2).NE.0)THEN
   CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'You should give multiplies of two IDFs!','Warning')
   RETURN
  ENDIF
 ENDIF

 FNAME=TRIM(SOLDIR)//'.SOL'
 INQUIRE(FILE=TRIM(PREFVAL(1))//'\SOLIDS\'//TRIM(SOLDIR)//'\'//TRIM(FNAME),EXIST=LEX)
 IF(LEX)THEN
  CALL WMESSAGEBOX(YESNO,QUESTIONICON,COMMONNO,'Are you sure to overwrite the file:'//CHAR(13)// &
     TRIM(FNAME)//' in the folder:'//CHAR(13)//TRIM(PREFVAL(1))//'\SOLIDS\'//TRIM(SOLDIR)//CHAR(13)// &
     'Press YES to overwrite it and continue'//CHAR(13)//'Press NO to stop the process.','Question')
  IF(WINFODIALOG(4).NE.1)RETURN
  CALL UTL_DEL1TREE(TRIM(PREFVAL(1))//'\SOLIDS\'//TRIM(SOLDIR))
  INQUIRE(FILE=TRIM(PREFVAL(1))//'\SOLIDS\'//TRIM(SOLDIR)//'\'//TRIM(FNAME),EXIST=LEX)
  !## stil exists, probalby terminated by user
  IF(LEX)RETURN
 ENDIF

 SOLDIR=TRIM(PREFVAL(1))//'\SOLIDS\'//TRIM(SOLDIR)
 CALL UTL_CREATEDIR(SOLDIR)

 CALL WDIALOGGETCHECKBOX(IDF_CHECK1,ICLIP)
 CALL WDIALOGGETREAL(IDF_REAL1,XMIN); CALL WDIALOGGETREAL(IDF_REAL2,YMIN)
 CALL WDIALOGGETREAL(IDF_REAL3,XMAX); CALL WDIALOGGETREAL(IDF_REAL4,YMAX)

 IF(ALLOCATED(SOLIDF))THEN
  CALL IDFDEALLOCATE(SOLIDF,SIZE(SOLIDF)); DEALLOCATE(SOLIDF)
 ENDIF
 ALLOCATE(SOLIDF(2)); DO I=1,SIZE(SOLIDF); CALL IDFNULLIFY(SOLIDF(I)); ENDDO

 CALL WINDOWSELECT(0)

 !## consensus modelling
 IF(ISUP.EQ.1)THEN

  !## source model, to be clipped/cutout
  JSEL_SOLID(ISEL_SOLID)=-1
  !## clip all
  DO I=1,SIZE(SLD)
   IF(ABS(JSEL_SOLID(I)).EQ.1)THEN
    JJ=0
    DO J=1,SLD(I)%NLAY
     JJ=JJ+1
     IF(JSEL_SOLID(I).EQ.-1)CALL WINDOWOUTSTATUSBAR(4,'Clipping '//TRIM(SLD(I)%INTNAME(J))//'...')
     IF(JSEL_SOLID(I).EQ. 1)CALL WINDOWOUTSTATUSBAR(4,'Checking '//TRIM(SLD(I)%INTNAME(J))//'...')
     FNAME=SLD(I)%INTNAME(J)(INDEX(SLD(I)%INTNAME(J),'\',.TRUE.)+1:)
     IF(.NOT.IDFREAD(SOLIDF(1),SLD(I)%INTNAME(J),0))RETURN
     IF(.NOT.IDFREADPART(SOLIDF(1),XMIN,YMIN,XMAX,YMAX))RETURN
     !## source model
     IF(JSEL_SOLID(I).EQ.-1)THEN
      IF(.NOT.IDFWRITE(SOLIDF(1),TRIM(SOLDIR)//'\'//TRIM(FNAME),1))RETURN
      SLD(I)%INTNAME(J)=TRIM(SOLDIR)//'\'//TRIM(FNAME)
      !## support model -- check for nodata, then leave it out!
     ELSE
      II=0
      IRLOOP: DO IR=1,SOLIDF(1)%NROW; DO IC=1,SOLIDF(1)%NCOL
       IF(SOLIDF(1)%X(IC,IR).NE.SOLIDF(1)%NODATA)THEN; II=1; EXIT IRLOOP; ENDIF
      ENDDO; ENDDO IRLOOP
      !## nodata found
      IF(II.EQ.0)THEN
       JJ=JJ-1; CYCLE
      ENDIF
      SLD(I)%INTNAME(JJ)=TRIM(SLD(I)%INTNAME(J)) 
     ENDIF
     CALL IDFDEALLOCATEX(SOLIDF(1))
     SLD(I)%INTCLR(JJ)=SLD(I)%INTCLR(J)
     SLD(I)%ICLC(JJ) =1
     !## kd clipping
     IF(SLD(I)%KDCLR(J).NE.0)THEN
      IF(JSEL_SOLID(I).EQ.-1)CALL WINDOWOUTSTATUSBAR(4,'Clipping '//TRIM(SLD(I)%KDNAME(J))//'...')
      IF(JSEL_SOLID(I).EQ. 1)CALL WINDOWOUTSTATUSBAR(4,'Checking '//TRIM(SLD(I)%KDNAME(J))//'...')
      FNAME=SLD(I)%KDNAME(J)(INDEX(SLD(I)%KDNAME(J),'\',.TRUE.)+1:)
      IF(.NOT.IDFREAD(SOLIDF(1),SLD(I)%KDNAME(J),0))RETURN
      IF(.NOT.IDFREADPART(SOLIDF(1),XMIN,YMIN,XMAX,YMAX))RETURN
      IF(.NOT.IDFWRITE(SOLIDF(1),TRIM(SOLDIR)//'\'//TRIM(FNAME),1))RETURN
      SLD(I)%KDNAME(JJ)=TRIM(SOLDIR)//'\'//TRIM(FNAME)
      CALL IDFDEALLOCATEX(SOLIDF(1))
     ENDIF
     IF(J.LT.SLD(I)%NLAY)THEN
      !## c clipping
      IF(SLD(I)%CCLR(J).NE.0)THEN
       IF(JSEL_SOLID(I).EQ.-1)CALL WINDOWOUTSTATUSBAR(4,'Clipping '//TRIM(SLD(I)%CNAME(J))//'...')
       IF(JSEL_SOLID(I).EQ. 1)CALL WINDOWOUTSTATUSBAR(4,'Checking '//TRIM(SLD(I)%CNAME(J))//'...')
       FNAME=SLD(I)%CNAME(J)(INDEX(SLD(I)%CNAME(J),'\',.TRUE.)+1:)
       IF(.NOT.IDFREAD(SOLIDF(1),SLD(I)%CNAME(J),0))RETURN
       IF(.NOT.IDFREADPART(SOLIDF(1),XMIN,YMIN,XMAX,YMAX))RETURN
       IF(.NOT.IDFWRITE(SOLIDF(1),TRIM(SOLDIR)//'\'//TRIM(FNAME),1))RETURN
       SLD(I)%CNAME(JJ)=TRIM(SOLDIR)//'\'//TRIM(FNAME)
       CALL IDFDEALLOCATEX(SOLIDF(1))
      ENDIF
     ENDIF
    ENDDO
    SLD(I)%NLAY=JJ
   ENDIF
  ENDDO
  IF(.NOT.SOLID_EXTRACTIPF(XMIN,YMIN,XMAX,YMAX))RETURN

 !## scratch modelling
 ELSEIF(ISUP.EQ.2)THEN

  !## ask to create zones between top and bottom
  IF(SUM(ILIST).EQ.2)THEN
   JSEL_SOLID(1)=-1
   IF(.NOT.SOLID_SPLIT(ICLIP))RETURN
  ELSE
   !## store solid-fnames()
   CALL SOLIDINITSLD(1)
   SLD(1)%NLAY=SUM(ILIST) !/2
   CALL SOLIDINITSLDPOINTER(1,SLD(1)%NLAY)
   IF(ALLOCATED(JSEL_SOLID))DEALLOCATE(JSEL_SOLID)
   ALLOCATE(JSEL_SOLID(1))
   JSEL_SOLID(1)=-1

   SLD(1)%KDCLR=0 !## no kd
   SLD(1)%CCLR=0  !## no c

   LEQUAL=.FALSE.

   J=0
   ICLR=0
   
   DO I=1,MXMPLOT
    IF(ILIST(I).EQ.1)THEN
     J=J+1
     
     IF(.NOT.LEQUAL)THEN
      !## make sure all idf files are equal to eachother
      IF(.NOT.IDFREAD(SOLIDF(2),MP(I)%IDFNAME,0))RETURN
      LEQUAL=.TRUE.
     ENDIF

     FNAME=MP(I)%IDFNAME(INDEX(MP(I)%IDFNAME,'\',.TRUE.)+1:)
     IF(ICLIP.EQ.0)THEN
      CALL WINDOWSELECT(0)
      CALL WINDOWOUTSTATUSBAR(4,'Copying '//TRIM(MP(I)%IDFNAME)//'...')
      IF(.NOT.IDFREAD(SOLIDF(1),MP(I)%IDFNAME,1))RETURN
      IF(.NOT.IDFEQUAL(SOLIDF(1),SOLIDF(2),1))RETURN
      IF(.NOT.IDFWRITE(SOLIDF(1),TRIM(SOLDIR)//'\'//TRIM(FNAME),1))RETURN
     ELSE
      CALL WINDOWSELECT(0)
      CALL WINDOWOUTSTATUSBAR(4,'Clipping '//TRIM(MP(I)%IDFNAME)//'...')
      IF(.NOT.IDFREAD(SOLIDF(1),MP(I)%IDFNAME,0))RETURN
      IF(.NOT.IDFREADPART(SOLIDF(1),XMIN,YMIN,XMAX,YMAX))RETURN
      IF(.NOT.IDFWRITE(SOLIDF(1),TRIM(SOLDIR)//'\'//TRIM(FNAME),1))RETURN
      CALL IDFDEALLOCATEX(SOLIDF(1))
     ENDIF

     !## store filenames
     SLD(1)%INTNAME(J)=TRIM(SOLDIR)//'\'//TRIM(FNAME)
     IF(MOD(K,2).NE.0)THEN
      SLD(1)%INTCLR(J)=WRGB(255,255,128)  !## colour = yellow
     ELSE
      ICLR=ICLR+1
      IF(ICLR.GT.SIZE(ICOLOR))ICLR=1
      SLD(1)%INTCLR(J)=ICOLOR(ICLR)
     ENDIF
     SLD(1)%ICLC(J)=1

    ENDIF
   END DO
   SLD(1)%SNAME=TRIM(SOLDIR(INDEX(SOLDIR,'\',.TRUE.)+1:))
   IF(.NOT.SOLID_EXTRACTIPF(SOLIDF(1)%XMIN,SOLIDF(1)%YMIN,SOLIDF(1)%XMAX,SOLIDF(1)%YMAX))RETURN
  ENDIF
 ENDIF

 CALL WINDOWSELECT(0)
 CALL WINDOWOUTSTATUSBAR(4,'')

 !## no polygons
 SHPNO=0
 NMASK=0
 NBOREHOLES=0
 !## try to write the solid
 FNAME=SOLDIR(INDEX(SOLDIR,'\',.TRUE.):)
 IF(.NOT.SOLIDOPENSOL('W',TRIM(SOLDIR)//TRIM(FNAME)//'.SOL',IQ=0))RETURN

 !## free all resource
 CALL SOLID_DEALLOCATE()

 !## refill menu with solids
 CALL SOLID_FIELDS()

 CALL WMESSAGEBOX(OKONLY,INFORMATIONICON,COMMONOK,'iMOD created the solid folder'//CHAR(13)// &
  TRIM(SOLDIR),'Information')

 SOLID_CREATE=.TRUE.

 END FUNCTION SOLID_CREATE

 !###======================================================================
 LOGICAL FUNCTION SOLID_SPLIT(ICLIP)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: ICLIP
 INTEGER :: N,I,J,K,IROW,ICOL,JROW,JCOL
 REAL :: X,Y,TOP,BOT,DZZ,XMIN,YMIN,XMAX,YMAX
 TYPE(WIN_MESSAGE) :: MESSAGE
 INTEGER :: ITYPE
 CHARACTER(LEN=3),DIMENSION(2) :: FTYPE
 DATA FTYPE/'TOP','BOT'/

 SOLID_SPLIT=.FALSE.
 
 CALL WDIALOGLOAD(ID_DLEGENDNOCLASSES,ID_DLEGENDNOCLASSES)
 CALL WDIALOGPUTSTRING(IDF_LABEL3,'Number of modellayers (1-50)')
 CALL WDIALOGFIELDSTATE(IDF_CHECK1,3)
 CALL WDIALOGTITLE('Define the Number of modellayers')
 CALL WDIALOGSHOW(-1,-1,0,3)
 DO
  CALL WMESSAGE(ITYPE,MESSAGE)
  SELECT CASE (ITYPE)
   CASE (PUSHBUTTON)
    SELECT CASE (MESSAGE%VALUE1)
     CASE (IDOK)
      CALL WDIALOGGETINTEGER(IDF_INTEGER1,N)
      EXIT
     CASE (IDCANCEL)
      EXIT
     CASE (IDHELP)
       CALL IMODGETHELP('5.4.1','Create a Solid')
    END SELECT
  END SELECT
 ENDDO

 CALL WDIALOGUNLOAD()
 IF(MESSAGE%VALUE1.EQ.IDCANCEL)RETURN

 CALL UTL_MESSAGEHANDLE(0)

 !## store solid-fnames()
 CALL SOLIDINITSLD(1)
 SLD(1)%NLAY=N
 SLD(1)%SNAME=TRIM(SOLDIR(INDEX(SOLDIR,'\',.TRUE.)+1:))
 CALL SOLIDINITSLDPOINTER(1,SLD(1)%NLAY); SLD(1)%ICLC=1; SLD(1)%ICHECK=1
 IF(ALLOCATED(JSEL_SOLID))DEALLOCATE(JSEL_SOLID)
 ALLOCATE(JSEL_SOLID(1)); JSEL_SOLID(1)=-1

 !## number of idf top,bot and (n-intervals*2)
 NTBSOL=N 

 IF(ALLOCATED(SOLIDF))THEN; CALL IDFDEALLOCATE(SOLIDF,SIZE(SOLIDF)); DEALLOCATE(SOLIDF); ENDIF
 IF(ALLOCATED(TB))THEN; CALL IDFDEALLOCATE(TB,SIZE(TB)); DEALLOCATE(TB); ENDIF
 ALLOCATE(SOLIDF(NTBSOL*2),TB(2))
 DO I=1,NTBSOL*2; CALL IDFNULLIFY(SOLIDF(I)); END DO
 DO I=1,2;        CALL IDFNULLIFY(TB(I));     END DO

 !## read original idf files (max. 2)
 J=0
 DO I=1,MXMPLOT
  IF(ILIST(I).EQ.1)THEN
   J=J+1
   IF(.NOT.IDFREAD(TB(J),MP(I)%IDFNAME,0))THEN !## error
   ENDIF
  ENDIF
 END DO

 !## adjust first idf to iclip
 IF(ICLIP.EQ.1)THEN
  CALL WDIALOGGETREAL(IDF_REAL1,XMIN)
  CALL WDIALOGGETREAL(IDF_REAL2,YMIN)
  CALL WDIALOGGETREAL(IDF_REAL3,XMAX)
  CALL WDIALOGGETREAL(IDF_REAL4,YMAX)
  CALL IDFCOPY(TB(1),SOLIDF(1))
  !## xmin
  I =INT(XMIN/SOLIDF(1)%DX)
  SOLIDF(1)%XMIN=I*SOLIDF(1)%DX
  !## ymin
  I =INT(YMIN/SOLIDF(1)%DY)
  SOLIDF(1)%YMIN=I*SOLIDF(1)%DY
  !## xmax
  I =INT(XMAX/SOLIDF(1)%DX)
  SOLIDF(1)%XMAX=I*SOLIDF(1)%DX
  !## ymax
  I =INT(YMAX/SOLIDF(1)%DY)
  SOLIDF(1)%YMAX=I*SOLIDF(1)%DY
  SOLIDF(1)%NCOL=(SOLIDF(1)%XMAX-SOLIDF(1)%XMIN)/SOLIDF(1)%DX
  SOLIDF(1)%NROW=(SOLIDF(1)%YMAX-SOLIDF(1)%YMIN)/SOLIDF(1)%DY
 ELSEIF(ICLIP.EQ.0)THEN
  CALL IDFCOPY(TB(1),SOLIDF(1))
 ENDIF

 !## write new files ... including top/bot given!
 DO I=1,NTBSOL

  !## first given IDF will be used to create all the others ... for now!
  IF(K.GT.1)CALL IDFCOPY(SOLIDF(1),SOLIDF(K))
  SOLIDF(I)%FNAME=TRIM(SOLDIR)//'\'//TRIM(FTYPE(J))//'_L'//TRIM(ITOS(I))//'.IDF'
  !##open new idfs
  IF(.NOT.IDFOPEN(SOLIDF(I)%IU,SOLIDF(I)%FNAME,'WO',0,1))THEN
  ENDIF

  !## store filenames
  SLD(1)%INTNAME(I)=SOLIDF(I)%FNAME
  SLD(1)%INTCLR(I)=ICOLOR(I)

 ENDDO

 SOLIDF%DMIN= 10.0E10
 SOLIDF%DMAX=-10.0E10

 DO IROW=1,SOLIDF(1)%NROW
  DO ICOL=1,SOLIDF(1)%NCOL

   !## get x/y coordinate
   CALL IDFGETLOC(SOLIDF(1),IROW,ICOL,X,Y)

   !## get top/bot information for current location
   CALL IDFIROWICOL(TB(1),JROW,JCOL,X,Y)
   TOP=IDFGETVAL(TB(1),JROW,JCOL)
   CALL IDFIROWICOL(TB(2),JROW,JCOL,X,Y)
   BOT=IDFGETVAL(TB(2),JROW,JCOL)

   DZZ=(TOP-BOT)/REAL(N-1) !*2-1) 
   !## check consistency
   IF(DZZ.LT.0.0)THEN
    DO I=1,NTBSOL*2; CLOSE(SOLIDF(I)%IU); ENDDO
    CALL UTL_MESSAGEHANDLE(1)
    CALL WMESSAGEBOX(OKONLY,INFORMATIONICON,COMMONOK,'iMOD can not create a Solid whenever the values from the first'//CHAR(13)// &
     'given IDF are lower than the values in for the second given IDF.'//CHAR(13)// &
     'Check whether you should change the order of the selected IDF files.','Information')
    RETURN
   ENDIF
   !## compute all intervals
   DO I=1,NTBSOL*2
    IF(TOP.NE.SOLIDF(1)%NODATA.AND. &
       BOT.NE.SOLIDF(2)%NODATA)THEN
     X=TOP-(DZZ*(I-1))
     SOLIDF(I)%DMIN=MIN(SOLIDF(I)%DMIN,X)
     SOLIDF(I)%DMAX=MAX(SOLIDF(I)%DMAX,X)
    ELSE
     X=SOLIDF(I)%NODATA
    ENDIF
    CALL IDFPUTVAL(SOLIDF(I),IROW,ICOL,X)
   END DO

  END DO
 END DO

 DO I=1,NTBSOL !*2
  IF(.NOT.IDFWRITEDIM(0,SOLIDF(I)))THEN
  ENDIF
  CLOSE(SOLIDF(I)%IU)
  CALL IDFINIT(IDFNAMEGIVEN=SOLIDF(I)%FNAME,LPLOT=.FALSE.)
 ENDDO

 NTBSOL=NTBSOL*2
 NSPF=0

 CALL UTL_MESSAGEHANDLE(1)

 SOLID_SPLIT=.TRUE.

 END FUNCTION SOLID_SPLIT

 !###======================================================================
 LOGICAL FUNCTION SOLID_EXTRACTIPF(XMIN,YMIN,XMAX,YMAX)
 !###======================================================================
 IMPLICIT NONE
 REAL,INTENT(IN) :: XMIN,YMIN,XMAX,YMAX
 INTEGER :: I,J,K,IU,JU,KU,NROW,NCOL,IASS,IOS,N,IRAT,IRAT1
 CHARACTER(LEN=256) :: DIR,FNAME1,FNAME2,LINE
 CHARACTER(LEN=5) :: TXT
 CHARACTER(LEN=50),ALLOCATABLE,DIMENSION(:) :: STRING
 REAL :: X,Y

 SOLID_EXTRACTIPF=.TRUE.
 IF(NBOREHOLES.LE.0)RETURN

 SOLID_EXTRACTIPF=.FALSE.

 JU=UTL_GETUNIT()
 CALL OSD_OPEN(JU,FILE=TRIM(PREFVAL(1))//'\TMP\COPY.BAT',STATUS='UNKNOWN',ACTION='WRITE',IOSTAT=IOS)
 IF(IOS.NE.0)THEN
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Can not CREATE '//TRIM(PREFVAL(1))//'\TMP\COPY.BAT','Error')
  RETURN
 ENDIF

 CALL UTL_CREATEDIR(TRIM(SOLDIR)//'\BOREHOLES')

 KU=UTL_GETUNIT()
 CALL OSD_OPEN(KU,FILE=TRIM(SOLDIR)//'\BOREHOLES\BOREHOLES_TMP.IPF',STATUS='UNKNOWN',ACTION='WRITE',IOSTAT=IOS)
 IF(IOS.NE.0)THEN
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Can not CREATE '//TRIM(SOLDIR)//'\BOREHOLES\BOREHOLES.IPF','Error')
  RETURN
 ENDIF

 N=0
 IRAT=0
 DO I=1,NBOREHOLES

  IU=UTL_GETUNIT()
  CALL OSD_OPEN(IU,FILE=FBOREHOLES(I),STATUS='OLD',ACTION='READ,DENYWRITE',IOSTAT=IOS)
  IF(IOS.NE.0)THEN
   CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'SOLIDTOOl can not find:'//CHAR(13)// &
    TRIM(FBOREHOLES(I)),'Error')
   RETURN
  ENDIF

  J  =INDEXNOCASE(FBOREHOLES(I),'\',.TRUE.)
  DIR=FBOREHOLES(I)(1:J-1)

  READ(IU,*) NROW
  READ(IU,*) NCOL
  IF(NROW.GT.0)THEN

   !## read attritutes
   DO J=1,NCOL; READ(IU,*); ENDDO
   READ(IU,*,IOSTAT=IOS) IASS,TXT
   IF(IOS.NE.0)THEN
    CLOSE(IU)
    CLOSE(JU)
    CLOSE(KU)
    CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Error reading [IASS,TXT] in ipffile'//CHAR(13)// &
      TRIM(FBOREHOLES(I)),'Error')
   ENDIF
   IF(IASS.GT.0)THEN
    ALLOCATE(STRING(IASS-2))
    DO J=1,NROW
     READ(IU,*,IOSTAT=IOS) X,Y,(STRING(K),K=1,IASS-2)
     IF(IOS.NE.0)THEN
      CLOSE(IU)
      CLOSE(JU)
      CLOSE(KU)
      CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Error reading line '//TRIM(ITOS(J))//' in ipffile'//CHAR(13)// &
       TRIM(FBOREHOLES(I)),'Error')
      RETURN
     ENDIF

     IF(X.GE.XMIN.AND.X.LE.XMAX.AND. &
        Y.GE.YMIN.AND.Y.LE.YMAX)THEN

      !## number of borehole inside graphical window
      N=N+1

      !## old associated filename
      FNAME1=TRIM(DIR)             //'\'//TRIM(STRING(IASS-2))//'.'//TRIM(ADJUSTL(TXT))
      !## new associated filename
      FNAME2=TRIM(SOLDIR)//'\BOREHOLES\DATA'//TRIM(ITOS(I))//'\'//TRIM(STRING(IASS-2))//'.'//TRIM(ADJUSTL(TXT))
      K=INDEX(FNAME2,'\',.TRUE.)
      IF(K.NE.0)CALL UTL_CREATEDIR(FNAME2(:K-1))

      !## copy batch
      LINE='copy '//TRIM(FNAME1)//' '//TRIM(FNAME2)
      WRITE(JU,'(A)') TRIM(LINE)
      !## tmp ipf
      LINE=TRIM(RTOS(X,'F',2))//','//TRIM(RTOS(Y,'F',2))//',data'//TRIM(ITOS(I))//'\'//TRIM(STRING(IASS-2))
      WRITE(KU,'(A)') TRIM(LINE)

     ENDIF

     CALL UTL_WAITMESSAGE(IRAT,IRAT1,I,NBOREHOLES,'Prepare copying associated files ... ')
    ENDDO
    DEALLOCATE(STRING)
   ENDIF
  ENDIF
  CLOSE(IU)
 ENDDO
 CLOSE(KU)
 CLOSE(JU)

 NBOREHOLES=1
 FBOREHOLES(1)=TRIM(SOLDIR)//'\BOREHOLES\BOREHOLES.IPF'

 CALL WINDOWOUTSTATUSBAR(4,'Copy selected associated files, can take a while ...')
 !## start copying
 CALL IOSCOMMAND(TRIM(PREFVAL(1))//'\TMP\COPY.BAT',PROCBLOCKED)
 CALL WINDOWOUTSTATUSBAR(4,'')

 CALL WINDOWOUTSTATUSBAR(4,'Rewriting BOREHOLES.IPF ...')

 IU=UTL_GETUNIT()
 CALL OSD_OPEN(JU,FILE=TRIM(SOLDIR)//'\BOREHOLES\BOREHOLES_TMP.IPF',STATUS='OLD',ACTION='READ',IOSTAT=IOS)
 IF(IOS.NE.0)THEN
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Can not OPEN '//TRIM(SOLDIR)//'\BOREHOLES\BOREHOLES_TMP.IPF','Error')
  RETURN
 ENDIF
 JU=UTL_GETUNIT()
 CALL OSD_OPEN(JU,FILE=TRIM(SOLDIR)//'\BOREHOLES\BOREHOLES.IPF',STATUS='UNKNOWN',ACTION='WRITE',IOSTAT=IOS)
 IF(IOS.NE.0)THEN
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Can not CREATE '//TRIM(SOLDIR)//'\BOREHOLES\BOREHOLES.IPF','Error')
  RETURN
 ENDIF
 LINE=TRIM(ITOS(N))
 WRITE(JU,'(A)') TRIM(LINE)
 WRITE(JU,'(A)') '3'
 WRITE(JU,'(A)') 'x'
 WRITE(JU,'(A)') 'y'
 WRITE(JU,'(A)') 'id'
 WRITE(JU,'(A)') '3,txt'
 DO I=1,N
  READ(IU,'(A256)') LINE
  WRITE(JU,'(A)') TRIM(LINE)
 ENDDO
 CLOSE(IU,STATUS='DELETE')
 CLOSE(JU)

 CALL WINDOWOUTSTATUSBAR(4,'')

 SOLID_EXTRACTIPF=.TRUE.

 END FUNCTION SOLID_EXTRACTIPF

 !###======================================================================
 LOGICAL FUNCTION SOLID_CALC_KDC()
 !###======================================================================
 IMPLICIT NONE
 INTEGER :: I,J,K,ILAY,JLAY,IROW,ICOL,IKH,IKV,IU,IOS,NLAY
 REAL :: TR,BR,Z1,Z2,F,KVAL,XTOP,XBOT
 CHARACTER(LEN=256) :: ROOT,FNAME
 CHARACTER(LEN=52) :: WC,CTYPE
 
 SOLID_CALC_KDC=.FALSE.

 !## refresh memory
! IF(IBATCH.EQ.0)THEN
!  CALL SOLID_DEALLOCATE()
!  !## read all idf-files in to memory
!  IF(.NOT.SOLIDOPENSOL('R',SOLFILE))RETURN
! ENDIF
 !## try to read all idf's
 NLAY=SLD(1)%NLAY; ALLOCATE(TOPIDF(NLAY),BOTIDF(NLAY)) 
 DO I=1,SLD(1)%NLAY; DO J=1,2
  FNAME=TRIM(OUTPUTFOLDER)//'\'//TRIM(SLD(1)%INTNAME(I)(INDEX(SLD(1)%INTNAME(I),'\',.TRUE.)+1:))
  WRITE(*,'(A)') 'Reading '//TRIM(FNAME)
  IF(J.EQ.1)THEN; IF(.NOT.IDFREAD(TOPIDF(I),FNAME,1))RETURN; ENDIF
  IF(J.EQ.2)THEN; IF(.NOT.IDFREAD(BOTIDF(I),FNAME,1))RETURN; ENDIF
 ENDDO; ENDDO
 
 !## get list of "regis"-files
 I=INDEX(REGISTOP,'\',.TRUE.); ROOT=REGISTOP(:I-1); WC=UTL_CAP(TRIM(REGISTOP(I+1:)),'U')
 IF(.NOT.UTL_DIRINFO_POINTER(ROOT,WC,REGISFILES,'F'))RETURN
 DO I=1,SIZE(REGISFILES); REGISFILES(I)=UTL_CAP(TRIM(ROOT)//'\'//TRIM(REGISFILES(I)),'U'); ENDDO
 
 IF(.NOT.SOLID_CALC_KDC_INIT(NLAY))RETURN
 
 IU=UTL_GETUNIT(); CALL OSD_OPEN(IU,FILE=TRIM(OUTPUTFOLDER)//'\solid_log.txt',STATUS='UNKNOWN',ACTION='WRITE',IOSTAT=IOS)
 IF(IOS.NE.0)THEN; WRITE(*,'(/A/)') 'Can not CREATE '//TRIM(OUTPUTFOLDER)//'\solid_log.txt'; RETURN; ENDIF

 !## read/process
 DO I=1,SIZE(REGISFILES)
  
  WRITE(*,'(2(I10,1X),F10.2)') I,SIZE(REGISFILES),REAL(I*100)/REAL(SIZE(REGISFILES))
  
  J=INDEX(REGISFILES(I),'\',.TRUE.)+1; K=INDEX(REGISFILES(I),TRIM(WC(2:)))-1
  CTYPE=REGISFILES(I)(J:K)

  WRITE(* ,'(A)') 'Reading:'; WRITE(IU,'(A)') 'Reading:'
  !## try top
  WRITE(* ,'(A)') '-'//TRIM(REGISFILES(I)); WRITE(IU,'(A)') '-'//TRIM(REGISFILES(I))
  IF(.NOT.IDFREADSCALE(REGISFILES(I),TB(1),2,1,0.0,0))RETURN !## scale mean
  TB(1)%FNAME=TRIM(OUTPUTFOLDER)//'\REGIS\'//TRIM(REGISFILES(I)(INDEX(REGISFILES(I),'\',.TRUE.):))
  !## try bot
  FNAME=UTL_SUBST(REGISBOT,'*',TRIM(CTYPE))
  WRITE(* ,'(A)') '-'//TRIM(FNAME); WRITE(IU,'(A)') '-'//TRIM(FNAME)
  IF(.NOT.IDFREADSCALE(FNAME,TB(2),2,1,0.0,0))RETURN !## scale mean
  TB(2)%FNAME=TRIM(OUTPUTFOLDER)//'\REGIS\'//TRIM(FNAME(INDEX(FNAME,'\',.TRUE.):))
  !## try kh
  FNAME=UTL_SUBST(REGISKHV,'*',TRIM(CTYPE))
  IKH=1; IF(.NOT.IDFREADSCALE(FNAME,KH(1),3,1,0.0,1))IKH=0
  IF(IKH.EQ.1)THEN; WRITE(*,'(A)') '-'//TRIM(FNAME); WRITE(IU,'(A)') '-'//TRIM(FNAME); ENDIF
  KH(1)%FNAME=TRIM(OUTPUTFOLDER)//'\REGIS\'//TRIM(FNAME(INDEX(FNAME,'\',.TRUE.):))
  !## try kv
  FNAME=UTL_SUBST(REGISKVV,'*',TRIM(CTYPE))
  IKV=1; IF(.NOT.IDFREADSCALE(FNAME,KV(1),3,1,0.0,1))IKV=0
  IF(IKV.EQ.1)THEN; WRITE(*,'(A)') '-'//TRIM(FNAME); WRITE(IU,'(A)') '-'//TRIM(FNAME); ENDIF
  KV(1)%FNAME=TRIM(OUTPUTFOLDER)//'\REGIS\'//TRIM(FNAME(INDEX(FNAME,'\',.TRUE.):))
  
  IF(IKH.EQ.0.AND.IKV.EQ.0)THEN
   WRITE(*,'(/A/)')  'No horizontal/vertical permeabilities found, formation will be skipped!'
   WRITE(IU,'(/A/)') 'No horizontal/vertical permeabilities found, formation will be skipped!'
   CYCLE
  ENDIF

  CALL UTL_CREATEDIR(TRIM(OUTPUTFOLDER)//'\FFRAC')
  DO ILAY=1,SIZE(FFRAC)
   FFRAC(ILAY)%FNAME=TRIM(OUTPUTFOLDER)//'\FFRAC\'//TRIM(CTYPE)//'_l'//TRIM(ITOS(ILAY))//'.idf'; FFRAC(ILAY)%X=0.0; FFRAC(ILAY)%NODATA=0.0
   WRITE(*,'(A)') TRIM(FFRAC(ILAY)%FNAME)
  ENDDO
  
  !## process data
  WRITE(*,'(A)') 'Process data ...'
  DO IROW=1,TOPIDF(1)%NROW; DO ICOL=1,TOPIDF(1)%NCOL
   
   TR=TB(1)%X(ICOL,IROW); BR=TB(2)%X(ICOL,IROW)   
   IF(TR.EQ.TB(1)%NODATA.OR.BR.EQ.TB(2)%NODATA)CYCLE
      
   !## compute fractions for aquifers
   DO ILAY=1,NLAY
    XTOP=TOPIDF(ILAY)%X(ICOL,IROW); XBOT=BOTIDF(ILAY)%X(ICOL,IROW)
    Z1=MIN(TR,XTOP); Z2=MAX(BR,XBOT)
    !## fraction in aquifer
    IF(Z1.GT.Z2.AND.XTOP.GT.XBOT)THEN
     F=(Z1-Z2)/(XTOP-XBOT)
     KDFRACIDF(ILAY)%X(ICOL,IROW)=KDFRACIDF(ILAY)%X(ICOL,IROW)+F
     !## assign maximum k values for aquifers
     KVAL=0.0
     IF(IKH.EQ.1)KVAL=MAX(KVAL,     KH(1)%X(ICOL,IROW))
     IF(IKV.EQ.1)KVAL=MAX(KVAL,(3.0*KV(1)%X(ICOL,IROW)))
     KDHIDF(ILAY)%X(ICOL,IROW)=KDHIDF(ILAY)%X(ICOL,IROW)+(Z1-Z2)*KVAL
     
     KVAL=0.0
     IF(IKV.EQ.1)KVAL=MAX(KVAL,     KV(1)%X(ICOL,IROW))
     IF(IKH.EQ.1)KVAL=MAX(KVAL,(0.3*KH(1)%X(ICOL,IROW)))
     KDVIDF(ILAY)%X(ICOL,IROW)=KDVIDF(ILAY)%X(ICOL,IROW)+(Z1-Z2)*KVAL
     
    ENDIF
   ENDDO

   !## compute fractions for aquitards, resistance between mid aquifer1 and aquifer2
   DO ILAY=1,NLAY-1
!    IF(CMID.EQ.1)THEN
!     XTOP=(TOPIDF(ILAY  )%X(ICOL,IROW)+BOTIDF(ILAY  )%X(ICOL,IROW))/2.0
!     XBOT=(TOPIDF(ILAY+1)%X(ICOL,IROW)+BOTIDF(ILAY+1)%X(ICOL,IROW))/2.0
!    ELSE
    XTOP=BOTIDF(ILAY  )%X(ICOL,IROW)
    XBOT=TOPIDF(ILAY+1)%X(ICOL,IROW)
!    ENDIF
    Z1=MIN(TR,XTOP); Z2=MAX(BR,XBOT)
    !## fraction in aquitards
    IF(Z1.GT.Z2)THEN
     F=(Z1-Z2)/(XTOP-XBOT)
     CFRACIDF(ILAY)%X(ICOL,IROW)=CFRACIDF(ILAY)%X(ICOL,IROW)+F
     !## assign minimum values for aquitards
     KVAL=10.0E10
     IF(IKH.EQ.1)KVAL=MIN(KVAL,(0.3*KH(1)%X(ICOL,IROW)))
     IF(IKV.EQ.1)KVAL=MIN(KVAL,     KV(1)%X(ICOL,IROW))
     IF(KVAL.GT.0.0)THEN
      CIDF(ILAY)%X(ICOL,IROW)=CIDF(ILAY)%X(ICOL,IROW)+((Z1-Z2)/KVAL)
     ENDIF
     FFRAC(ILAY)%X(ICOL,IROW)=(Z1-Z2)
    ENDIF
   ENDDO
   
  ENDDO; ENDDO
  
!  IF(.NOT.IDFWRITE(TB(1),TB(1)%FNAME,1))RETURN
!  IF(.NOT.IDFWRITE(TB(2),TB(2)%FNAME,1))RETURN
!  IF(IKH.EQ.1)THEN; IF(.NOT.IDFWRITE(KH(1),KH(1)%FNAME,1))RETURN; ENDIF
!  IF(IKV.EQ.1)THEN; IF(.NOT.IDFWRITE(KV(1),KV(1)%FNAME,1))RETURN; ENDIF

  DO IROW=1,TOPIDF(1)%NROW; DO ICOL=1,TOPIDF(1)%NCOL
   F=0.0; DO ILAY=1,NLAY; F=F+FFRAC(ILAY)%X(ICOL,IROW); ENDDO
   IF(F.GT.0.0)THEN
    DO ILAY=1,NLAY; FFRAC(ILAY)%X(ICOL,IROW)=FFRAC(ILAY)%X(ICOL,IROW)/F; ENDDO
   ENDIF
  ENDDO; ENDDO
  
  DO ILAY=1,NLAY
   IF(SUM(FFRAC(ILAY)%X).GT.0.0)THEN; IF(.NOT.IDFWRITE(FFRAC(ILAY),FFRAC(ILAY)%FNAME,1))RETURN; ENDIF
  ENDDO

  IF(F.GT.0.0)THEN
   !## take layer that contains most of the fractions
   CALL UTL_CREATEDIR(TRIM(OUTPUTFOLDER)//'\FILAY')
   FFRAC(1)%FNAME=TRIM(OUTPUTFOLDER)//'\FILAY\'//TRIM(CTYPE)//'_pointer.idf'
   DO IROW=1,TOPIDF(1)%NROW; DO ICOL=1,TOPIDF(1)%NCOL
    F=0.0; DO ILAY=1,NLAY
     IF(FFRAC(ILAY)%X(ICOL,IROW).GT.F)THEN; F=FFRAC(ILAY)%X(ICOL,IROW); J=ILAY; ENDIF
    ENDDO
    IF(F.GT.0.0)THEN; FFRAC(1)%X(ICOL,IROW)=REAL(J); ENDIF
   ENDDO; ENDDO
   IF(SUM(FFRAC(1)%X).GT.0.0)THEN; IF(.NOT.IDFWRITE(FFRAC(1),FFRAC(1)%FNAME,1))RETURN; ENDIF
  ENDIF 
  
 ENDDO
 CLOSE(IU)
 
 !## write transmissivities/vertical resistances
 DO I=1,SIZE(KDHIDF); IF(.NOT.IDFWRITE(KDHIDF(I),TRIM(OUTPUTFOLDER)//'\mdl_kd_l'//TRIM(ITOS(I))//'.idf',1))RETURN; ENDDO
 DO I=1,SIZE(CIDF);   IF(.NOT.IDFWRITE(CIDF(I)  ,TRIM(OUTPUTFOLDER)//'\mdl_vc_l'//TRIM(ITOS(I))//'.idf',1))RETURN; ENDDO

 DO IROW=1,TOPIDF(1)%NROW; DO ICOL=1,TOPIDF(1)%NCOL; DO ILAY=1,NLAY
  TR=TOPIDF(ILAY)%X(ICOL,IROW); BR=BOTIDF(ILAY)%X(ICOL,IROW)   
  IF(TR.EQ.TOPIDF(ILAY)%NODATA.OR.BR.EQ.BOTIDF(ILAY)%NODATA)CYCLE
  IF(TR-BR.LE.0.0)THEN
   KDHIDF(ILAY)%X(ICOL,IROW)=0.0
   KDVIDF(ILAY)%X(ICOL,IROW)=1.0
  ELSE
   KDHIDF(ILAY)%X(ICOL,IROW)=KDHIDF(ILAY)%X(ICOL,IROW)/(TR-BR)
   KDVIDF(ILAY)%X(ICOL,IROW)=KDVIDF(ILAY)%X(ICOL,IROW)/(TR-BR)    
   KDVIDF(ILAY)%X(ICOL,IROW)=KDVIDF(ILAY)%X(ICOL,IROW)/KDHIDF(ILAY)%X(ICOL,IROW)
  ENDIF
  IF(ILAY.LT.NLAY)THEN
   BR=TOPIDF(ILAY)%X(ICOL,IROW); TR=TOPIDF(ILAY+1)%X(ICOL,IROW)   
   IF(TR.EQ.TOPIDF(ILAY)%NODATA.OR.BR.EQ.BOTIDF(ILAY)%NODATA)CYCLE
   IF(CIDF(ILAY)%X(ICOL,IROW).LE.0.0)THEN
    CIDF(ILAY)%X(ICOL,IROW)= 0.0
   ELSE
    CIDF(ILAY)%X(ICOL,IROW)=(TR-BR)/CIDF(ILAY)%X(ICOL,IROW)
   ENDIF
  ENDIF
 ENDDO; ENDDO; ENDDO
 
 DO I=1,SIZE(KDHIDF);    IF(.NOT.IDFWRITE(KDHIDF(I),KDHIDF(I)%FNAME,1))RETURN; ENDDO
 DO I=1,SIZE(KDVIDF);    IF(.NOT.IDFWRITE(KDVIDF(I),KDVIDF(I)%FNAME,1))RETURN; ENDDO
 DO I=1,SIZE(CIDF);      IF(.NOT.IDFWRITE(CIDF(I),CIDF(I)%FNAME,1))RETURN; ENDDO
 DO I=1,SIZE(KDFRACIDF); IF(.NOT.IDFWRITE(KDFRACIDF(I),KDFRACIDF(I)%FNAME,1))RETURN; ENDDO
 DO I=1,SIZE(CFRACIDF);  IF(.NOT.IDFWRITE(CFRACIDF(I),CFRACIDF(I)%FNAME,1))RETURN; ENDDO
 
 SOLID_CALC_KDC=.TRUE.
 
 END FUNCTION SOLID_CALC_KDC

 !###======================================================================
 LOGICAL FUNCTION SOLID_CALC_KDC_INIT(NLAY)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: NLAY
 INTEGER :: I
 
 SOLID_CALC_KDC_INIT=.FALSE.
 
 ALLOCATE(CIDF(NLAY-1),CFRACIDF(NLAY-1),KDHIDF(NLAY),KDVIDF(NLAY),KDFRACIDF(NLAY),TOP(NLAY), &
          BOT(NLAY),TB(2),KH(1),KV(1),FFRAC(NLAY))
 !## nullify idf-objects
 DO I=1,SIZE(CIDF);      CALL IDFNULLIFY(CIDF(I)) ; ENDDO
 DO I=1,SIZE(KDHIDF);    CALL IDFNULLIFY(KDHIDF(I)); ENDDO 
 DO I=1,SIZE(KDVIDF);    CALL IDFNULLIFY(KDVIDF(I)); ENDDO 
 DO I=1,SIZE(CFRACIDF);  CALL IDFNULLIFY(CFRACIDF(I)) ; ENDDO
 DO I=1,SIZE(KDFRACIDF); CALL IDFNULLIFY(KDFRACIDF(I)); ENDDO 
 DO I=1,SIZE(KH);        CALL IDFNULLIFY(KH(I));    ENDDO 
 DO I=1,SIZE(KV);        CALL IDFNULLIFY(KV(I));    ENDDO 
 DO I=1,SIZE(TB);        CALL IDFNULLIFY(TB(I));    ENDDO
 DO I=1,SIZE(FFRAC);     CALL IDFNULLIFY(FFRAC(I));    ENDDO
 !## copy settings
 DO I=1,SIZE(CIDF);  CALL IDFCOPY(TOPIDF(1),CIDF(I)) ; ENDDO 
 DO I=1,SIZE(KDHIDF); CALL IDFCOPY(TOPIDF(1),KDHIDF(I)); ENDDO 
 DO I=1,SIZE(KDVIDF); CALL IDFCOPY(TOPIDF(1),KDVIDF(I)); ENDDO 
 DO I=1,SIZE(CFRACIDF);  CALL IDFCOPY(TOPIDF(1),CFRACIDF(I)) ; ENDDO 
 DO I=1,SIZE(KDFRACIDF); CALL IDFCOPY(TOPIDF(1),KDFRACIDF(I)); ENDDO 
 DO I=1,SIZE(TB)   ; CALL IDFCOPY(TOPIDF(1),TB(I))   ; ENDDO 
 DO I=1,SIZE(FFRAC)   ; CALL IDFCOPY(TOPIDF(1),FFRAC(I))   ; ENDDO 
 CALL IDFCOPY(TOPIDF(1),KH(1)); CALL IDFCOPY(TOPIDF(1),KV(1))
 
 !## write header information kdidf / cidf
 DO I=1,SIZE(KDHIDF)
  KDHIDF(I)%X=0.0; KDHIDF(I)%FNAME=TRIM(OUTPUTFOLDER)//'\mdl_khv_l'//TRIM(ITOS(I))//'.idf'
 ENDDO
 DO I=1,SIZE(KDHIDF)
  KDVIDF(I)%X=0.0; KDVIDF(I)%FNAME=TRIM(OUTPUTFOLDER)//'\mdl_kva_l'//TRIM(ITOS(I))//'.idf'
 ENDDO
 DO I=1,SIZE(CIDF)
  CIDF(I)%X=0.0;   CIDF(I)%FNAME=TRIM(OUTPUTFOLDER)//'\mdl_kvv_l'//TRIM(ITOS(I))//'.idf'
 ENDDO
 DO I=1,SIZE(KDFRACIDF)
  KDFRACIDF(I)%X=0.0; KDFRACIDF(I)%FNAME=TRIM(OUTPUTFOLDER)//'\mdl_kdfrac_l'//TRIM(ITOS(I))//'.idf'
 ENDDO
 DO I=1,SIZE(CFRACIDF)
  CFRACIDF(I)%X=0.0; CFRACIDF(I)%FNAME=TRIM(OUTPUTFOLDER)//'\mdl_cfrac_l'//TRIM(ITOS(I))//'.idf'
 ENDDO
  
 SOLID_CALC_KDC_INIT=.TRUE.
 
 END FUNCTION SOLID_CALC_KDC_INIT

 !###======================================================================
 SUBROUTINE SOLID_CALC_KDC_DEALLOCATE()
 !###======================================================================
 IMPLICIT NONE
 
 !## deallocate
 IF(ALLOCATED(TOPIDF))THEN;    CALL IDFDEALLOCATE(TOPIDF,SIZE(TOPIDF));       DEALLOCATE(TOPIDF); ENDIF
 IF(ALLOCATED(BOTIDF))THEN;    CALL IDFDEALLOCATE(BOTIDF,SIZE(BOTIDF));       DEALLOCATE(BOTIDF); ENDIF
 IF(ALLOCATED(CIDF))THEN;      CALL IDFDEALLOCATE(CIDF ,SIZE(CIDF));          DEALLOCATE(CIDF);   ENDIF
 IF(ALLOCATED(KDHIDF))THEN;    CALL IDFDEALLOCATE(KDHIDF,SIZE(KDHIDF));       DEALLOCATE(KDHIDF);  ENDIF
 IF(ALLOCATED(KDVIDF))THEN;    CALL IDFDEALLOCATE(KDVIDF,SIZE(KDVIDF));       DEALLOCATE(KDVIDF);  ENDIF
 IF(ALLOCATED(CFRACIDF))THEN;  CALL IDFDEALLOCATE(CFRACIDF ,SIZE(CFRACIDF));  DEALLOCATE(CFRACIDF); ENDIF
 IF(ALLOCATED(KDFRACIDF))THEN; CALL IDFDEALLOCATE(KDFRACIDF,SIZE(KDFRACIDF)); DEALLOCATE(KDFRACIDF); ENDIF
 IF(ASSOCIATED(REGISFILES))DEALLOCATE(REGISFILES)
 IF(ALLOCATED(TOP))DEALLOCATE(TOP) 
 IF(ALLOCATED(BOT))DEALLOCATE(BOT) 
 IF(ALLOCATED(KH))THEN; CALL IDFDEALLOCATE(KH,SIZE(KH)); DEALLOCATE(KH); ENDIF
 IF(ALLOCATED(KV))THEN; CALL IDFDEALLOCATE(KV,SIZE(KV)); DEALLOCATE(KV); ENDIF
 IF(ALLOCATED(TB))THEN; CALL IDFDEALLOCATE(TB,SIZE(TB)); DEALLOCATE(TB); ENDIF 
 IF(ALLOCATED(FFRAC))THEN; CALL IDFDEALLOCATE(FFRAC,SIZE(FFRAC)); DEALLOCATE(FFRAC); ENDIF 
 
 END SUBROUTINE SOLID_CALC_KDC_DEALLOCATE

END MODULE MOD_SOLID

