!!  Copyright (C) Stichting Deltares, 2005-2018.
!!
!!  This file is part of iMOD.
!!
!!  This program is free software: you can redistribute it and/or modify
!!  it under the terms of the GNU General Public License as published by
!!  the Free Software Foundation, either version 3 of the License, or
!!  (at your option) any later version.
!!
!!  This program is distributed in the hope that it will be useful,
!!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!  GNU General Public License for more details.
!!
!!  You should have received a copy of the GNU General Public License
!!  along with this program.  If not, see <http://www.gnu.org/licenses/>.
!!
!!  Contact: imod.support@deltares.nl
!!  Stichting Deltares
!!  P.O. Box 177
!!  2600 MH Delft, The Netherlands.
!!
MODULE MOD_POLYGON_DRAW

USE WINTERACTER
USE RESOURCE
USE MOD_DBL
USE MOD_POLYGON_PAR
USE MOD_POLYGON_UTL
USE MOD_UTL
USE MODPLOT, ONLY : MPW

CONTAINS

 !###======================================================================
 SUBROUTINE POLYGON1DRAW(IPOL)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IPOL
 TYPE(WIN_MESSAGE) :: MESSAGE
 INTEGER :: ITYPE,N
 REAL(KIND=DP_KIND) :: MOUSEX,MOUSEY
 LOGICAL :: LEX

 CALL IGRPLOTMODE(MODEXOR)
 SHP%POL(IPOL)%ICOLOR=UTL_INVERSECOLOUR(SHP%POL(IPOL)%ICOLOR)
 CALL IGRCOLOURN(SHP%POL(IPOL)%ICOLOR)

 SHP%POL(IPOL)%N=1

 LEX=.FALSE.

 SELECT CASE (SHP%POL(IPOL)%ITYPE)
  CASE (ID_POLYGON)
   CALL WCURSORSHAPE(ID_CURSORPOLYGON)
  CASE (ID_RECTANGLE)
   CALL WCURSORSHAPE(ID_CURSORRECTANGLE)
  CASE (ID_POINT)
   CALL WCURSORSHAPE(ID_CURSORPOINT)
  CASE (ID_LINE)
   CALL WCURSORSHAPE(ID_CURSORLINE)
  CASE (ID_CIRCLE)
   CALL WCURSORSHAPE(ID_CURSORCIRCLE)
 END SELECT

 CALL IGRFILLPATTERN(OUTLINE)
 CALL IGRLINETYPE(SOLIDLINE)
 CALL IGRLINEWIDTH(SHP%POL(IPOL)%IWIDTH)

 !## allocate memory
 CALL POLYGON1ALLOCATEXY(IPOL,50)
 
 DO
 
  CALL WMESSAGE(ITYPE,MESSAGE)

  SELECT CASE (ITYPE)

   !## mouse-move
   CASE (MOUSEMOVE)

    MOUSEX=DBLE(MESSAGE%GX)+OFFSETX
    MOUSEY=DBLE(MESSAGE%GY)+OFFSETY

    CALL WINDOWSELECT(0)
    CALL WINDOWOUTSTATUSBAR(1,'x = '//TRIM(RTOS(MOUSEX,'G',10))//' m; y = '//TRIM(RTOS(MOUSEY,'G',10))//' m')

    !## first point set 
    IF(SHP%POL(IPOL)%N.GT.1.OR.SHP%POL(IPOL)%ITYPE.EQ.ID_POINT)THEN
     CALL UTL_PLOT1BITMAP()
     IF(LEX)CALL POLYGON1PLOTSHAPE(IPOL); LEX=.TRUE.
     SHP%POL(IPOL)%X(SHP%POL(IPOL)%N)=MOUSEX 
     SHP%POL(IPOL)%Y(SHP%POL(IPOL)%N)=MOUSEY 
     CALL POLYGON1PLOTSHAPE(IPOL)
     CALL UTL_PLOT2BITMAP()
    ENDIF

   CASE (PUSHBUTTON)
!    SELECT CASE (MESSAGE%VALUE1)
!     CASE (IDCANCEL)
!      EXIT
!    END SELECT

   CASE (MOUSEBUTDOWN)
    CALL UTL_PLOT1BITMAP()
    IF(LEX)CALL POLYGON1PLOTSHAPE(IPOL)
    SELECT CASE (MESSAGE%VALUE1)

     CASE (1)  !## left button
      IF((SHP%POL(IPOL)%ITYPE.EQ.ID_RECTANGLE.OR. &
          SHP%POL(IPOL)%ITYPE.EQ.ID_CIRCLE).AND.SHP%POL(IPOL)%N.EQ.2)THEN
       CALL POLYGON1PLOTSHAPE(IPOL); CALL UTL_PLOT2BITMAP(); EXIT
      ENDIF
      
      N=SHP%POL(IPOL)%N
      
      !## allocate memory
      CALL POLYGON1ALLOCATEXY(IPOL,SHP%POL(IPOL)%N+1)

      SHP%POL(IPOL)%X(N:N+1)=MOUSEX
      SHP%POL(IPOL)%Y(N:N+1)=MOUSEY
      SHP%POL(IPOL)%N=N+1
      
      CALL POLYGON1PLOTSHAPE(IPOL); CALL UTL_PLOT2BITMAP()

     CASE (3)  !## right button
      SHP%POL(IPOL)%N=SHP%POL(IPOL)%N-1
      CALL POLYGON1PLOTSHAPE(IPOL); CALL UTL_PLOT2BITMAP()
      EXIT
    END SELECT

   !## bitmap scrolled, renew top-left pixel coordinates
   CASE (BITMAPSCROLLED)
    MPW%IX=MESSAGE%VALUE1
    MPW%IY=MESSAGE%VALUE2

!   CASE (EXPOSE)
!     IF(WMENUGETSTATE(ID_PLOTLEGEND,2).EQ.1)CALL LEGPLOT_PLOTUPDATE(.FALSE.)
!     CALL DBL_IGRUNITS(MPW%XMIN,MPW%YMIN,MPW%XMAX,MPW%YMAX)

  END SELECT
 END DO

 SELECT CASE (SHP%POL(IPOL)%ITYPE)

  CASE (ID_POLYGON)
   IF(SHP%POL(IPOL)%N.LT.3)THEN
    CALL UTL_PLOT1BITMAP(); CALL POLYGON1PLOTSHAPE(IPOL); CALL UTL_PLOT2BITMAP()
    SHP%POL(IPOL)%N=0
   ENDIF
  
  CASE (ID_POINT)

  CASE (ID_LINE,ID_CIRCLE,ID_RECTANGLE)
   IF(SHP%POL(IPOL)%N.LT.2)THEN
    CALL UTL_PLOT1BITMAP(); CALL POLYGON1PLOTSHAPE(IPOL); CALL UTL_PLOT2BITMAP()
    SHP%POL(IPOL)%N=0
   ENDIF
  
 END SELECT

 SHP%POL(IPOL)%ICOLOR=UTL_INVERSECOLOUR(SHP%POL(IPOL)%ICOLOR)

 CALL WCURSORSHAPE(CURARROW)
 CALL IGRPLOTMODE(MODECOPY)
 CALL IGRFILLPATTERN(OUTLINE)
 CALL IGRLINETYPE(SOLIDLINE)
 CALL IGRLINEWIDTH(1)

 END SUBROUTINE POLYGON1DRAW
 
 !###======================================================================
 SUBROUTINE POLYGON1DRAWSHAPE(I1,I2,LPLOT)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: I1,I2
 LOGICAL,INTENT(IN),OPTIONAL :: LPLOT
 LOGICAL :: LP
 INTEGER :: I
 
 LP=.TRUE.; IF(PRESENT(LPLOT))LP=LPLOT

 CALL UTL_PLOT1BITMAP()
 CALL IGRPLOTMODE(MODEXOR)

 IF(I1.GT.0.AND.I2.GT.0)THEN
  !## draw actual shapes
  DO I=I1,I2
   IF(SHP%POL(I)%N.GT.0)THEN
    SHP%POL(I)%ICOLOR=UTL_INVERSECOLOUR(SHP%POL(I)%ICOLOR)
    CALL POLYGON1PLOTSHAPE(I)
    SHP%POL(I)%ICOLOR=UTL_INVERSECOLOUR(SHP%POL(I)%ICOLOR)
   ENDIF
  ENDDO
 ENDIF

 !## plot ysel if available
 CALL POLYGON1DRAWYSEL()

 IF(LP)CALL UTL_PLOT2BITMAP()
 CALL IGRPLOTMODE(MODECOPY)
 CALL IGRFILLPATTERN(OUTLINE)
 CALL IGRLINETYPE(SOLIDLINE)

 END SUBROUTINE POLYGON1DRAWSHAPE

 !###======================================================================
 SUBROUTINE POLYGON1PLOTSHAPE(IPOL)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IPOL
 REAL(KIND=DP_KIND) :: DX,X1,X2,Y1,Y2,X,Y,WX1,WX2,WY1,WY2,RAT,THEIGHT,TWIDTH
 INTEGER :: I
 
 IF(SHP%POL(IPOL)%N.LE.0)RETURN

 CALL WGROFONTSWISS()

 CALL IGRCOLOURN(SHP%POL(IPOL)%ICOLOR)
 CALL IGRFILLPATTERN(OUTLINE)
 CALL IGRLINETYPE(SOLIDLINE)
 CALL IGRLINEWIDTH(SHP%POL(IPOL)%IWIDTH)

 DX=SQRT((MPW%XMAX-MPW%XMIN)**2.0D0+(MPW%YMAX-MPW%YMIN)**2.0D0)/500.0D0

 SELECT CASE (SHP%POL(IPOL)%ITYPE)

  CASE (ID_RECTANGLE)
   X1=MIN(SHP%POL(IPOL)%X(1),SHP%POL(IPOL)%X(2))
   X2=MAX(SHP%POL(IPOL)%X(1),SHP%POL(IPOL)%X(2))
   Y1=MIN(SHP%POL(IPOL)%Y(1),SHP%POL(IPOL)%Y(2))
   Y2=MAX(SHP%POL(IPOL)%Y(1),SHP%POL(IPOL)%Y(2))
   IF(X1.EQ.X2)X2=X2+1; IF(Y1.EQ.Y2)Y2=Y2+1
   CALL DBL_IGRRECTANGLE(X1,Y1,X2,Y2,IOFFSET=1)
   X=(X1+X2)/2.0D0; Y=(Y1+Y2)/2.0D0

  CASE (ID_POLYGON)
   !## draw lines
   IF(SHP%POL(IPOL)%N.EQ.2)THEN
    CALL DBL_IGRPOLYLINE(SHP%POL(IPOL)%X,SHP%POL(IPOL)%Y,SHP%POL(IPOL)%N,IOFFSET=1)
   !## draw polygon
   ELSE
    CALL DBL_IGRPOLYGONSIMPLE(SHP%POL(IPOL)%X,SHP%POL(IPOL)%Y,SHP%POL(IPOL)%N,IOFFSET=1)
   ENDIF
   !## get appropriate point - first coordinate
   X=SUM(SHP%POL(IPOL)%X(1:SHP%POL(IPOL)%N))/REAL(SHP%POL(IPOL)%N,8)
   Y=SUM(SHP%POL(IPOL)%X(1:SHP%POL(IPOL)%N))/REAL(SHP%POL(IPOL)%N,8)

  CASE (ID_POINT)
   DO I=1,SHP%POL(IPOL)%N; CALL DBL_IGRCIRCLE(SHP%POL(IPOL)%X(I),SHP%POL(IPOL)%Y(I),DX*2.0D0,IOFFSET=1); END DO
   X=SHP%POL(IPOL)%X(1); Y=SHP%POL(IPOL)%Y(1)

  CASE (ID_LINE)
   CALL DBL_IGRPOLYLINE(SHP%POL(IPOL)%X,SHP%POL(IPOL)%Y,SHP%POL(IPOL)%N,IOFFSET=1)
   X=SHP%POL(IPOL)%X(1); Y=SHP%POL(IPOL)%Y(1)

  CASE (ID_CIRCLE)
   RAT=(SHP%POL(IPOL)%X(1)-SHP%POL(IPOL)%X(2))**2.0D0+ &
       (SHP%POL(IPOL)%Y(1)-SHP%POL(IPOL)%Y(2))**2.0D0
   IF(RAT.GT.0.0D0)THEN
    RAT=SQRT(RAT)
    CALL DBL_IGRCIRCLE(SHP%POL(IPOL)%X(1),SHP%POL(IPOL)%Y(1),RAT,IOFFSET=1)
   ENDIF
   
 END SELECT

 CALL IGRLINEWIDTH(1)

 IF(SHP%POL(IPOL)%IACT.EQ.1)THEN

  !## draw shapename
  WX1=WINFOGRREAL(GRAPHICSUNITMINX)! (7) LEFT LIMIT OF MAIN GRAPHICS AREA
  WY1=WINFOGRREAL(GRAPHICSUNITMINY)! (8) LOWER LIMIT OF MAIN GRAPHICS AREA
  WX2=WINFOGRREAL(GRAPHICSUNITMAXX)! (9) RIGHT LIMIT OF MAIN GRAPHICS AREA
  WY2=WINFOGRREAL(GRAPHICSUNITMAXY)! (10) UPPER LIMIT OF
  RAT=(WX2-WX1)/(WY2-WY1)
  !## textsize in graphical dimensions
  THEIGHT=0.03D0
  TWIDTH =THEIGHT/(0.03333D0/0.01333D0)/RAT

  CALL DBL_WGRTEXTFONT(IFAMILY=FFSOFTWARE,TWIDTH=TWIDTH,THEIGHT=THEIGHT,ISTYLE=FSBOLD) 
  CALL DBL_WGRTEXTORIENTATION(IALIGN=ALIGNCENTRE,ANGLE=0.0D0,IDIR=DIRHORIZ,NALIGN=ALIGNLEFT)
  CALL DBL_WGRTEXTSTRING(X,Y,TRIM(SHP%POL(IPOL)%PNAME),IOFFSET=1)

  !## draw boxes
  DO I=1,SHP%POL(IPOL)%N
   CALL DBL_IGRRECTANGLE(SHP%POL(IPOL)%X(I)-DX,SHP%POL(IPOL)%Y(I)-DX,SHP%POL(IPOL)%X(I)+DX,SHP%POL(IPOL)%Y(I)+DX,IOFFSET=1)
  END DO
 
 ENDIF
 
 END SUBROUTINE POLYGON1PLOTSHAPE

 !###======================================================================
 SUBROUTINE POLYGON1DRAWYSEL()
 !###======================================================================
 IMPLICIT NONE
 INTEGER,PARAMETER :: MYSEL=1000000
 INTEGER :: I

 IF(.NOT.ALLOCATED(SELIDF))RETURN
 IF(.NOT.LPLOTYSEL)RETURN

 IF(SELIDF(1)%NTHREAD.GT.MYSEL)THEN
  CALL WMESSAGEBOX(YESNO,QUESTIONICON,COMMONNO,'Are you sure to draw '//TRIM(ITOS(SELIDF(1)%NTHREAD))//' selected cell?'//CHAR(13)// &
      'Click No to skip drawing these cells, click YES to draw them.'//CHAR(13)//'Be aware in that case, it can take a while.','Question')
  IF(WINFODIALOG(4).NE.1)THEN; LPLOTYSEL=.FALSE.; RETURN; ENDIF
 ENDIF
 
 CALL UTL_PLOT1BITMAP()
 CALL IGRPLOTMODE(MODEXOR)
 CALL IGRCOLOURN(WRGB(255,255,255))
 CALL IGRFILLPATTERN(SOLID)

 DO I=1,SELIDF(1)%NTHREAD
  CALL POLYGON1PLOTYSEL(I)
 ENDDO

 CALL UTL_PLOT2BITMAP()
 CALL IGRPLOTMODE(MODECOPY)

 END SUBROUTINE POLYGON1DRAWYSEL

 !###======================================================================
 SUBROUTINE POLYGON1PLOTYSEL(I)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: I
 INTEGER :: IROW,ICOL

 IF(SELIDF(1)%IEQ.EQ.0)THEN
  CALL DBL_IGRRECTANGLE(SELIDF(1)%XMIN+(SELIDF(1)%YSEL(1,I)-1)*SELIDF(1)%DX, &
                    SELIDF(1)%YMAX-(SELIDF(1)%YSEL(2,I)-1)*SELIDF(1)%DY, &
                    SELIDF(1)%XMIN+ SELIDF(1)%YSEL(1,I)   *SELIDF(1)%DX, &
                    SELIDF(1)%YMAX- SELIDF(1)%YSEL(2,I)   *SELIDF(1)%DY,IOFFSET=1)
 ELSEIF(SELIDF(1)%IEQ.EQ.1)THEN
  ICOL=INT(SELIDF(1)%YSEL(1,I))
  IROW=INT(SELIDF(1)%YSEL(2,I))
  CALL DBL_IGRRECTANGLE(SELIDF(1)%SX(ICOL-1),SELIDF(1)%SY(IROW-1), &
                        SELIDF(1)%SX(ICOL)  ,SELIDF(1)%SY(IROW),IOFFSET=1)
 ENDIF

 END SUBROUTINE POLYGON1PLOTYSEL

END MODULE MOD_POLYGON_DRAW


