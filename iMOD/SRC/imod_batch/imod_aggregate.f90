MODULE MOD_AGGREGATE
 
 USE MOD_UTL, ONLY : UTL_CREATEDIR,UTL_IDFSNAPTOGRID_LLC
 USE MOD_IDF
 USE MOD_AGGREGATE_PAR

 CONTAINS

 !###===========================
 SUBROUTINE LHM_CONVERTREGIS_MAIN()
 !###===========================
 IMPLICIT NONE

 !## initialize
 CALL LHM_CONVERTREGIS_SORTFILES(FLIST,SORTFILE,INDIR,0)
 
 SELECT CASE (IMODE)
  !## make dataset consistent
  CASE (1); CALL LHM_CONVERTREGIS()
  !## include additional data
  CASE (2); CALL LHM_CONVERTREGIS_SORTFILES(ALIST,IWHBFILE,IWHBDIR,1); CALL LHM_ADDIWHB()
  !## aggregate dataset
  CASE (3); CALL LHM_CONVERTREGIS_AGGREGATE(); IF(IPRJ.EQ.1)CALL LHM_CONVERTREGIS_WRITEPRJ()
 END SELECT

 END SUBROUTINE LHM_CONVERTREGIS_MAIN

 !###===========================
 SUBROUTINE LHM_CONVERTREGIS_SORTFILES(SLIST,OFILE,DIR,IMETHOD)
 !###===========================
 IMPLICIT NONE
 TYPE(FOBJ),INTENT(INOUT),POINTER,DIMENSION(:) :: SLIST
 CHARACTER(LEN=*),INTENT(IN) :: OFILE,DIR
 INTEGER,INTENT(IN) :: IMETHOD
 INTEGER :: I,J,N,M,IU,IOS
 LOGICAL :: LEX
 
 !## open unit for same line printing of echo (is equal to screen or '*')
 OPEN(UNIT=6,CARRIAGECONTROL='FORTRAN') 

 IU=UTL_GETUNIT(); OPEN(IU,FILE=OFILE,STATUS='OLD',ACTION='READ'); ALLOCATE(SLIST(1)); READ(IU,*)
 DO I=1,2; M=1; N=1; DO
   IF(I.EQ.2.AND.M.GT.SIZE(SLIST))EXIT
   SLIST(M)%FILE=''
   IF(IMETHOD.EQ.0)THEN
    READ(IU,*,IOSTAT=IOS) (SLIST(M)%FILE(J),J=1,SIZE(SLIST(M)%FILE)); IF(IOS.NE.0)EXIT
   ELSE
    READ(IU,*,IOSTAT=IOS) (SLIST(M)%FILE(J),J=1,SIZE(SLIST(M)%FILE)),SLIST(M)%ITOP,SLIST(M)%IBOT,SLIST(M)%METH; IF(IOS.NE.0)EXIT
   ENDIF
   N=N+1; IF(I.EQ.2)M=N
  ENDDO
  IF(I.EQ.1)THEN
   DEALLOCATE(SLIST)
   IF(N-1.LE.0)THEN; WRITE(*,'(/A/)') 'CANNOT FIND APPROPRIATE FILES FROM '//TRIM(OFILE); STOP; ENDIF
   ALLOCATE(SLIST(N-1))
  ENDIF
  REWIND(IU); READ(IU,*)
 ENDDO; CLOSE(IU)

 !## check files
 DO I=1,SIZE(SLIST)
  DO J=1,SIZE(SLIST(I)%FILE)
   IF(TRIM(SLIST(I)%FILE(J)).NE.'')THEN
    READ(SLIST(I)%FILE(J),*,IOSTAT=IOS) SLIST(I)%XVAL(J)
    IF(IOS.NE.0)THEN
     SLIST(I)%ITYPE(J)=0; SLIST(I)%XVAL(J)=HUGE(1.0D0)
     INQUIRE(FILE=TRIM(DIR)//'\'//TRIM(SLIST(I)%FILE(J)),EXIST=LEX)
     IF(.NOT.LEX)THEN
      WRITE(*,'(/A/)') 'Cannot find file '//TRIM(INDIR)//'\'//TRIM(SLIST(I)%FILE(J))
      STOP
     ENDIF
     SLIST(I)%FILE(J)=UTL_CAP(SLIST(I)%FILE(J),'U')
    ELSE
     SLIST(I)%ITYPE(J)=1
    ENDIF
   ELSE
    !## missing value
    SLIST(I)%ITYPE(J)=-1; SLIST(I)%XVAL(J)=-999.0D0
   ENDIF
  ENDDO
 ENDDO
 CLOSE(IU)
 
 END SUBROUTINE LHM_CONVERTREGIS_SORTFILES

 !###===========================
 SUBROUTINE LHM_ADDIWHB()
 !###===========================
 IMPLICIT NONE
 INTEGER :: I,II,III,J,K,L,N,M,O,IROW,ICOL,IU,NS
 REAL(KIND=DP_KIND) :: F,T,B
 INTEGER,DIMENSION(:),ALLOCATABLE :: NL
 TYPE(IDFOBJ) :: MDL
 TYPE(IDFOBJ),ALLOCATABLE,DIMENSION(:) :: IDF
 
 CALL IDFNULLIFY(MDL); ALLOCATE(IDF(5)); DO I=1,SIZE(IDF); CALL IDFNULLIFY(IDF(I)); ENDDO

 !## specify window
 IF(IWINDOW.EQ.1)THEN
  MDL%XMIN=XMIN; MDL%XMAX=XMAX; MDL%YMIN=YMIN; MDL%YMAX=YMAX; MDL%DX=CELLSIZE; MDL%DY=MDL%DX
  CALL UTL_IDFSNAPTOGRID_LLC(MDL%XMIN,MDL%XMAX,MDL%YMIN,MDL%YMAX,MDL%DX,MDL%DY,MDL%NCOL,MDL%NROW,.TRUE.)
 ELSE
  IF(.NOT.IDFREAD(MDL,FLIST(1)%FILE(1),0))STOP
 ENDIF
 
 N=SIZE(FLIST)+SIZE(ALIST); ALLOCATE(FM(N),NL(N))

 N=SIZE(FLIST); DO I=1,N

  !## read data
  IF(.NOT.LHM_ADDIWHB_READFLIST(MDL,IDF(1),IDF(2),IDF(3),IDF(4),IDF(5),SIZE(FLIST(I)%FILE),FLIST(I)%FILE,INDIR))STOP
  CALL LHM_ADDIWHB_ADDDATA(I,FLIST(I)%FILE,IDF); FM(I)%IORDER=I
  
  F=100.0D0*DBLE(I)/DBLE(N); WRITE(6,'(A)') '+READING '//TRIM(FLIST(I)%FILE(1))//'('//TRIM(RTOS(F,'F',2))//'%)         '

 ENDDO

 !## modifying the solid
 N=SIZE(FLIST)+SIZE(ALIST); J=0; DO I=SIZE(FLIST)+1,N
  !## read data
  J=J+1
  IF(.NOT.LHM_ADDIWHB_READFLIST(MDL,IDF(1),IDF(2),IDF(3),IDF(4),IDF(5),SIZE(ALIST(J)%FILE),ALIST(J)%FILE,IWHBDIR))STOP
  F=100.0D0*DBLE(J)/DBLE(SIZE(ALIST)); WRITE(6,'(A)') '+READING '//TRIM(ALIST(J)%FILE(1))//'('//TRIM(RTOS(F,'F',2))//'%)          '

  !## read in data
  CALL LHM_ADDIWHB_ADDDATA(I,ALIST(J)%FILE,IDF)

  SELECT CASE (ALIST(J)%METH)
   !## find location
   CASE (1)
    !## check minimum and maximum layer to insert layer
    CALL LHM_ADDIWHB_GETMAXLAYER(I,SIZE(NL),NL,IDF); IF(SUM(NL).EQ.0)CYCLE
    !## get layer
    L=0; K=0; DO II=1,SIZE(NL); IF(NL(II).GT.K)THEN; K=NL(II); L=II; ENDIF; ENDDO; FM(I)%IORDER=L
    !## shift all others
    DO II=1,I-1; IF(FM(II)%IORDER.GE.L)FM(II)%IORDER=FM(II)%IORDER+1; ENDDO
   !## fixed location
   CASE (2,3)
    DO L=1,SIZE(NL); IF(FM(L)%IORDER.EQ.ALIST(J)%ITOP)EXIT; ENDDO; FM(I)%IORDER=L
  END SELECT
  
  SELECT CASE (ALIST(J)%METH)
   CASE (1)
    !## correct all others for this inserted layer
    CALL LHM_ADDIWHB_INSERT_IWHB(I,IDF)
   CASE (2,3)
    !## fixed location
    CALL LHM_ADDIWHB_REPLACE_IWHB(I,ALIST(J)%METH,IDF)
    !## correct all others for this inserted layer
    CALL LHM_ADDIWHB_INSERT_IWHB(I,IDF)
  END SELECT
  
 ENDDO
! DO I=1,N; WRITE(*,*) I,FM(I)%IORDER; ENDDO
 
 CALL UTL_CREATEDIR(OUTDIR); IU=UTL_GETUNIT(); OPEN(IU,FILE=TRIM(OUTDIR)//'\IWHB_SORTFILE.TXT',STATUS='UNKNOWN',ACTION='WRITE')
 WRITE(IU,'(5A32)') 'TOP','BOT','KH','KV','VA'

 !## need to be completed ... fill with previous values
 IF(.NOT.LHM_ADDIWHB_READFLIST(MDL,IDF(1),IDF(2),IDF(3),IDF(4),IDF(5),SIZE(FLIST(1)%FILE),FLIST(1)%FILE,INDIR))STOP
 IF(IDF(5)%NCOL.LE.0)CALL IDFCOPY(IDF(1),IDF(5)); IDF(2)%X=IDF(1)%X
 
 !## number of formations
 N=SIZE(FM); DO III=1,N
  
  !## get correct number
  DO I=1,N; IF(FM(I)%IORDER.EQ.III)EXIT; ENDDO
  !## nothing to do for this layer
  IF(I.GT.N)CYCLE
  
  !## number of subformations
  IF(.NOT.ASSOCIATED(FM(I)%SF))CYCLE
  M=SIZE(FM(I)%SF)
  DO J=1,M 
   IF(.NOT.ASSOCIATED(FM(I)%SF(J)%AT))CYCLE
   O=SIZE(FM(I)%SF(J)%AT); IF(O.EQ.0)EXIT

   DO II=3,5; IDF(II)%X=IDF(II)%NODATA; ENDDO
   
   NS=0
   DO L=1,O
    IROW=INT(FM(I)%SF(J)%AT(L)%IROW,4)
    ICOL=INT(FM(I)%SF(J)%AT(L)%ICOL,4)
    T=FM(I)%SF(J)%AT(L)%TP; B=FM(I)%SF(J)%AT(L)%BT
    !## due to aggregation layers can become zero thickness
    IF(T-B.GT.0.0D0)THEN
     NS=NS+1
     IDF(1)%X(ICOL,IROW)=FM(I)%SF(J)%AT(L)%TP
     IDF(2)%X(ICOL,IROW)=FM(I)%SF(J)%AT(L)%BT  
     IDF(3)%X(ICOL,IROW)=FM(I)%SF(J)%AT(L)%KH
     IDF(4)%X(ICOL,IROW)=FM(I)%SF(J)%AT(L)%KV
     IDF(5)%X(ICOL,IROW)=IDF(4)%X(ICOL,IROW)/IDF(3)%X(ICOL,IROW)
    ENDIF
   ENDDO
   
   !## nothing left from this layer
   IF(NS.EQ.0)CYCLE
   
   !## save idf files
   DO L=1,5
    IF(I.LE.SIZE(FLIST))THEN
     IDF(L)%FNAME=TRIM(OUTDIR)//'\'//TRIM(FLIST(I)%FILE(L))
    ELSE
     II=I-SIZE(FLIST)
     IDF(L)%FNAME=TRIM(OUTDIR)//'\'//TRIM(ALIST(II)%FILE(L))
    ENDIF
   ENDDO
   CALL LHM_CONVERTREGIS_OUTPUT(IDF(1),IDF(2),IDF(3),IDF(4),IDF(5))
   DO L=1,5
    II=INDEX(IDF(L)%FNAME,'\',.TRUE.); IF(II.NE.0)IDF(L)%FNAME=IDF(L)%FNAME(II+1:)
   ENDDO
   WRITE(IU,'(5A32)') (TRIM(IDF(L)%FNAME),L=1,5)

   DO L=1,O
    IROW=INT(FM(I)%SF(J)%AT(L)%IROW,4)
    ICOL=INT(FM(I)%SF(J)%AT(L)%ICOL,4)
    IDF(1)%X(ICOL,IROW)=FM(I)%SF(J)%AT(L)%BT
   ENDDO

  ENDDO

  II=LEN_TRIM(OUTDIR)
  F=100.0D0*DBLE(I)/DBLE(N); WRITE(6,'(A)') '+WRITING '//TRIM(IDF(1)%FNAME(II+2:))//'('//TRIM(RTOS(F,'F',2))//'%)         '
 
 ENDDO
 CLOSE(IU)

 DO I=1,SIZE(FM)
  IF(ASSOCIATED(FM(I)%SF))THEN
   DO J=1,SIZE(FM(I)%SF)
    IF(ASSOCIATED(FM(I)%SF(J)%AT))DEALLOCATE(FM(I)%SF(J)%AT)
   ENDDO
   DEALLOCATE(FM(I)%SF)
  ENDIF
 ENDDO
 DO I=1,SIZE(IDF); CALL IDFDEALLOCATEX(IDF(I)); CALL IDFDEALLOCATESX(IDF(I)); ENDDO
 
 END SUBROUTINE LHM_ADDIWHB
 
 !###===========================
 SUBROUTINE LHM_ADDIWHB_INSERT_IWHB(IFM,IDF)
 !###===========================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IFM
 TYPE(IDFOBJ),INTENT(INOUT),DIMENSION(5) :: IDF
 INTEGER :: I,II,J,K,N,IROW,ICOL,IORDER
 REAL(KIND=DP_KIND) :: T,B,VC,TR,DZ,TF,BF
 LOGICAL :: LTOP,LBOT
 REAL(KIND=DP_KIND),ALLOCATABLE,DIMENSION(:,:) :: DZT,DZB
 INTEGER,ALLOCATABLE,DIMENSION(:,:,:) :: BFM,IFP
 
 !## location of inserted layer
 IORDER=FM(IFM)%IORDER

 !## process current iwhb layer
 DO II=1,IFM

  !## skip this one as it is the current iwhb to be processed
  IF(II.EQ.IORDER)CYCLE

  LTOP=II.LT.IORDER
  LBOT=II.GT.IORDER

  !## get correct number
  DO I=1,IFM; IF(FM(I)%IORDER.EQ.II)EXIT; ENDDO
  !## nothing to insert
  IF(I.GT.IFM)CYCLE
  
  !## number of subformations
  IF(.NOT.ASSOCIATED(FM(I)%SF))CYCLE
  DO J=1,SIZE(FM(I)%SF)
   IF(.NOT.ASSOCIATED(FM(I)%SF(J)%AT))CYCLE
   N=SIZE(FM(I)%SF(J)%AT); IF(N.EQ.0)EXIT
   DO K=1,N
    IROW=INT(FM(I)%SF(J)%AT(K)%IROW,4)
    ICOL=INT(FM(I)%SF(J)%AT(K)%ICOL,4)

    T=IDF(1)%X(ICOL,IROW); B=IDF(2)%X(ICOL,IROW)
    !## new iwhb has a thickness here - correct if needed
    IF(T-B.GT.0.0D0)THEN
     
     DZ=FM(I)%SF(J)%AT(K)%TP-FM(I)%SF(J)%AT(K)%BT
     TR=DZ*FM(I)%SF(J)%AT(K)%KH
     VC=DZ/FM(I)%SF(J)%AT(K)%KV
     
     !## layers above
     IF(LTOP)THEN
      FM(I)%SF(J)%AT(K)%TP=MAX(FM(I)%SF(J)%AT(K)%TP,T)
      FM(I)%SF(J)%AT(K)%BT=MAX(FM(I)%SF(J)%AT(K)%BT,T)
     !## layer underneath
     ELSEIF(LBOT)THEN
      FM(I)%SF(J)%AT(K)%TP=MIN(FM(I)%SF(J)%AT(K)%TP,B)
      FM(I)%SF(J)%AT(K)%BT=MIN(FM(I)%SF(J)%AT(K)%BT,B)
     ENDIF

     !## new dz
     DZ=FM(I)%SF(J)%AT(K)%TP-FM(I)%SF(J)%AT(K)%BT
     !## correct if possible
     IF(DZ.LE.0.0D0)THEN; FM(I)%SF(J)%AT(K)%KH=0.0D0; FM(I)%SF(J)%AT(K)%KV=0.0D0; ENDIF

    ENDIF
   ENDDO
  ENDDO
 ENDDO
 
 !## find formation(s) nearest from top and bottom
 ALLOCATE(DZT(IDF(1)%NCOL,IDF(1)%NROW)); DZT=HUGE(1.0)
 ALLOCATE(DZB(IDF(1)%NCOL,IDF(1)%NROW)); DZB=HUGE(1.0)
 ALLOCATE(BFM(IDF(1)%NCOL,IDF(1)%NROW,2)); BFM=0
 ALLOCATE(IFP(IDF(1)%NCOL,IDF(1)%NROW,2)); IFP=0
 
 !## correct for caps
 DO II=1,IFM-1
  IF(.NOT.ASSOCIATED(FM(II)%SF))CYCLE
  DO J=1,SIZE(FM(II)%SF)
   IF(.NOT.ASSOCIATED(FM(II)%SF(J)%AT))CYCLE
   N=SIZE(FM(II)%SF(J)%AT); IF(N.EQ.0)EXIT
   DO K=1,N
    TF=FM(II)%SF(J)%AT(K)%TP; BF=FM(II)%SF(J)%AT(K)%BT; IF(TF-BF.LE.0.0D0)CYCLE
    IROW=INT(FM(II)%SF(J)%AT(K)%IROW,4); ICOL=INT(FM(II)%SF(J)%AT(K)%ICOL,4)
    T=IDF(1)%X(ICOL,IROW); B=IDF(2)%X(ICOL,IROW)
    IF(T.EQ.IDF(1)%NODATA.OR.B.EQ.IDF(2)%NODATA)CYCLE
    !## skip if not a new location for a potential "leak"
    IF(T-B.LE.0.0D0)CYCLE
    !## compute distance above
    DZ=BF-T
    IF(DZ.GT.0.0D0.AND.DZ.LE.DZT(ICOL,IROW))THEN
     DZT(ICOL,IROW)=DZ; BFM(ICOL,IROW,1)=II; IFP(ICOL,IROW,1)=K
    ENDIF
    !## compute distance below
    DZ=B-TF
    IF(DZ.GT.0.0D0.AND.DZ.LE.DZB(ICOL,IROW))THEN
     DZB(ICOL,IROW)=DZ; BFM(ICOL,IROW,2)=II; IFP(ICOL,IROW,2)=K
    ENDIF
   ENDDO
  ENDDO
 ENDDO

 !## correct single formation above and below
 !## zero thickness is absent anyhow
 
!   !## fill in updated top/bottom
!   DO II=1,IFM
!    IF(.NOT.ASSOCIATED(FM(II)%SF))CYCLE
!    DO J=1,SIZE(FM(II)%SF)
!     IF(.NOT.ASSOCIATED(FM(II)%SF(J)%AT))CYCLE
!     K=ID(II); IF(K.NE.0)THEN
!      FM(II)%SF(J)%AT(K)%TP=TF(II)
!      FM(II)%SF(J)%AT(K)%BT=BF(II)
!     ENDIF
!    ENDDO
!   ENDDO
    
!  ENDIF
! ENDDO; ENDDO
 
 DEALLOCATE(DZT,DZB,IFP,BFM)
 
 END SUBROUTINE LHM_ADDIWHB_INSERT_IWHB
 
 !###===========================
 SUBROUTINE LHM_ADDIWHB_REPLACE_IWHB(IFM,IMETH,IDF)
 !###===========================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IFM,IMETH
 TYPE(IDFOBJ),INTENT(INOUT),DIMENSION(5) :: IDF 
 INTEGER :: I,J,N,IROW,ICOL,IORDER
 REAL(KIND=DP_KIND) :: T,B,TP,BT,D,TR,VC,KH,KV
 
 !## location of inserted layer
 IORDER=FM(IFM)%IORDER

 !## combine with existing data
 IF(ASSOCIATED(FM(IORDER)%SF))THEN
  DO I=1,SIZE(FM(IORDER)%SF)
   IF(.NOT.ASSOCIATED(FM(IORDER)%SF(I)%AT))CYCLE
   DO J=1,SIZE(FM(IORDER)%SF(I)%AT)
  
    IROW=FM(IORDER)%SF(I)%AT(J)%IROW
    ICOL=FM(IORDER)%SF(I)%AT(J)%ICOL
    TP  =FM(IORDER)%SF(I)%AT(J)%TP
    BT  =FM(IORDER)%SF(I)%AT(J)%BT
    KH  =FM(IORDER)%SF(I)%AT(J)%KH
    KV  =FM(IORDER)%SF(I)%AT(J)%KV

    T=IDF(1)%X(ICOL,IROW); B=IDF(2)%X(ICOL,IROW)

    !## new data available here
    IF(T.NE.IDF(1)%NODATA.AND.B.NE.IDF(2)%NODATA.AND.(T-B).GT.0.0D0)THEN
     TR=0.0D0; VC=0.0D0
    
     !## add to an existing layer
     IF(IMETH.EQ.3)THEN
      !## remaining original thickness
      D=MAX(0.0D0,(TP-BT)-(T-B))
      !## remaining transmissivity
      TR=D*KH
      !## remaining vertical resistance
      VC=D/KV
     ENDIF
    
     !## compute thickness
     D=T-B

     KH=IDF(3)%X(ICOL,IROW)
     KV=IDF(4)%X(ICOL,IROW)
     !## compute total transmissivity
     TR=TR+D*KH
     !## compute total vertical resistance
     VC=VC+D/KV

     IF(IMETH.EQ.3)THEN
      !## update top- and bottom values
      T=MAX(TP,T)
      B=MIN(BT,B)
     ENDIF
    
     !## recompute representative k-values
     D =T-B
     KH=TR/D
     KV=D/VC

     !## save updated values
     IDF(1)%X(ICOL,IROW)=T
     IDF(2)%X(ICOL,IROW)=B
     IDF(3)%X(ICOL,IROW)=KH
     IDF(4)%X(ICOL,IROW)=KV
   
    !## no update here needed, copy existing data
    ELSE
   
     IDF(1)%X(ICOL,IROW)=TP; IDF(2)%X(ICOL,IROW)=BT
     IDF(3)%X(ICOL,IROW)=KH; IDF(4)%X(ICOL,IROW)=KV
     
    ENDIF
   
   ENDDO
  ENDDO
 ENDIF
 
 !## get size of to be total combined inserted layer
 N=0; DO IROW=1,IDF(1)%NROW; DO ICOL=1,IDF(1)%NCOL
  T=IDF(1)%X(ICOL,IROW); B=IDF(2)%X(ICOL,IROW)
  IF(T.EQ.IDF(1)%NODATA.OR.B.EQ.IDF(2)%NODATA)CYCLE
  IF(T-B.GT.0.0D0)N=N+1
 ENDDO; ENDDO
 
 !## remove current layer
 IF(ASSOCIATED(FM(IORDER)%SF))THEN
  DO J=1,SIZE(FM(IORDER)%SF); IF(ASSOCIATED(FM(IORDER)%SF(J)%AT))DEALLOCATE(FM(IORDER)%SF(J)%AT); ENDDO
 ENDIF
 
 !## fill in new object of this layer
 ALLOCATE(FM(IORDER)%SF(1)%AT(N))
 
 !## add new layer to it - correct top/bot en k-values
 N=0; DO IROW=1,IDF(1)%NROW; DO ICOL=1,IDF(1)%NCOL
  T=IDF(1)%X(ICOL,IROW); B=IDF(2)%X(ICOL,IROW)
  IF(T.EQ.IDF(1)%NODATA.OR.B.EQ.IDF(2)%NODATA)CYCLE
  IF(T-B.GT.0.0D0)THEN
   N=N+1
   FM(IORDER)%SF(1)%AT(N)%IROW=INT(IROW,2)
   FM(IORDER)%SF(1)%AT(N)%ICOL=INT(ICOL,2)
   FM(IORDER)%SF(1)%AT(N)%TP  =IDF(1)%X(ICOL,IROW)
   FM(IORDER)%SF(1)%AT(N)%BT  =IDF(2)%X(ICOL,IROW)
   FM(IORDER)%SF(1)%AT(N)%KH  =IDF(3)%X(ICOL,IROW)
   FM(IORDER)%SF(1)%AT(N)%KV  =IDF(4)%X(ICOL,IROW)
  ENDIF   
 ENDDO; ENDDO
 
 END SUBROUTINE LHM_ADDIWHB_REPLACE_IWHB

 !###===========================
 SUBROUTINE LHM_ADDIWHB_ADDDATA(IFM,FNAME,IDF)
 !###===========================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IFM
 CHARACTER(LEN=*),INTENT(IN),DIMENSION(:) :: FNAME
 TYPE(IDFOBJ),INTENT(INOUT),DIMENSION(5) :: IDF
 INTEGER :: I,M,IROW,ICOL
 REAL(KIND=DP_KIND) :: T,B
 
 DO I=1,2
  M=0; DO IROW=1,IDF(1)%NROW; DO ICOL=1,IDF(1)%NCOL
   T=IDF(1)%X(ICOL,IROW); B=IDF(2)%X(ICOL,IROW)
   IF(T.NE.IDF(1)%NODATA.AND.B.NE.IDF(2)%NODATA)THEN
    IF(T-B.GT.0.0D0)THEN
     M=M+1
     IF(I.EQ.2)THEN
      FM(IFM)%SF(1)%AT(M)%IROW=INT(IROW,2)
      FM(IFM)%SF(1)%AT(M)%ICOL=INT(ICOL,2)
      FM(IFM)%SF(1)%AT(M)%TP  =T
      FM(IFM)%SF(1)%AT(M)%BT  =B
      FM(IFM)%SF(1)%AT(M)%KH  =IDF(3)%X(ICOL,IROW)
      FM(IFM)%SF(1)%AT(M)%KV  =IDF(4)%X(ICOL,IROW)
     ENDIF
    ENDIF
   ENDIF
  ENDDO; ENDDO
  IF(I.EQ.1)THEN; ALLOCATE(FM(IFM)%SF(MF)); ALLOCATE(FM(IFM)%SF(1)%AT(M)); ENDIF
 ENDDO
 DO I=1,5; IDF(I)%FNAME=ADJUSTL(FNAME(I)); ENDDO
 
 END SUBROUTINE LHM_ADDIWHB_ADDDATA
 
 !###===========================
 SUBROUTINE LHM_ADDIWHB_GETMAXLAYER(IFM,N,NL,IDF)
 !###===========================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IFM,N
 INTEGER,INTENT(OUT),DIMENSION(N) :: NL
 TYPE(IDFOBJ),INTENT(INOUT),DIMENSION(5) :: IDF
 INTEGER :: IROW,ICOL,I,J,K,NNODATA,M,NTHICKN
 REAL(KIND=DP_KIND) :: T,B,TF,BF
 
 NL=0; NNODATA=0; NTHICKN=0
 
 !## check formations till now
ILOOP: DO I=1,IFM-1
  IF(.NOT.ASSOCIATED(FM(I)%SF))CYCLE
  !## number of subformations
  DO J=1,SIZE(FM(I)%SF)
   IF(.NOT.ASSOCIATED(FM(I)%SF(J)%AT))CYCLE
   M=SIZE(FM(I)%SF(J)%AT); IF(M.EQ.0)EXIT
   DO K=1,M
    IROW=INT(FM(I)%SF(J)%AT(K)%IROW,4)
    ICOL=INT(FM(I)%SF(J)%AT(K)%ICOL,4)
    
    T   =IDF(1)%X(ICOL,IROW)
    B   =IDF(2)%X(ICOL,IROW)
    !## no thickness of current iwhb layer
    IF(T-B.LE.0.0D0)CYCLE

    NTHICKN=NTHICKN+1
    NNODATA=1
    TF  =FM(I)%SF(J)%AT(K)%TP
    BF  =FM(I)%SF(J)%AT(K)%BT
    IF(TF.GT.T.AND.BF.LE.T)NL(I)=NL(I)+1
    IF(BF.LE.B.AND.TF.GT.B)NL(I)=NL(I)+1

   ENDDO
  ENDDO
 ENDDO ILOOP
  
 !## find nothing but there is something to add
 IF(SUM(NL).EQ.0.AND.NTHICKN.GT.0)THEN
  IF(NNODATA.EQ.0)NL(1)=1   !## nodata found underneath this formation --- add it to layer 1
  IF(NNODATA.EQ.1)NL(IFM)=1 !## probably underneath existing formations -- add it below layer ifm-1
 ENDIF
 
 END SUBROUTINE LHM_ADDIWHB_GETMAXLAYER

 !###===========================
 LOGICAL FUNCTION LHM_ADDIWHB_READFLIST(IDF,TP,BT,KH,KV,VA,N,LIST,DIR)  
 !###===========================
 IMPLICIT NONE
 TYPE(IDFOBJ),INTENT(INOUT) :: IDF,TP,BT,KH,KV,VA
 CHARACTER(LEN=*),INTENT(IN) :: DIR
 INTEGER,INTENT(IN) :: N
 CHARACTER(LEN=256) :: FN
 INTEGER :: ICOL,IROW,IOS,J,JJ
 REAL(KIND=DP_KIND) :: X
 CHARACTER(LEN=*),DIMENSION(N) :: LIST
 CHARACTER(LEN=256) :: FTXT
LOGICAL :: LEX
 
 LHM_ADDIWHB_READFLIST=.FALSE.
 
 FN=TRIM(DIR)//'\'//TRIM(LIST(1))
 IF(IWINDOW.EQ.1)THEN
  CALL IDFCOPY(IDF,TP); IF(.NOT.IDFREADSCALE(FN,TP,10,1,0.0D0,0))THEN; WRITE(*,'(/A/)') 'ERROR READING '//TRIM(FN); STOP; ENDIF 
 ELSE
  IF(.NOT.IDFREAD(TP,FN,1))THEN; WRITE(*,'(/A/)') 'ERROR READING '//TRIM(FN); STOP; ENDIF 
 ENDIF
  
 FN=TRIM(DIR)//'\'//TRIM(LIST(2)) 
 IF(IWINDOW.EQ.1)THEN
  CALL IDFCOPY(IDF,BT); IF(.NOT.IDFREADSCALE(FN,BT,10,1,0.0D0,0))THEN; WRITE(*,'(/A/)') 'ERROR READING '//TRIM(FN); STOP; ENDIF 
 ELSE
  IF(.NOT.IDFREAD(BT,FN,1))THEN; WRITE(*,'(/A/)') 'ERROR READING '//TRIM(FN); STOP; ENDIF
 ENDIF
 
 !## make sure with constant values not to add dir
 LEX=.FALSE.; IF(TRIM(LIST(3)).NE.'')THEN
  READ(LIST(3),*,IOSTAT=IOS) X; IF(IOS.NE.0)THEN; FN=TRIM(DIR)//'\'//TRIM(LIST(3)); ELSE; FN=TRIM(LIST(3)); LEX=.TRUE.; ENDIF
  IF(IWINDOW.EQ.1)THEN
   CALL IDFCOPY(IDF,KH); IF(.NOT.IDFREADSCALE(FN,KH,10,1,0.0D0,0))THEN; WRITE(*,'(/A/)') 'ERROR READING '//TRIM(FN); STOP; ENDIF 
  ELSE
   IF(.NOT.IDFREAD(KH,FN,1))THEN; WRITE(*,'(/A/)') 'ERROR READING '//TRIM(FN); STOP; ENDIF  
  ENDIF
 ELSE
  CALL IDFCOPY(IDF,KH); IF(.NOT.IDFALLOCATEX(KH))THEN
   CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Cannot ALLOCATE memory for a constant value KH.','Error'); RETURN
  ENDIF; LEX=.TRUE.
 ENDIF
 IF(LEX)THEN
  J= INDEX(LIST(1),'_',.TRUE.); JJ=INDEX(LIST(1)(J+1:),'-'); JJ=JJ+J
  FTXT=LIST(1)(:JJ-1); LIST(3)=TRIM(FTXT)//'-KH-S.IDF' 
 ENDIF
 
 !## make sure with constant values not to add dir
 LEX=.FALSE.; IF(TRIM(LIST(4)).NE.'')THEN
  READ(LIST(4),*,IOSTAT=IOS) X; IF(IOS.NE.0)THEN; FN=TRIM(DIR)//'\'//TRIM(LIST(4)); ELSE; FN=TRIM(LIST(4)); LEX=.TRUE.; ENDIF
  IF(IWINDOW.EQ.1)THEN
   CALL IDFCOPY(IDF,KV); IF(.NOT.IDFREADSCALE(FN,KV,10,1,0.0D0,0))THEN; WRITE(*,'(/A/)') 'ERROR READING '//TRIM(FN); STOP; ENDIF 
  ELSE
   IF(.NOT.IDFREAD(KV,FN,1))THEN; WRITE(*,'(/A/)') 'ERROR READING '//TRIM(FN); STOP; ENDIF
  ENDIF
 ELSE
  CALL IDFCOPY(IDF,KV); IF(.NOT.IDFALLOCATEX(KV))THEN
   CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Cannot ALLOCATE memory for a constant value KV.','Error'); RETURN
  ENDIF; LEX=.TRUE.
 ENDIF
 IF(LEX)THEN
  J= INDEX(LIST(1),'_',.TRUE.); JJ=INDEX(LIST(1)(J+1:),'-'); JJ=JJ+J
  FTXT=LIST(1)(:JJ-1); LIST(4)=TRIM(FTXT)//'-KV-S.IDF' 
 ENDIF

 !## if kh and kv are not both read, use va
 LEX=.TRUE.; IF(TRIM(LIST(3)).EQ.''.OR.TRIM(LIST(4)).EQ.'')THEN
  IF(TRIM(LIST(5)).EQ.'')THEN
   WRITE(*,'(/A/)') 'ERROR entry for VA is empty'; STOP
  ENDIF
  READ(LIST(5),*,IOSTAT=IOS) X; IF(IOS.NE.0)THEN; FN=TRIM(DIR)//'\'//TRIM(LIST(5)); LEX=.FALSE.; ELSE; FN=TRIM(LIST(5)); ENDIF
  IF(IWINDOW.EQ.1)THEN
   CALL IDFCOPY(IDF,VA); IF(.NOT.IDFREADSCALE(FN,VA,10,1,0.0D0,0))THEN; WRITE(*,'(/A/)') 'ERROR READING '//TRIM(FN); STOP; ENDIF 
  ELSE
   IF(.NOT.IDFREAD(VA,FN,1))THEN; WRITE(*,'(/A/)') 'ERROR READING '//TRIM(FN); STOP; ENDIF
  ENDIF
  !## fill in values for kh or kv
  IF(TRIM(LIST(3)).EQ.'')THEN
   DO IROW=1,VA%NROW; DO ICOL=1,VA%NCOL
    IF(VA%X(ICOL,IROW).NE.VA%NODATA.AND.KH%X(ICOL,IROW).NE.KH%NODATA)THEN
     KH%X(ICOL,IROW)=KV%X(ICOL,IROW)/VA%X(ICOL,IROW)
    ENDIF
   ENDDO; ENDDO
  ELSE
   DO IROW=1,VA%NROW; DO ICOL=1,VA%NCOL
    IF(VA%X(ICOL,IROW).NE.VA%NODATA.AND.KV%X(ICOL,IROW).NE.KH%NODATA)THEN
     KV%X(ICOL,IROW)=KH%X(ICOL,IROW)*VA%X(ICOL,IROW)
    ENDIF
   ENDDO; ENDDO
  ENDIF
 ENDIF
 IF(LEX)THEN
  J= INDEX(LIST(1),'_',.TRUE.); JJ=INDEX(LIST(1)(J+1:),'-'); JJ=JJ+J
  FTXT=LIST(1)(:JJ-1); LIST(5)=TRIM(FTXT)//'-VA-S.IDF' 
 ENDIF
 
 LHM_ADDIWHB_READFLIST=.TRUE.
 
 END FUNCTION LHM_ADDIWHB_READFLIST 

 !###===========================
 SUBROUTINE LHM_CONVERTREGIS()
 !###===========================
 IMPLICIT NONE
 INTEGER :: I,J,II,N,ICOL,IROW,IU
 REAL(KIND=DP_KIND) :: T,B,K1,K2,X,Y
 TYPE(IDFOBJ),DIMENSION(:,:),ALLOCATABLE :: TPK
 TYPE(IDFOBJ) :: TPIDF,BTIDF,KHIDF,KVIDF,VAIDF,IBIDF
  
 CALL UTL_CREATEDIR(OUTDIR)
 
 N=SIZE(FLIST); ALLOCATE(TPK(N,5)) 
 DO I=1,N; DO J=1,5; CALL IDFNULLIFY(TPK(I,J)); ENDDO; ENDDO
 CALL IDFNULLIFY(TPIDF); CALL IDFNULLIFY(BTIDF); CALL IDFNULLIFY(KHIDF)
 CALL IDFNULLIFY(KVIDF); CALL IDFNULLIFY(VAIDF); CALL IDFNULLIFY(IBIDF)
 
 DO I=1,N
  DO J=1,SIZE(FLIST(I)%FILE)
   WRITE(6,*) 'Reading '//TRIM(FLIST(I)%FILE(J))//' ...'
   IF(FLIST(I)%ITYPE(J).EQ.0)THEN
    TPK(I,J)%FNAME=TRIM(INDIR)//'\'//TRIM(FLIST(I)%FILE(J))
    IF(.NOT.IDFREAD(TPK(I,J),TPK(I,J)%FNAME,0))THEN; WRITE(6,'(/A/)') 'ERROR READING '//TRIM(TPK(I,J)%FNAME); STOP; ENDIF
   ENDIF
  ENDDO
 ENDDO

 IF(IWINDOW.EQ.1)THEN
  TPIDF%XMIN=XMIN; TPIDF%XMAX=XMAX; TPIDF%YMIN=YMIN; TPIDF%YMAX=YMAX; TPIDF%DX=CELLSIZE; TPIDF%DY=TPIDF%DX
  CALL UTL_IDFSNAPTOGRID_LLC(TPIDF%XMIN,TPIDF%XMAX,TPIDF%YMIN,TPIDF%YMAX,TPIDF%DX,TPIDF%DY,TPIDF%NCOL,TPIDF%NROW,.TRUE.)
  TPIDF%NODATA=TPK(1,1)%NODATA
 ELSE
  CALL IDFCOPY(TPK(1,1),TPIDF)
 ENDIF

 CALL IDFCOPY(TPIDF,BTIDF); CALL IDFCOPY(TPIDF,KHIDF); CALL IDFCOPY(TPIDF,KVIDF); CALL IDFCOPY(TPIDF,IBIDF); CALL IDFCOPY(TPIDF,VAIDF)
 IF(.NOT.IDFALLOCATEX(TPIDF))STOP; IF(.NOT.IDFALLOCATEX(BTIDF))STOP; IF(.NOT.IDFALLOCATEX(KHIDF))STOP
 IF(.NOT.IDFALLOCATEX(KVIDF))STOP; IF(.NOT.IDFALLOCATEX(IBIDF))STOP; IF(.NOT.IDFALLOCATEX(VAIDF))STOP

 IU=UTL_GETUNIT(); OPEN(IU,FILE=TRIM(OUTDIR)//'\CONSISTENT_SORTFILE.TXT',STATUS='UNKNOWN',ACTION='WRITE')
 WRITE(IU,'(5A32)') 'TOP','BOT','KH','KV','VA'
 
 !## fill in values
 TPIDF%X=TPIDF%NODATA; BTIDF%X=BTIDF%NODATA; KHIDF%X=KHIDF%NODATA; KVIDF%X=KVIDF%NODATA; IBIDF%X=IBIDF%NODATA; VAIDF%X=VAIDF%NODATA
 DO I=1,N

  DO IROW=1,TPIDF%NROW; DO ICOL=1,TPIDF%NCOL
   if(irow.eq.39.and.icol.eq.937)then
   write(*,*)
   endif
   CALL IDFGETLOC(TPIDF,IROW,ICOL,X,Y)

   !## nodata remains nodata 
   IF(I.GT.1.AND.TPIDF%X(ICOL,IROW).EQ.TPIDF%NODATA)CYCLE

   !## constant of variable value
   IF(FLIST(I)%ITYPE(1).EQ.1)THEN; T=FLIST(I)%XVAL(1); ELSE; T=IDFGETXYVAL(TPK(I,1),X,Y); ENDIF
   IF(FLIST(I)%ITYPE(2).EQ.1)THEN; B=FLIST(I)%XVAL(2); ELSE; B=IDFGETXYVAL(TPK(I,2),X,Y); ENDIF
   !## look for first no data
   IF(T.EQ.TPK(I,1)%NODATA)THEN
    IF(I.EQ.1)THEN
     !## check below
     DO J=I+1,N
      IF(FLIST(J)%ITYPE(1).EQ.1)THEN; T=FLIST(J)%XVAL(1); ELSE; T=IDFGETXYVAL(TPK(J,1),X,Y); ENDIF
      IF(T.NE.TPK(J,1)%NODATA)THEN
       B=T; EXIT
      ENDIF
     ENDDO
    ELSE
     T=BTIDF%X(ICOL,IROW); B=BTIDF%X(ICOL,IROW)
    ENDIF
    K1=TPK(I,3)%NODATA; K2=TPK(I,4)%NODATA
   ELSE
    IF(FLIST(I)%ITYPE(3).EQ.1)THEN; K1=FLIST(I)%XVAL(3); ELSE; K1=IDFGETXYVAL(TPK(I,3),X,Y); ENDIF
    IF(FLIST(I)%ITYPE(4).EQ.1)THEN; K2=FLIST(I)%XVAL(4); ELSE; K2=IDFGETXYVAL(TPK(I,4),X,Y); ENDIF
    IF(K1.EQ.TPK(I,3)%NODATA)K1=EPS; IF(K2.EQ.TPK(I,4)%NODATA)K2=EPS
    IF(K1.EQ.0.0D0)K1=K2; IF(K2.EQ.0.0D0)K2=K1
    IF(K1.EQ.0.0D0.AND.K2.EQ.0.0D0)THEN
     K1=TPK(I,3)%NODATA; K2=K1; T=BTIDF%X(ICOL,IROW); B=BTIDF%X(ICOL,IROW)
    ELSE
     !## make sure it connects
     IF(I.GT.1)T=BTIDF%X(ICOL,IROW)
    ENDIF
   ENDIF

   TPIDF%X(ICOL,IROW)=T; BTIDF%X(ICOL,IROW)=B; IBIDF%X(ICOL,IROW)=1
   IF(K1.NE.TPK(I,3)%NODATA.AND.K2.NE.TPK(I,4)%NODATA)THEN
    KHIDF%X(ICOL,IROW)=K1; KVIDF%X(ICOL,IROW)=K2; VAIDF%X(ICOL,IROW)=K2/K1
   ELSE
    KHIDF%X(ICOL,IROW)=1.0D0; KVIDF%X(ICOL,IROW)=1.0D0; VAIDF%X(ICOL,IROW)=1.0D0
   ENDIF
   
  ENDDO; WRITE(6,'(A,F10.3,A)') '+Progress ',REAL(100*IROW)/REAL(TPIDF%NROW),'%         '; ENDDO

  !## save only active packages
  J=0
RLOOP: DO IROW=1,TPIDF%NROW; DO ICOL=1,TPIDF%NCOL
   T=TPIDF%X(ICOL,IROW); B=BTIDF%X(ICOL,IROW)
   IF(T-B.GT.0.0D0)THEN; J=1; EXIT RLOOP; ENDIF
  ENDDO; ENDDO RLOOP
  IF(J.EQ.1)THEN   
   DO J=1,5; FLIST(I)%FILE(J)=TRIM(ITOS(I))//'_'//FLIST(I)%FILE(J); ENDDO
   TPIDF%FNAME=TRIM(OUTDIR)//'\'//TRIM(FLIST(I)%FILE(1))
   BTIDF%FNAME=TRIM(OUTDIR)//'\'//TRIM(FLIST(I)%FILE(2))
   KHIDF%FNAME=TRIM(OUTDIR)//'\'//TRIM(FLIST(I)%FILE(3))
   KVIDF%FNAME=TRIM(OUTDIR)//'\'//TRIM(FLIST(I)%FILE(4))
   VAIDF%FNAME=TRIM(OUTDIR)//'\'//TRIM(FLIST(I)%FILE(5))
   CALL LHM_CONVERTREGIS_OUTPUT(TPIDF,BTIDF,KHIDF,KVIDF,VAIDF)
   FLIST(I)%FILE(1)=TPIDF%FNAME; FLIST(I)%FILE(2)=BTIDF%FNAME; FLIST(I)%FILE(3)=KHIDF%FNAME
   FLIST(I)%FILE(4)=KVIDF%FNAME; FLIST(I)%FILE(5)=VAIDF%FNAME
   DO J=1,5
    II=INDEX(FLIST(I)%FILE(J),'\',.TRUE.)
    IF(II.NE.0)THEN
     FLIST(I)%FILE(J)=FLIST(I)%FILE(J)(II+1:)
    ENDIF
   ENDDO
   WRITE(IU,'(5A32)') (TRIM(FLIST(I)%FILE(J)),J=1,5)
  ENDIF
 ENDDO
 CLOSE(IU)
 
 END SUBROUTINE LHM_CONVERTREGIS

 !###===========================
 SUBROUTINE LHM_CONVERTREGIS_OUTPUT(TPIDF,BTIDF,KHIDF,KVIDF,VAIDF) 
 !###===========================
 IMPLICIT NONE
 TYPE(IDFOBJ),INTENT(INOUT) :: TPIDF,BTIDF,KHIDF,KVIDF,VAIDF 
 INTEGER :: IROW,ICOL,J,JJ
 REAL(KIND=DP_KIND) :: K
 LOGICAL :: LEX
 CHARACTER(LEN=256) :: FTXT
 
 IF(.NOT.IDFWRITE(TPIDF,TPIDF%FNAME,1,1))THEN; WRITE(*,'(/A/)') 'ERROR WRITING '//TRIM(TPIDF%FNAME); STOP; ENDIF  
 IF(.NOT.IDFWRITE(BTIDF,BTIDF%FNAME,1,1))THEN; WRITE(*,'(/A/)') 'ERROR WRITING '//TRIM(BTIDF%FNAME); STOP; ENDIF  
 
 IF(.NOT.IDFWRITE(KHIDF,KHIDF%FNAME,1,1))THEN; WRITE(*,'(/A/)') 'ERROR WRITING '//TRIM(KHIDF%FNAME); STOP; ENDIF  
 
 IF(.NOT.IDFWRITE(KVIDF,KVIDF%FNAME,1,1))THEN; WRITE(*,'(/A/)') 'ERROR WRITING '//TRIM(KVIDF%FNAME); STOP; ENDIF  
 
 IF(ASSOCIATED(VAIDF%X))THEN
  !## check whether this is variable
  LEX=.TRUE.; K=VAIDF%NODATA; DO IROW=1,VAIDF%NROW; DO ICOL=1,VAIDF%NCOL
   IF(VAIDF%X(ICOL,IROW).NE.VAIDF%NODATA)THEN
    IF(K.EQ.VAIDF%NODATA)K=VAIDF%X(ICOL,IROW)
    IF(K.NE.VAIDF%X(ICOL,IROW))THEN; LEX=.FALSE.; EXIT; ENDIF
   ENDIF
  ENDDO; IF(.NOT.LEX)EXIT; ENDDO
 ELSE
  LEX=.TRUE.; K=1.0D0
 ENDIF
 IF(.NOT.LEX)THEN
  IF(INDEX(VAIDF%FNAME,'.IDF').LE.0)THEN
   J= INDEX(TPIDF%FNAME,'_',.TRUE.)
   JJ=INDEX(TPIDF%FNAME(J+1:),'-'); JJ=JJ+J
   FTXT=TPIDF%FNAME(:JJ-1); VAIDF%FNAME=TRIM(FTXT)//'-VA-C.IDF' 
  ENDIF
  IF(.NOT.IDFWRITE(VAIDF,VAIDF%FNAME,1,1))THEN; WRITE(*,'(/A/)') 'ERROR WRITING '//TRIM(VAIDF%FNAME); STOP; ENDIF  
 ELSE
  WRITE(VAIDF%FNAME,*) '  ',K
 ENDIF
 
 END SUBROUTINE LHM_CONVERTREGIS_OUTPUT
 
 !###===========================
 SUBROUTINE LHM_CONVERTREGIS_AGGREGATE()
 !###===========================
 IMPLICIT NONE
 INTEGER :: III,II,I,J,JJ,N,BSIZE,NODES,INODE
 REAL(KIND=DP_KIND) :: KE,CE
 REAL(KIND=DP_KIND),DIMENSION(2) :: TKDW,TVCW
 REAL(KIND=DP_KIND),DIMENSION(:,:),ALLOCATABLE :: TOP,KHV,KVV,KVA
 REAL(KIND=DP_KIND),DIMENSION(:),ALLOCATABLE :: VCV,KDW
 TYPE(IDFOBJ),DIMENSION(:,:),ALLOCATABLE :: TP,KH,KV
 REAL(KIND=SP_KIND),DIMENSION(:),ALLOCATABLE :: X
  
 WRITE(OUTPUTDIR,'(A,I5.5)') TRIM(OUTDIR)//'\CMIN_',INT(CMIN)
 CALL UTL_CREATEDIR(OUTPUTDIR)
 
 N=SIZE(FLIST); ALLOCATE(TP(N+1,2),KH(N,2),KV(N,2))
 DO I=1,N+1; DO J=1,2; CALL IDFNULLIFY(TP(I,J)); ENDDO; ENDDO
 DO I=1,N;   DO J=1,2; CALL IDFNULLIFY(KH(I,J)); CALL IDFNULLIFY(KV(I,J)); ENDDO; ENDDO

 DO I=1,N
  
!  FNAME=FLIST(I)(INDEX(FLIST(I),'\',.TRUE.)+1:); FNAME=TRIM(OUTDIR)//'\'//TRIM(FNAME)//'-T_L'//TRIM(ITOS(I))//'.IDF'
  IF(.NOT.IDFREAD(TP(I,1),FNAME,-1))THEN; WRITE(*,'(/A/)') 'ERROR READING '//TRIM(FNAME); STOP; ENDIF 
!  FNAME=FLIST(I)(INDEX(FLIST(I),'\',.TRUE.)+1:); FNAME=TRIM(OUTPUTDIR)//'\'//TRIM(FNAME)//'-T_L'//TRIM(ITOS(I))//'.IDF'
  CALL IDFCOPY(TP(I,1),TP(I,2))
  IF(.NOT.IDFWRITE(TP(I,2),FNAME,1,-1))THEN; WRITE(*,'(/A/)') 'ERROR READING '//TRIM(FNAME); STOP; ENDIF
  
!  FNAME=FLIST(I)(INDEX(FLIST(I),'\',.TRUE.)+1:); FNAME=TRIM(OUTDIR)//'\'//TRIM(FNAME)//'-KH_L'//TRIM(ITOS(I))//'.IDF'
  IF(.NOT.IDFREAD(KH(I,1),FNAME,-1))THEN; WRITE(*,'(/A/)') 'ERROR READING '//TRIM(FNAME); STOP; ENDIF  
!  FNAME=FLIST(I)(INDEX(FLIST(I),'\',.TRUE.)+1:); FNAME=TRIM(OUTPUTDIR)//'\'//TRIM(FNAME)//'-KH_L'//TRIM(ITOS(I))//'.IDF'
  CALL IDFCOPY(KH(I,1),KH(I,2))
  IF(.NOT.IDFWRITE(KH(I,2),FNAME,1,-1))THEN; WRITE(*,'(/A/)') 'ERROR READING '//TRIM(FNAME); STOP; ENDIF

!  FNAME=FLIST(I)(INDEX(FLIST(I),'\',.TRUE.)+1:); FNAME=TRIM(OUTDIR)//'\'//TRIM(FNAME)//'-KV_L'//TRIM(ITOS(I))//'.IDF'
  IF(.NOT.IDFREAD(KV(I,1),FNAME,-1))THEN; WRITE(*,'(/A/)') 'ERROR READING '//TRIM(FNAME); STOP; ENDIF
!  FNAME=FLIST(I)(INDEX(FLIST(I),'\',.TRUE.)+1:); FNAME=TRIM(OUTPUTDIR)//'\'//TRIM(FNAME)//'-VA_L'//TRIM(ITOS(I))//'.IDF'
  CALL IDFCOPY(KV(I,1),KV(I,2))
  IF(.NOT.IDFWRITE(KV(I,2),FNAME,1,-1))THEN; WRITE(*,'(/A/)') 'ERROR READING '//TRIM(FNAME); STOP; ENDIF
 
  IF(I.EQ.N)THEN
!   FNAME=FLIST(I)(INDEX(FLIST(I),'\',.TRUE.)+1:); FNAME=TRIM(OUTDIR)//'\'//TRIM(FNAME)//'-B_L'//TRIM(ITOS(I))//'.IDF'
   IF(.NOT.IDFREAD(TP(I+1,1),FNAME,-1))THEN; WRITE(*,'(/A/)') 'ERROR READING '//TRIM(FNAME); STOP; ENDIF
!   FNAME=FLIST(I)(INDEX(FLIST(I),'\',.TRUE.)+1:); FNAME=TRIM(OUTPUTDIR)//'\'//TRIM(FNAME)//'-B_L'//TRIM(ITOS(I))//'.IDF'
   CALL IDFCOPY(TP(I+1,1),TP(I+1,2))
   IF(.NOT.IDFWRITE(TP(I+1,2),FNAME,1,-1))THEN; WRITE(*,'(/A/)') 'ERROR READING '//TRIM(FNAME); STOP; ENDIF
  ENDIF
 
 ENDDO
 
 ALLOCATE(TOP(N+1,BLOCKSIZE),KHV(N,BLOCKSIZE),KVV(N,BLOCKSIZE),KVA(N,BLOCKSIZE),VCV(N),KDW(N),X(BLOCKSIZE))
 
 NODES=TP(1,1)%NROW*TP(1,1)%NCOL
 INODE=0
 DO 
  
  BSIZE=MIN(BLOCKSIZE,NODES-INODE)

  !## finished
  IF(BSIZE.LE.0)EXIT
  
  !## read variables at currrent location
  DO I=1,N
   IF(TP(I,1)%ITYPE.EQ.8)THEN
    READ(TP(I,1)%IU) (TOP(I,J),J=1,BSIZE)
   ELSE
    READ(TP(I,1)%IU) (X(J),J=1,BSIZE)
    DO J=1,BSIZE; TOP(I,J)=X(J); ENDDO
   ENDIF
   IF(KH(I,1)%IU.GT.0)THEN
    IF(KH(I,1)%ITYPE.EQ.8)THEN
     READ(KH(I,1)%IU) (KHV(I,J),J=1,BSIZE)
    ELSE
     READ(KH(I,1)%IU) (X(J),J=1,BSIZE)
     DO J=1,BSIZE; KHV(I,J)=X(J); ENDDO
    ENDIF
   ENDIF
   IF(KV(I,1)%IU.GT.0)THEN
    IF(KV(I,1)%ITYPE.EQ.8)THEN
     READ(KV(I,1)%IU) (KVV(I,J),J=1,BSIZE)
    ELSE
     READ(KV(I,1)%IU) (X(J),J=1,BSIZE)
     DO J=1,BSIZE; KVV(I,J)=X(J); ENDDO
    ENDIF
   ENDIF
  ENDDO
  IF(TP(N+1,1)%ITYPE.EQ.8)THEN
   READ(TP(N+1,1)%IU) (TOP(N+1,J),J=1,BSIZE)
  ELSE
   READ(TP(N+1,1)%IU) (X(J),J=1,BSIZE)
   DO J=1,BSIZE; TOP(I,J)=X(J); ENDDO
  ENDIF

  DO J=1,BSIZE

   !## compute c- and t-values
   DO I=1,N
    VCV(I)=(TOP(I,J)-TOP(I+1,J))/KVV(I,J)
    KDW(I)=(TOP(I,J)-TOP(I+1,J))*KHV(I,J)
   ENDDO
   TKDW(1)=SUM(KDW); TVCW(1)=SUM(VCV)
  
   !## skip this as it is all nodata
   IF(TKDW(1).LE.0.0)CYCLE
  
   !## aggregate from layer 1 onwards
   I=0; DO
    I=I+1
    DO II=I+1,N
     IF(VCV(II).GT.CMIN.OR.II.EQ.N)THEN
      !## shift bottoms down
      JJ=1; IF(II.EQ.N)JJ=0
      DO III=I+1,II-JJ !1
       TOP(III,J)=TOP(II,J)
       VCV(I)    =VCV(I)+VCV(III); VCV(III)=0.0
       KDW(I)    =KDW(I)+KDW(III); KDW(III)=0.0
      ENDDO
      EXIT
     ENDIF
    ENDDO
    I=II
    IF(I.GE.N)EXIT
   ENDDO
   
   TKDW(2)=SUM(KDW); TVCW(2)=SUM(VCV)
  
   KE=100.0*(TKDW(1)-TKDW(2))/TKDW(1)
   CE=100.0*(TVCW(1)-TVCW(2))/TVCW(1)
   IF(KE.GT.KERROR.OR.CE.GT.CERROR)THEN
    WRITE(*,'(/A)') 'Something went wrong'
    WRITE(*,*) TKDW(1),TKDW(2),TKDW(1)-TKDW(2),KE
    WRITE(*,*) TVCW(1),TVCW(2),TVCW(1)-TVCW(2),CE
   ENDIF
  
   !## compute khv and kvv-values
   DO I=1,N
    IF((TOP(I,J)-TOP(I+1,J)).GT.0.0)THEN
     KHV(I,J)=KDW(I)/(TOP(I,J)-TOP(I+1,J))
     KVV(I,J)=(TOP(I,J)-TOP(I+1,J))*VCV(I)
    ELSE
     KHV(I,J)=EPS
     KVV(I,J)=EPS
    ENDIF
   ENDDO  
  ENDDO
  
  !## save variables at currrent location
  DO I=1,N
   IF(TP(I,1)%ITYPE.EQ.8)THEN
    WRITE(TP(I,1)%IU) (TOP(I,J),J=1,BSIZE)
   ELSE
    DO J=1,BSIZE; X(J)=TOP(I,J); ENDDO
    WRITE(TP(I,2)%IU) (X(J),J=1,BSIZE)
   ENDIF
   IF(KH(I,1)%ITYPE.EQ.8)THEN
    WRITE(KH(I,2)%IU) (KHV(I,J),J=1,BSIZE)
   ELSE
    DO J=1,BSIZE; X(J)=KHV(I,J); ENDDO
    WRITE(KH(I,2)%IU) (X(J),J=1,BSIZE)
   ENDIF
   DO J=1,BSIZE; KVA(I,J)=KVV(I,J)/KHV(I,J); ENDDO
   IF(KV(I,1)%ITYPE.EQ.8)THEN
    WRITE(KV(I,2)%IU) (KVA(I,J),J=1,BSIZE)
   ELSE
    DO J=1,BSIZE; X(J)=KVA(I,J); ENDDO
    WRITE(KV(I,2)%IU) (X(J),J=1,BSIZE)
   ENDIF
  ENDDO
  IF(TP(N+1,1)%ITYPE.EQ.8)THEN
   WRITE(TP(N+1,2)%IU) (TOP(I,J),J=1,BSIZE)
  ELSE
   DO J=1,BSIZE; X(J)=TOP(I,J); ENDDO
   WRITE(TP(N+1,2)%IU) (X(J),J=1,BSIZE)
  ENDIF
 
  INODE=INODE+BSIZE

  WRITE(6,'(A,F10.3,A)') '+Progress Aggregation ',REAL(100*INODE)/REAL(NODES),'%     '

 ENDDO
 
 DEALLOCATE(TOP,KHV,KVV,VCV,KDW,X)
 
 END SUBROUTINE LHM_CONVERTREGIS_AGGREGATE

 !###===========================
 SUBROUTINE LHM_CONVERTREGIS_WRITEPRJ()
 !###===========================
 IMPLICIT NONE
 INTEGER :: I,IU,N
 
 N=SIZE(FLIST)
 CALL UTL_CREATEDIR(OUTPUTDIR)
 IU=UTL_GETUNIT(); OPEN(IU,FILE=TRIM(OUTPUTDIR)//'\MODEL_v5.PRJ',STATUS='UNKNOWN',ACTION='WRITE')

 WRITE(IU,'(/A)') '0001,(BND),1, BOUNDARY CONDITION,[BND]'
 WRITE(IU,'(A,I10)') '001,',N
 DO I = 1,N
!  FNAME = FLIST(I)(INDEX(FLIST(I),'\',.TRUE.)+1:)
  FNAME = TRIM(OUTPUTDIR)//'\'//TRIM(FNAME)//'-IB_L'//TRIM(ITOS(I))//'.IDF'
  WRITE(IU,'(A,I3,A)') '1,2,',I,',1.0,0.0,-999.99,'//TRIM(FNAME)
 ENDDO
 
 WRITE(IU,'(/A)') '0001,(TOP),1, TOP ELEVATION,[TOP]'
 WRITE(IU,'(A,I10)') '001,',N
 DO I = 1,N
!  FNAME = FLIST(I)(INDEX(FLIST(I),'\',.TRUE.)+1:)
  FNAME = TRIM(OUTPUTDIR)//'\'//TRIM(FNAME)//'-T_L'//TRIM(ITOS(I))//'.IDF'
  WRITE(IU,'(A,I3,A)') '1,2,',I,',1.0,0.0,-999.99,'//TRIM(FNAME)
 ENDDO
 
 WRITE(IU,'(/A)') '0001,(BOT),1, BOTTOM ELEVATION,[BOT]'
 WRITE(IU,'(A,I10)') '001,',N
 DO I = 1,N
  IF(I.EQ.N)THEN
!   FNAME = FLIST(I)(INDEX(FLIST(I),'\',.TRUE.)+1:)
   FNAME = TRIM(OUTPUTDIR)//'\'//TRIM(FNAME)//'-B_L'//TRIM(ITOS(I))//'.IDF'
   WRITE(IU,'(A,I3,A)') '1,2,',I,',1.0,0.0,-999.99,'//TRIM(FNAME)
  ELSE
!   FNAME = FLIST(I+1)(INDEX(FLIST(I+1),'\',.TRUE.)+1:)
   FNAME = TRIM(OUTPUTDIR)//'\'//TRIM(FNAME)//'-T_L'//TRIM(ITOS(I+1))//'.IDF'
   WRITE(IU,'(A,I3,A)') '1,2,',I,',1.0,0.0,-999.99,'//TRIM(FNAME)
  ENDIF
 ENDDO

 WRITE(IU,'(/A)') '0001,(KHV),1, HORIZONTAL PERMEABILITY,[KHV]'
 WRITE(IU,'(A,I10)') '001,',N
 DO I = 1,N
!  FNAME = FLIST(I)(INDEX(FLIST(I),'\',.TRUE.)+1:)
  FNAME = TRIM(OUTPUTDIR)//'\'//TRIM(FNAME)//'-KH_L'//TRIM(ITOS(I))//'.IDF'
  WRITE(IU,'(A,I3,A)') '1,2,',I,',1.0,0.0,-999.99,'//TRIM(FNAME)
 ENDDO

 WRITE(IU,'(/A)') '0001,(KVA),1, VERTICAL ANISOTROPY,[KVA]'
 WRITE(IU,'(A,I10)') '001,',N
 
 DO I = 1,N
!  FNAME = FLIST(I)(INDEX(FLIST(I),'\',.TRUE.)+1:)
  FNAME = TRIM(OUTPUTDIR)//'\'//TRIM(FNAME)//'-VA_L'//TRIM(ITOS(I))//'.IDF'
  WRITE(IU,'(A,I3,A)') '1,2,',I,',1.0,0.0,-999.99,'//TRIM(FNAME)
 ENDDO
 
 WRITE(IU,'(/A)') '0001,(KVV),1, VERTICAL PERMEABILITY,[KVV]'
 WRITE(IU,'(A,I10)') '001,',N
 
 DO I = 1,N
  WRITE(IU,'(A,I3,A)') '1,1,',I,',1.0,0.0,1.0,""'
 ENDDO
 
 WRITE(IU,'(/A)') '0001 ,(SHD),1, STARTING HEADS,[SHD]'
 WRITE(IU,'(A,I10)') '001,',N
 
 DO I = 1,N
!  FNAME = FLIST(1)(INDEX(FLIST(1),'\',.TRUE.)+1:)
  FNAME = TRIM(OUTPUTDIR)//'\'//TRIM(FNAME)//'-T_L'//TRIM(ITOS(1))//'.IDF'
  WRITE(IU,'(A,I3,A)') '1,2,',I,',1.0,0.0,-999.99,'//TRIM(FNAME)
 ENDDO

!! WRITE(IU,'(/A)') '0001,(RIV),1, RIVER'
! WRITE(IU,'(A)') 'STEADY-STATE'
! WRITE(IU,'(A)') '004,005'
! WRITE(IU,'(A)') '1,2, -001,   1.000000    ,   0.000000    ,  -999.9900    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\COND_HL1_250.IDF'
! WRITE(IU,'(A)') '1,2, -001,   1.000000    ,   0.000000    ,  -999.9900    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\COND_HL2_250.IDF'
! WRITE(IU,'(A)') '1,2, -001,   1.000000    ,   0.000000    ,  -999.9900    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\COND_P_L0.IDF'
! WRITE(IU,'(A)') '1,2, -001,   1.000000    ,   0.000000    ,  -999.9900    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\COND_S_L0.IDF'
! WRITE(IU,'(A)') '1,2, -001,   1.000000    ,   0.000000    ,  -999.9900    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\COND_T_L0.IDF'
! WRITE(IU,'(A)') '1,2, -001,   1.000000    ,   0.000000    ,  -999.9900    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\PEIL_HW_250.IDF'
! WRITE(IU,'(A)') '1,2, -001,   1.000000    ,   0.000000    ,  -999.9900    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\PEIL_HW_250.IDF'
! WRITE(IU,'(A)') '1,2, -001,   1.000000    ,   0.000000    ,  -999.9900    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\PEIL_P1W_250.IDF'
! WRITE(IU,'(A)') '1,2, -001,   1.000000    ,   0.000000    ,  -999.9900    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\PEIL_S1W_250.IDF'
! WRITE(IU,'(A)') '1,2, -001,   1.000000    ,   0.000000    ,  -999.9900    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\PEIL_T1W_250.IDF'
! WRITE(IU,'(A)') '1,2, -001,   1.000000    ,   0.000000    ,  -999.9900    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\BOTH_W_L1.IDF'
! WRITE(IU,'(A)') '1,2, -001,   1.000000    ,   0.000000    ,  -999.9900    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\BOTH_W_L2.IDF'
! WRITE(IU,'(A)') '1,2, -001,   1.000000    ,   0.000000    ,  -999.9900    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\BODH_P1W_250.IDF'
! WRITE(IU,'(A)') '1,2, -001,   1.000000    ,   0.000000    ,  -999.9900    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\BODH_S1W_250.IDF' 
! WRITE(IU,'(A)') '1,2, -001,   1.000000    ,   0.000000    ,  -999.9900    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\PEIL_T1W_250.IDF'
! WRITE(IU,'(A)') '1,2, -001,   1.000000    ,   0.000000    ,  -999.9900    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\INFMZ_H_250_L1.IDF'
! WRITE(IU,'(A)') '1,2, -001,   1.000000    ,   0.000000    ,  -999.9900    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\INFMZ_H_250_L2.IDF'
! WRITE(IU,'(A)') '1,2, -001,   1.000000    ,   0.000000    ,  -999.9900    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\INFMZ_P1_250.IDF'
! WRITE(IU,'(A)') '1,2, -001,   1.000000    ,   0.000000    ,  -999.9900    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\INFMZ_S1_250.IDF'
! WRITE(IU,'(A)') '1,2, -001,   1.000000    ,   0.000000    ,  -999.9900    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\INFMZ_T1_250.IDF'
! 
! WRITE(IU,'(/A)') '0001,(DRN),1, DRAINAGE'
! WRITE(IU,'(A)') 'STEADY-STATE'
! WRITE(IU,'(A)') '002,001'
! WRITE(IU,'(A)') ' 1,2, -001,   1.000000    ,   0.000000    ,  -999.9900    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\COND_B_250.IDF'
! WRITE(IU,'(A)') ' 1,2, -001,   1.000000    ,   0.000000    ,   8.000000    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\BODH_B_250.IDF'
! 
! WRITE(IU,'(/A)') '0001,(GHB),1, GENERAL HEAD BOUNDARY,[CON,LVL]'
! WRITE(IU,'(A)') 'STEADY-STATE'
! WRITE(IU,'(A)') '002,001'
! WRITE(IU,'(A)') ' 1,2, -001,   1.000000    ,   0.000000    ,  -999.9900    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\GHB_COND_REGIS_L01.IDF'
! WRITE(IU,'(A)') ' 1,2, -001,   1.000000    ,   0.000000    ,   8.000000    ,'//TRIM(WORKDIR)//'\LHM\LHMV1\GHB_STAGE_REGIS_L01.IDF'
! 
! WRITE(IU,'(/A)') '0001,(RCH),1, RECHARGE,[RCH]'
! WRITE(IU,'(A)') 'STEADY-STATE'
! WRITE(IU,'(A)') '001,001'
! WRITE(IU,'(A)') ' 1,1, -001,   1.000000    ,   0.000000    ,   0.700000    ,""'
 
 WRITE(IU,'(/A)') ' 0001,(PCG),1, PRECONDITION CONJUGATE-GRADIENT []'
 WRITE(IU,'(A)')  '50,150,0.10000E-02,10.00000,0.98000,1,0,1,1.0000,1.0000,1,5.00000'
 
 WRITE(IU,'(/A)') 'PERIODS'
 CLOSE(IU)
 
 END SUBROUTINE LHM_CONVERTREGIS_WRITEPRJ
 
END MODULE MOD_AGGREGATE