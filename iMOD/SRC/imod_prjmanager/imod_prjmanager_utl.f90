!!  Copyright (C) Stichting Deltares, 2005-2018.
!!
!!  This file is part of iMOD.
!!
!!  This program is free software: you can redistribute it and/or modify
!!  it under the terms of the GNU General Public License as published by
!!  the Free Software Foundation, either version 3 of the License, or
!!  (at your option) any later version.
!!
!!  This program is distributed in the hope that it will be useful,
!!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!  GNU General Public License for more details.
!!
!!  You should have received a copy of the GNU General Public License
!!  along with this program.  If not, see <http://www.gnu.org/licenses/>.
!!
!!  Contact: imod.support@deltares.nl
!!  Stichting Deltares
!!  P.O. Box 177
!!  2600 MH Delft, The Netherlands.
!!
MODULE MOD_PMANAGER_UTL

USE WINTERACTER
USE RESOURCE
USE MOD_MODEL_PAR
USE MOD_PMANAGER_PAR
USE MOD_PMANAGER_TIME
USE IMODVAR
USE MOD_IDF
USE MOD_UTL
USE MOD_OSD
USE MOD_PREF_PAR
USE DATEVAR
USE MODPLOT
USE MOD_ABOUT

CONTAINS

 !###======================================================================
 SUBROUTINE PMANAGER_SORTTOPIC(ITOPIC,IPER)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: ITOPIC,IPER
 INTEGER :: I,J,II,K,N,M,JJ,IYR,IMH,IDY,IHR,IMT,ISC
 INTEGER,ALLOCATABLE,DIMENSION(:) :: ILAY,ISORT
 REAL(KIND=DP_KIND),ALLOCATABLE,DIMENSION(:) :: RTIME
  
 !## sort selected systems in layer
 N=SIZE(TOPICS(ITOPIC)%STRESS(IPER)%FILES,2)
 IF(N.GT.1)THEN
  ALLOCATE(ILAY(N),ISORT(N)); ILAY=0; ISORT=0
  DO I=1,N; ILAY(I)=TOPICS(ITOPIC)%STRESS(IPER)%FILES(1,I)%ILAY; ENDDO
  CALL WSORT(ILAY,1,N,IORDER=ISORT)

  J =SIZE(TOPICS(ITOPIC)%STRESS(IPER)%FILES,1)
  K =SIZE(TOPICS(ITOPIC)%STRESS(IPER)%FILES,2)
  NULLIFY(TOPICS(ITOPIC)%STRESS(IPER)%FILES_TMP)
  ALLOCATE(TOPICS(ITOPIC)%STRESS(IPER)%FILES_TMP(J,K))
  
  DO I=1,N
   J=ISORT(I)
   DO II=1,SIZE(TOPICS(ITOPIC)%STRESS(IPER)%FILES,1)
    TOPICS(ITOPIC)%STRESS(IPER)%FILES_TMP(II,I)=TOPICS(ITOPIC)%STRESS(IPER)%FILES(II,J)
   ENDDO
  ENDDO
  DEALLOCATE(TOPICS(ITOPIC)%STRESS(IPER)%FILES)
  TOPICS(ITOPIC)%STRESS(IPER)%FILES=>TOPICS(ITOPIC)%STRESS(IPER)%FILES_TMP
  DEALLOCATE(ILAY,ISORT)
 ENDIF
   
 !## sort selected systems in time
 IF(TOPICS(ITOPIC)%TIMDEP)THEN
  N=SIZE(TOPICS(ITOPIC)%STRESS)
  IF(N.GT.1)THEN
   ALLOCATE(RTIME(N),ISORT(N)); RTIME=0.0D0; ISORT=0
   DO I=1,N   
    IYR=TOPICS(ITOPIC)%STRESS(I)%IYR; IMH=TOPICS(ITOPIC)%STRESS(I)%IMH
    IDY=TOPICS(ITOPIC)%STRESS(I)%IDY; IHR=TOPICS(ITOPIC)%STRESS(I)%IHR
    IMT=TOPICS(ITOPIC)%STRESS(I)%IMT; ISC=TOPICS(ITOPIC)%STRESS(I)%ISC   
    RTIME(I)=IYR*10000000000+IMH*100000000+IDY*1000000+IHR*10000+IMT*100+ISC
   ENDDO
   CALL WSORT(RTIME,1,N,IORDER=ISORT)

   N=SIZE(TOPICS(ITOPIC)%STRESS); ALLOCATE(TOPICS(ITOPIC)%STRESS_TMP(N))
   
   DO I=1,N
    J=ISORT(I)

    !## create items for j
    N =SIZE(TOPICS(ITOPIC)%STRESS(J)%FILES,1)
    M =SIZE(TOPICS(ITOPIC)%STRESS(J)%FILES,2)
    NULLIFY(TOPICS(ITOPIC)%STRESS_TMP(I)%FILES); ALLOCATE(TOPICS(ITOPIC)%STRESS_TMP(I)%FILES(N,M))
    
    TOPICS(ITOPIC)%STRESS_TMP(I)%CDATE=TOPICS(ITOPIC)%STRESS(J)%CDATE
    TOPICS(ITOPIC)%STRESS_TMP(I)%IYR  =TOPICS(ITOPIC)%STRESS(J)%IYR
    TOPICS(ITOPIC)%STRESS_TMP(I)%IMH  =TOPICS(ITOPIC)%STRESS(J)%IMH
    TOPICS(ITOPIC)%STRESS_TMP(I)%IDY  =TOPICS(ITOPIC)%STRESS(J)%IDY
    TOPICS(ITOPIC)%STRESS_TMP(I)%IHR  =TOPICS(ITOPIC)%STRESS(J)%IHR
    TOPICS(ITOPIC)%STRESS_TMP(I)%IMT  =TOPICS(ITOPIC)%STRESS(J)%IMT
    TOPICS(ITOPIC)%STRESS_TMP(I)%ISC  =TOPICS(ITOPIC)%STRESS(J)%ISC
    
    DO II=1,SIZE(TOPICS(ITOPIC)%STRESS_TMP(I)%FILES,1)
     DO JJ=1,SIZE(TOPICS(ITOPIC)%STRESS_TMP(I)%FILES,2)
      TOPICS(ITOPIC)%STRESS_TMP(I)%FILES(II,JJ)=TOPICS(ITOPIC)%STRESS(J)%FILES(II,JJ)
     ENDDO
    ENDDO
   
    ENDDO

   DEALLOCATE(TOPICS(ITOPIC)%STRESS)
   TOPICS(ITOPIC)%STRESS=>TOPICS(ITOPIC)%STRESS_TMP

   DEALLOCATE(RTIME,ISORT)
  ENDIF
 ENDIF

 END SUBROUTINE PMANAGER_SORTTOPIC

 !###======================================================================
 INTEGER FUNCTION PMANAGER_GETFNAMES(IL1,IL2,JSYS,JSUB,JPER)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IL1,IL2,JSYS,JSUB,JPER
 INTEGER :: KK,I,J,JJ,ISYS,ISUB,IPER,IL
 LOGICAL :: LEX
 
 PMANAGER_GETFNAMES=0

 KK=0
 !## find fnames for model layers
 DO IL=IL1,IL2
 
  !## find topics
  DO J=1,SIZE(PRJILIST)

   JJ=PRJILIST(J)
   !## skip last - if that is vcw/kvv
   IF(IL1.NE.IL2.AND.IL.EQ.IL2)THEN
    IF(JJ.EQ.9.OR.JJ.EQ.10)CYCLE
   ENDIF

   IF(.NOT.ASSOCIATED(TOPICS(JJ)%STRESS))CYCLE
   
   DO IPER=1,SIZE(TOPICS(JJ)%STRESS)
   
    !## not appropriate system
    IF(IPER.NE.JPER.AND.JPER.NE.0)CYCLE

    IF(.NOT.ASSOCIATED(TOPICS(JJ)%STRESS(IPER)%FILES))CYCLE

    !## number of subtopics
    DO ISUB=1,SIZE(TOPICS(JJ)%STRESS(IPER)%FILES,1)

     !## not appropriate system
     IF(ISUB.NE.JSUB.AND.JSUB.NE.0)CYCLE

     !## number of systems
     DO ISYS=1,SIZE(TOPICS(JJ)%STRESS(IPER)%FILES,2)

      !## not appropriate system
      IF(ISYS.NE.JSYS.AND.JSYS.NE.0)CYCLE

      !## not appropriate layer
      IF(IL.NE.0)THEN
       IF(TOPICS(JJ)%STRESS(IPER)%FILES(ISUB,ISYS)%ILAY.NE.IL)CYCLE
      ENDIF
       
      KK=KK+1; CALL PMAMAGER_INCREASEFNAMES(KK)
      FNAMES(KK)%ILAY =TOPICS(JJ)%STRESS(IPER)%FILES(ISUB,ISYS)%ILAY
      FNAMES(KK)%ICNST=TOPICS(JJ)%STRESS(IPER)%FILES(ISUB,ISYS)%ICNST
      FNAMES(KK)%CNST =TOPICS(JJ)%STRESS(IPER)%FILES(ISUB,ISYS)%CNST
      FNAMES(KK)%FCT  =TOPICS(JJ)%STRESS(IPER)%FILES(ISUB,ISYS)%FCT
      FNAMES(KK)%IMP  =TOPICS(JJ)%STRESS(IPER)%FILES(ISUB,ISYS)%IMP
      FNAMES(KK)%FNAME=TOPICS(JJ)%STRESS(IPER)%FILES(ISUB,ISYS)%FNAME

      !## read only the first appropriate file
      EXIT 

     ENDDO
    ENDDO 
   ENDDO

  ENDDO
 ENDDO

 !## actual found files
 PMANAGER_GETFNAMES=KK

 LINE=TOPICS(PRJILIST(1))%TNAME(1:5)
 DO J=2,SIZE(PRJILIST); LINE=TRIM(LINE)//','//TOPICS(PRJILIST(J))%TNAME(1:5); ENDDO
 IF(PMANAGER_GETFNAMES.EQ.0)CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'No compulsory files found for package(s):'//CHAR(13)//TRIM(LINE),'Warning')

 !## check whether file(s) exist
 DO I=1,KK
  !## filename read
  IF(FNAMES(I)%ICNST.GT.1)THEN
   INQUIRE(FILE=FNAMES(I)%FNAME,EXIST=LEX)
   IF(.NOT.LEX)THEN
    CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'iMOD cannot find the following file:'//CHAR(13)// &
     TRIM(FNAMES(I)%FNAME),'Warning'); PMANAGER_GETFNAMES=0
   ENDIF
  ENDIF
 ENDDO

 END FUNCTION PMANAGER_GETFNAMES

 !###======================================================================
 SUBROUTINE PMAMAGER_INCREASEFNAMES(K)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: K
 INTEGER :: I,N
 
 IF(.NOT.ASSOCIATED(FNAMES))THEN; ALLOCATE(FNAMES(1)); RETURN; ENDIF
  
 N=SIZE(FNAMES); IF(K.LE.N)RETURN

 ALLOCATE(FNAMES_BU(N+10)); DO I=1,N; FNAMES_BU(I)=FNAMES(I); ENDDO
 DEALLOCATE(FNAMES); FNAMES=>FNAMES_BU
 
 END SUBROUTINE PMAMAGER_INCREASEFNAMES

 !###======================================================================
 LOGICAL FUNCTION PMANAGER_GETPACKAGES(IBATCH)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IBATCH
 INTEGER :: ITOPIC,I
 
 PMANAGER_GETPACKAGES=.FALSE.

! LPCGN=.FALSE.  !## option ?
 LPWT =.FALSE.
  
 !## cap
 LMSP=.FALSE.; ITOPIC=1; IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS))THEN
  IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS(1)%FILES))LMSP=.TRUE.; ENDIF 
 IF(TOPICS(ITOPIC)%IACT_MODEL.EQ.0)LMSP=.FALSE.
 !## turn off for steady-state simulations
 IF(ISS.EQ.0)LMSP=.FALSE.
 
 !## ani
 LANI=.FALSE.; ITOPIC=14; IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS))THEN
  IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS(1)%FILES))LANI=.TRUE.; ENDIF 
 IF(TOPICS(ITOPIC)%IACT_MODEL.EQ.0)LANI=.FALSE.

 !## hfb
 LHFB=.FALSE.; ITOPIC=15; IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS))THEN
  IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS(1)%FILES))LHFB=.TRUE.; ENDIF 
 IF(TOPICS(ITOPIC)%IACT_MODEL.EQ.0)LHFB=.FALSE.

 !## wel
 LWEL=.FALSE.; ITOPIC=21; IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS))THEN
  IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS(1)%FILES))LWEL=.TRUE.; ENDIF 
 IF(TOPICS(ITOPIC)%IACT_MODEL.EQ.0)LWEL=.FALSE.

 !## drn
 LDRN=.FALSE.; ITOPIC=22; IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS))THEN
  IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS(1)%FILES))LDRN=.TRUE.; ENDIF 
 IF(TOPICS(ITOPIC)%IACT_MODEL.EQ.0)LDRN=.FALSE.

 !## riv
 LRIV=.FALSE.; ITOPIC=23; IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS))THEN
  IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS(1)%FILES))LRIV=.TRUE.; ENDIF 
 IF(TOPICS(ITOPIC)%IACT_MODEL.EQ.0)LRIV=.FALSE.

 !## evt
 LEVT=.FALSE.; ITOPIC=24; IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS))THEN
  IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS(1)%FILES))LEVT=.TRUE.; ENDIF 
 IF(TOPICS(ITOPIC)%IACT_MODEL.EQ.0)LEVT=.FALSE.

 !## ghb
 LGHB=.FALSE.; ITOPIC=25; IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS))THEN
  IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS(1)%FILES))LGHB=.TRUE.; ENDIF 
 IF(TOPICS(ITOPIC)%IACT_MODEL.EQ.0)LGHB=.FALSE.

 !## rch
 LRCH=.FALSE.; ITOPIC=26; IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS))THEN
  IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS(1)%FILES))LRCH=.TRUE.; ENDIF 
 IF(TOPICS(ITOPIC)%IACT_MODEL.EQ.0)LRCH=.FALSE.

 !## sof
 LOLF=.FALSE.; ITOPIC=27; IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS))THEN
  IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS(1)%FILES))LOLF=.TRUE.; ENDIF 
 IF(TOPICS(ITOPIC)%IACT_MODEL.EQ.0)LOLF=.FALSE.

 !## chd
 LCHD=.FALSE.; ITOPIC=28; IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS))THEN
  IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS(1)%FILES))LCHD=.TRUE.; ENDIF 
 IF(TOPICS(ITOPIC)%IACT_MODEL.EQ.0)LCHD=.FALSE.

 !## isg
 LISG=.FALSE.; ITOPIC=29; IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS))THEN
  IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS(1)%FILES))LISG=.TRUE.; ENDIF 
 IF(TOPICS(ITOPIC)%IACT_MODEL.EQ.0)LISG=.FALSE.

 !## sfr
 LSFR=.FALSE.; ITOPIC=30; IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS))THEN
  IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS(1)%FILES))LSFR=.TRUE.; ENDIF 
 IF(TOPICS(ITOPIC)%IACT_MODEL.EQ.0)LSFR=.FALSE.

 !## fhb
 LFHB=.FALSE.; ITOPIC=31; IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS))THEN
  IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS(1)%FILES))LFHB=.TRUE.; ENDIF 
 IF(TOPICS(ITOPIC)%IACT_MODEL.EQ.0)LFHB=.FALSE.

 !## lak
 LLAK=.FALSE.; ITOPIC=32; IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS))THEN
  IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS(1)%FILES))LLAK=.TRUE.; ENDIF 
 IF(TOPICS(ITOPIC)%IACT_MODEL.EQ.0)LLAK=.FALSE.

 !## pcg
 LPCG=.FALSE.; ITOPIC=33; IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS))THEN
  IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS(1)%FILES))LPCG=.TRUE.; ENDIF 
 IF(TOPICS(ITOPIC)%IACT_MODEL.EQ.0)LPCG=.FALSE.

 IF(.NOT.LPCG)THEN
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'It is compulsory to add a solver, e.g. PCG','Error')
  RETURN
 ENDIF

 IF(LPCG.AND.PBMAN%IPKS.EQ.1)THEN
  LPCG=.FALSE.; LPKS=.TRUE.
 ENDIF
 
 !## uzf
 LUZF=.FALSE.; ITOPIC=18; IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS))THEN
  IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS(1)%FILES))LUZF=.TRUE.; ENDIF 
 IF(TOPICS(ITOPIC)%IACT_MODEL.EQ.0)LUZF=.FALSE.

 IF(LUZF)THEN
  IF(LAYCON(1).NE.2)THEN
   CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'It is compulsory to use an unconfined first model layer for the UZF package','Error')
   RETURN
  ENDIF
 ENDIF
 
 !## mnw
 LMNW=.FALSE.; ITOPIC=19; IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS))THEN
  IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS(1)%FILES))LMNW=.TRUE.; ENDIF 
 IF(TOPICS(ITOPIC)%IACT_MODEL.EQ.0)LMNW=.FALSE.

 !## sft
 LSFT=.FALSE.; ITOPIC=17; IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS))THEN
  IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS(1)%FILES))LSFT=.TRUE.; ENDIF 
 IF(TOPICS(ITOPIC)%IACT_MODEL.EQ.0)LSFT=.FALSE.

 !## pst
 LPST=.FALSE.; ITOPIC=20; IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS))THEN
  IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS(1)%FILES))LPST=.TRUE.; ENDIF 
 IF(TOPICS(ITOPIC)%IACT_MODEL.EQ.0)LPST=.FALSE.
 
 !## save settings for iMOD GUI
 IF(IBATCH.EQ.0)THEN
  !## use as unconfined
  ALLOCATE(PBMAN%UNCONFINED(1)); PBMAN%UNCONFINED(1)=0
  !## save all heads
  ALLOCATE(PBMAN%SAVESHD(1)); PBMAN%SAVESHD(1)=-1
  !## save all fluxes
  ALLOCATE(PBMAN%SAVEFLX(1)); PBMAN%SAVEFLX(1)=-1
  IF(LUZF)THEN
   ALLOCATE(PBMAN%SAVEUZF(1)); PBMAN%SAVEUZF(1)=1
  ENDIF
  IF(LSFR)THEN
   ALLOCATE(PBMAN%SAVESFR(1)); PBMAN%SAVESFR(1)=1
  ENDIF
  IF(LWEL)THEN
   ALLOCATE(PBMAN%SAVEWEL(1)); PBMAN%SAVEWEL(1)=-1
  ENDIF 
  IF(LDRN.OR.LOLF)THEN
   ALLOCATE(PBMAN%SAVEDRN(1)); PBMAN%SAVEDRN(1)=-1
  ENDIF 
  IF(LRIV.OR.LISG)THEN
   ALLOCATE(PBMAN%SAVERIV(1)); PBMAN%SAVERIV(1)=-1
  ENDIF 
  IF(LGHB)THEN
   ALLOCATE(PBMAN%SAVEGHB(1)); PBMAN%SAVEGHB(1)=-1
  ENDIF 
  IF(LRCH)THEN
   ALLOCATE(PBMAN%SAVERCH(1)); PBMAN%SAVERCH(1)=1
  ENDIF 
  IF(LEVT)THEN
   ALLOCATE(PBMAN%SAVEEVT(1)); PBMAN%SAVEEVT(1)=1
  ENDIF 
  IF(LMNW)THEN
   ALLOCATE(PBMAN%SAVEMNW(1)); PBMAN%SAVEMNW(1)=-1
  ENDIF
  IF(LLAK)THEN
   ALLOCATE(PBMAN%SAVELAK(1)); PBMAN%SAVELAK(1)=-1
  ENDIF
  IF(LFHB)THEN
   ALLOCATE(PBMAN%SAVEFHB(1)); PBMAN%SAVEFHB(1)=-1
  ENDIF
  PBMAN%MINKD=0.0D0
  PBMAN%MINC =0.0D0
  PBMAN%IFVDL=0
  PBMAN%IPKS=0
  PBMAN%ICONCHK=0
  PBMAN%ICHKCHD=0
  PBMAN%OUTPUT=''
  PBMAN%NSUBMODEL=1
  PBMAN%ISUBMODEL=1
  PBMAN%SSYSTEM=0
  PBMAN%DWEL=1
  PBMAN%DISG=1
  PBMAN%ISAVEENDDATE=0
  ENDIF

 IF(.NOT.ASSOCIATED(PBMAN%ILAY))THEN
  ALLOCATE(PBMAN%ILAY(PRJNLAY))
  DO I=1,SIZE(PBMAN%ILAY); PBMAN%ILAY(I)=1; ENDDO
 ENDIF

 PMANAGER_GETPACKAGES=.TRUE.

 END FUNCTION PMANAGER_GETPACKAGES

 !###======================================================================
 LOGICAL FUNCTION PMANAGER_INIT_SIMAREA(IDF,IBATCH)
 !###======================================================================
 IMPLICIT NONE
 TYPE(IDFOBJ),INTENT(INOUT) :: IDF
 INTEGER,INTENT(IN) :: IBATCH
 INTEGER :: I,J,K,II

 PMANAGER_INIT_SIMAREA=.FALSE.

 IF(PBMAN%IWINDOW.EQ.2)THEN
  IF(IDFREAD(IDF,PBMAN%BNDFILE,0))THEN
   PMANAGER_INIT_SIMAREA=.TRUE.; RETURN
  ENDIF
 ENDIF
  
!## get estimated of the current modeldomain
JLOOP: DO K=1,SIZE(TOPICS)
  !## skip wel,mnw,hfb,isg,sfr
  SELECT CASE (K)
   CASE (15,19:21,29,30,33); CYCLE
  END SELECT
  IF(.NOT.ASSOCIATED(TOPICS(K)%STRESS))CYCLE
  DO J=1,SIZE(TOPICS(K)%STRESS)
   IF(.NOT.ASSOCIATED(TOPICS(K)%STRESS(J)%FILES))CYCLE
   !## number of systems
   DO I=1,SIZE(TOPICS(K)%STRESS(J)%FILES,1)
    !## number of layers
    DO II=1,SIZE(TOPICS(K)%STRESS(J)%FILES,2)
     IF(TOPICS(K)%STRESS(J)%FILES(I,II)%ICNST.EQ.2)THEN
      IF(.NOT.IDFREAD(IDF,TOPICS(K)%STRESS(J)%FILES(I,II)%FNAME,0))THEN
       RETURN
      ENDIF
      EXIT JLOOP
     ENDIF
    ENDDO
   ENDDO
  ENDDO
 ENDDO JLOOP
 
 IF(K.GT.SIZE(TOPICS))THEN
  IF(IBATCH.EQ.0)THEN
   CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'iMOD cannot determine the size of the model.'//CHAR(13)// &
     'Please specify at least ONE IDF file in the PRJ file or'//CHAR(13)// &
     'specify a simulation window beforehand','Error')
  ELSE
   WRITE(*,'(/A/)') 'iMOD cannot determine the size of the model. Please specify at least ONE IDF file in the PRJ file or '// &
     'specify a simulation window beforehand'
  ENDIF
  RETURN
 ENDIF
 
 !## in case non-equi network is read, et rid of the ieq settings
 CALL IDFDEALLOCATESX(IDF); IDF%IEQ=0
 
 PMANAGER_INIT_SIMAREA=.TRUE.

 END FUNCTION PMANAGER_INIT_SIMAREA
 
 !###======================================================================
 LOGICAL FUNCTION PMANAGER_INITSIM(FNAME,IBATCH,IRUN)
 !###======================================================================
 IMPLICIT NONE
 CHARACTER(LEN=*),INTENT(OUT) :: FNAME
 INTEGER,INTENT(OUT) :: IRUN
 INTEGER,INTENT(IN) :: IBATCH
 INTEGER :: ITYPE
 TYPE(WIN_MESSAGE) :: MESSAGE
 INTEGER :: IDY,IYR,IMH,ITOPIC,IPER,I,J,K,MINJD,MAXJD,IDATE,IHR,IMT,ISC,IHMS,MINHMS,MAXHMS,ISTEADY,ISTEP,ITRANSIENT
 TYPE(IDFOBJ),ALLOCATABLE,DIMENSION(:) :: IDF
 LOGICAL :: LEX,LBAS
 
 PMANAGER_INITSIM=.FALSE.; IRUN=0
 
 !## put maximum number of layer in dialog
 CALL WDIALOGLOAD(ID_DPMANAGER_SIM,ID_DPMANAGER_SIM)
 CALL WDIALOGLOAD(ID_DPMANAGERLAYERTYPES,ID_DPMANAGERLAYERTYPES)
 CALL PMANAGER_GETNFILES((/2,3,4,5,6,7,8,9,10,11,12/),PRJMXNLAY)

 IF(PRJMXNLAY.LE.0)THEN
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'No layers found for the current configuration','Error')
  RETURN
 ENDIF

 !## number of active layers equal to maximum allowable layers
 CALL WDIALOGRANGEINTEGER(IDF_INTEGER1,1,PRJMXNLAY)
 CALL WDIALOGPUTINTEGER(IDF_INTEGER1,PRJMXNLAY); PRJNLAY=PRJMXNLAY
 IF(PRJMXNLAY.GT.WINFOGRID(IDF_GRID1,GRIDROWSMAX))THEN
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'For this iMOD version, there is a maximum number of layers is '// &
     TRIM(ITOS(WINFOGRID(IDF_GRID1,GRIDROWSMAX))),'Error')
  RETURN
 ENDIF
 CALL WGRIDROWS(IDF_GRID1,PRJMXNLAY)
 IF(ALLOCATED(LAYCON))THEN
  IF(SIZE(LAYCON).LT.PRJMXNLAY)DEALLOCATE(LAYCON)
 ENDIF
 IF(.NOT.ALLOCATED(LAYCON))THEN
  ALLOCATE(LAYCON(PRJMXNLAY))
  IF(IBATCH.EQ.0)THEN
   LAYCON=1
  ELSE
   J=0
   DO I=1,PRJMXNLAY
    IF(I.LE.SIZE(PBMAN%UNCONFINED))J=J+1
    LAYCON(I)=PBMAN%UNCONFINED(J)+1   !## 1/2 value for unconfinedness
   ENDDO
  ENDIF
 ENDIF

 !## laycon=1: 0
 !## laycon=2: 1
 !## laycon=3:-1
 !## laycon=4: constant head
  
 ISTEADY=0; ITRANSIENT=0; MINJD=10.0D07; MAXJD=-10.0D07; MINHMS=246060; MAXHMS=0.0D0
 DO ITOPIC=1,MAXTOPICS
  IF(.NOT.ASSOCIATED(TOPICS(ITOPIC)%STRESS))CYCLE
  IF(.NOT.TOPICS(ITOPIC)%TIMDEP)CYCLE
  DO IPER=1,SIZE(TOPICS(ITOPIC)%STRESS)

   IF(TRIM(UTL_CAP(TOPICS(ITOPIC)%STRESS(IPER)%CDATE,'U')).EQ.'STEADY-STATE')THEN
    ISTEADY=1
   ELSE
    IYR=TOPICS(ITOPIC)%STRESS(IPER)%IYR; IMH=TOPICS(ITOPIC)%STRESS(IPER)%IMH; IDY=TOPICS(ITOPIC)%STRESS(IPER)%IDY
    IHR=TOPICS(ITOPIC)%STRESS(IPER)%IHR; IMT=TOPICS(ITOPIC)%STRESS(IPER)%IMT; ISC=TOPICS(ITOPIC)%STRESS(IPER)%ISC
    !## date entered
    IF(IYR+IMH+IDY+IHR+IMT+ISC.GT.0)THEN
     ITRANSIENT=1
     IDATE=JD(IYR,IMH,IDY); IHMS=HMSTOITIME(IHR,IMT,ISC)
     IF(IDATE.LE.MINJD)THEN
      MINJD=MIN(MINJD,IDATE); IF(IHMS.LT.MINHMS)MINHMS=IHMS
     ENDIF
     IF(IDATE.GE.MAXJD)THEN
      MAXJD=MAX(MAXJD,IDATE); IF(IHMS.GT.MAXHMS)MAXHMS=IHMS
     ENDIF
    ELSE
     !## probably period definition?
     DO J=1,NPERIOD
      IF(TRIM(UTL_CAP(TOPICS(ITOPIC)%STRESS(IPER)%CDATE,'U')).EQ.TRIM(UTL_CAP(PERIOD(J)%NAME,'U')))EXIT
     ENDDO
     !## see whether the current stress is within mentioned period
     IF(J.LE.NPERIOD)THEN
      ITRANSIENT=1
      DO K=1,2
       IYR=PERIOD(J)%IYR; IMH=PERIOD(J)%IMH; IDY=PERIOD(J)%IDY
       IHR=PERIOD(J)%IHR; IMT=PERIOD(J)%IMT; ISC=PERIOD(J)%ISC
       IDATE=JD(IYR,IMH,IDY); IHMS=HMSTOITIME(IHR,IMT,ISC)
       IF(IDATE.LE.MINJD)THEN
        MINJD=MIN(MINJD,IDATE); IF(IHMS.LT.MINHMS)MINHMS=IHMS
       ENDIF
       IF(IDATE.GE.MAXJD)THEN
        MAXJD=MAX(MAXJD,IDATE); IF(IHMS.GT.MAXHMS)MAXHMS=IHMS
       ENDIF
      ENDDO
     ELSE
      CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Cannot convert date ['//TRIM(TOPICS(ITOPIC)%STRESS(IPER)%CDATE)//'] for'//CHAR(13)// &
         'Topic '//TRIM(TOPICS(ITOPIC)%TNAME),'Warning')
      RETURN
     ENDIF
    ENDIF
   ENDIF

  ENDDO
 ENDDO

 !## transient data found - see whether storage has been defined
 IF(ITRANSIENT.EQ.1)THEN
  I=0
  IF(ASSOCIATED(TOPICS(11)%STRESS))THEN
   IF(ASSOCIATED(TOPICS(11)%STRESS(1)%FILES))I=1
  ENDIF
  IF(I.EQ.0)THEN
   IF(ISTEADY.EQ.0)THEN
    CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Missing data to convert to a transient model.'//CHAR(13)// &
    'You need to specify the package (STO).','Warning'); RETURN
   ELSE
    CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Missing data to convert to a transient model.'//CHAR(13)// &
    'You need to specify the package (STO).'//CHAR(13)//'You can only select the STEADY-STATE model.','Warning'); ITRANSIENT=0
   ENDIF
  ENDIF    
 ENDIF
 
 !## default packages
 CALL WDIALOGSELECT(ID_DPMANAGER_SIM)
 CALL WDIALOGPUTMENU(IDF_MENU4,TMENU1,SIZE(TMENU1),8)
 CALL WDIALOGPUTIMAGE(ID_DRAW,ID_ICONDRAW,1)
 CALL WDIALOGPUTIMAGE(ID_OPEN,ID_ICONOPENIDF,1)
 CALL WDIALOGPUTSTRING(ID_LAYERTYPES,'Define '//TRIM(ITOS(PRJNLAY))//' Layer Types ...')

 !## no transient data found
 IF(ITRANSIENT.EQ.0)THEN 

  IMH=3; IYR=1970; IDY=8; IHR=0; IMT=0; ISC=0
  CALL WDIALOGPUTRADIOBUTTON(IDF_RADIO1)
  CALL WDIALOGFIELDSTATE(IDF_RADIO2,0)
  CALL WDIALOGPUTMENU(IDF_MENU2,CDATE,12,IMH)
  CALL WDIALOGPUTINTEGER(IDF_INTEGER2,IDY)
  CALL WDIALOGPUTINTEGER(IDF_INTEGER3,IYR)
  CALL WDIALOGPUTINTEGER(IDF_INTEGER6,IHR)
  CALL WDIALOGPUTINTEGER(IDF_INTEGER7,IMT)
  CALL WDIALOGPUTINTEGER(IDF_INTEGER8,ISC)
  CALL WDIALOGPUTMENU(IDF_MENU3,CDATE,12,IMH)
  CALL WDIALOGPUTINTEGER(IDF_INTEGER4,IDY)
  CALL WDIALOGPUTINTEGER(IDF_INTEGER5,IYR)
  CALL WDIALOGPUTINTEGER(IDF_INTEGER9,IHR)
  CALL WDIALOGPUTINTEGER(IDF_INTEGER10,IMT)
  CALL WDIALOGPUTINTEGER(IDF_INTEGER11,ISC)
 
 !## transient data found
 ELSE

  CALL WDIALOGPUTRADIOBUTTON(IDF_RADIO2)
  IF(ISTEADY.EQ.0)THEN
   CALL WDIALOGFIELDSTATE(IDF_RADIO1,0)
   CALL WDIALOGFIELDSTATE(IDF_CHECK2,0)
  ELSE
   CALL WDIALOGPUTCHECKBOX(IDF_CHECK2,1)
  ENDIF
  CALL UTL_GDATE(MINJD,IYR,IMH,IDY)
  CALL WDIALOGPUTMENU(IDF_MENU2,CDATE,12,IMH)
  CALL WDIALOGPUTINTEGER(IDF_INTEGER2,IDY)
  CALL WDIALOGPUTINTEGER(IDF_INTEGER3,IYR)
  CALL ITIMETOHMS(MINHMS,IHR,IMT,ISC)
  CALL WDIALOGPUTINTEGER(IDF_INTEGER6,IHR)
  CALL WDIALOGPUTINTEGER(IDF_INTEGER7,IMT)
  CALL WDIALOGPUTINTEGER(IDF_INTEGER8,ISC)

  CALL UTL_GDATE(MAXJD,IYR,IMH,IDY)
  CALL WDIALOGPUTMENU(IDF_MENU3,CDATE,12,IMH)
  CALL WDIALOGPUTINTEGER(IDF_INTEGER4,IDY)
  CALL WDIALOGPUTINTEGER(IDF_INTEGER5,IYR)
  CALL ITIMETOHMS(MAXHMS,IHR,IMT,ISC)
  CALL WDIALOGPUTINTEGER(IDF_INTEGER9,IHR)
  CALL WDIALOGPUTINTEGER(IDF_INTEGER10,IMT)
  CALL WDIALOGPUTINTEGER(IDF_INTEGER11,ISC)
 ENDIF

 LBAS=.FALSE.
 IF(ASSOCIATED(TOPICS(4)%STRESS).AND. &  !## bas
    ASSOCIATED(TOPICS(5)%STRESS))THEN    !## shd
  IF(ASSOCIATED(TOPICS(4)%STRESS(1)%FILES).AND. & !## bas
     ASSOCIATED(TOPICS(5)%STRESS(1)%FILES))THEN   !## shd
   LBAS=.TRUE.
  ENDIF
 ENDIF
 IF(.NOT.LBAS)THEN
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Missing data to convert to BAS package'//CHAR(13)// &
    'You need at least BND and SHD parameters','Warning')
  RETURN
 ENDIF

 LBCF=.FALSE.
 IF(ASSOCIATED(TOPICS(6)%STRESS))THEN
  IF(ASSOCIATED(TOPICS(6)%STRESS(1)%FILES))THEN   !## kdw
   LBCF=.TRUE.
   IF(PRJNLAY.GT.1)THEN
    IF(ASSOCIATED(TOPICS(9)%STRESS))THEN
     IF(.NOT.ASSOCIATED(TOPICS(9)%STRESS(1)%FILES))I=0    !## vcw
    ELSE
     LBCF=.FALSE.
    ENDIF
   ENDIF
  ENDIF
 ENDIF
 I=0; IF(LBCF)I=1; CALL WDIALOGFIELDSTATE(IDF_RADIO5,I)             !## bcf
 IF(LBCF)CALL WDIALOGPUTRADIOBUTTON(IDF_RADIO5)
 
 LLPF=.FALSE.; LNPF=.FALSE.
 IF(ASSOCIATED(TOPICS(2)%STRESS).AND. &
    ASSOCIATED(TOPICS(3)%STRESS).AND. &
    ASSOCIATED(TOPICS(7)%STRESS))THEN
  IF(ASSOCIATED(TOPICS(2)%STRESS(1)%FILES).AND. & !## top
     ASSOCIATED(TOPICS(3)%STRESS(1)%FILES).AND. & !## bot
     ASSOCIATED(TOPICS(7)%STRESS(1)%FILES))THEN   !## hkv
   LLPF=.TRUE.; LNPF=.TRUE.
!   IF(PRJNLAY.GT.1)THEN
   IF(ASSOCIATED(TOPICS(8)%STRESS))THEN
    IF(.NOT.ASSOCIATED(TOPICS(8)%STRESS(1)%FILES))I=0    !## kva
   ELSE
    LLPF=.FALSE.; LNPF=.FALSE.
   ENDIF
!   ENDIF
  ENDIF
 ENDIF
 
 J=0; IF(LLPF)J=1; CALL WDIALOGFIELDSTATE(IDF_RADIO6,J)              !## lpf
 IF(LLPF)CALL WDIALOGPUTRADIOBUTTON(IDF_RADIO6)
 IF(.NOT.LBCF.AND..NOT.LLPF.AND..NOT.LNPF)THEN
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Missing data to convert to BCF6, LPF or NPF package'//CHAR(13)// &
    'For BCF you need at least KDW and VCW parameters'//CHAR(13)// &
    'For LPF/NPF you need at least TOP, BOT, KHV and KVA parameters','Warning')
  RETURN
 ENDIF
 
 !## if lake or uzf package activated, make sure top/bot are active too 
 IF(ASSOCIATED(TOPICS(32)%STRESS).OR.ASSOCIATED(TOPICS(18)%STRESS))THEN
  J=0
  IF(ASSOCIATED(TOPICS(2)%STRESS).AND.ASSOCIATED(TOPICS(3)%STRESS))J=1
  IF(J.EQ.0)THEN
   CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'For usage of the LAK or UZF package you need to'//CHAR(13)// &
       'specify TOP and BOT packages as well','Warning'); RETURN
  ENDIF
 ENDIF

 !## look for any boundary file (first) not equal to constant values
 ALLOCATE(IDF(1)); CALL IDFNULLIFY(IDF(1))
 IF(.NOT.PMANAGER_INIT_SIMAREA(IDF(1),IBATCH))THEN
  CALL IDFDEALLOCATE(IDF,SIZE(IDF)); DEALLOCATE(IDF); RETURN
 ENDIF
 IF(IBATCH.EQ.0)PBMAN%BNDFILE=''
 IF(TRIM(PBMAN%BNDFILE).NE.'')THEN
  CALL WDIALOGPUTSTRING(IDF_STRING2,PBMAN%BNDFILE)
  CALL WDIALOGPUTRADIOBUTTON(IDF_RADIO16)
 ELSE
  CALL WDIALOGPUTRADIOBUTTON(IDF_RADIO17)
  CALL WDIALOGPUTSTRING(IDF_STRING2,'Enter NETWORKIDF')
 ENDIF
 !## found any of the given IDF-files that could serve as simulation window
 IF(IDF(1)%DX.GT.0.0D0)THEN
  CALL WDIALOGPUTDOUBLE(IDF_REAL5,IDF(1)%DX,'(G12.7)') 
 ELSE
  CALL WDIALOGPUTDOUBLE(IDF_REAL5,25.0D0,'(G12.7)') 
 ENDIF
 CALL IDFDEALLOCATE(IDF,SIZE(IDF)); DEALLOCATE(IDF)

 !## set output precision
 IF(PBMAN%IDOUBLE.EQ.0)CALL WDIALOGPUTRADIOBUTTON(IDF_RADIO18)
 IF(PBMAN%IDOUBLE.EQ.1)CALL WDIALOGPUTRADIOBUTTON(IDF_RADIO19)
 
 !## modflow2005 does not allow thickness of zero
 CALL WDIALOGPUTDOUBLE(IDF_REAL6,PBMAN%MINTHICKNESS,'(F15.3)') 
 
 CALL WDIALOGPUTDOUBLE(IDF_REAL1,MPW%XMIN,'(F15.3)') 
 CALL WDIALOGPUTDOUBLE(IDF_REAL2,MPW%YMIN,'(F15.3)') 
 CALL WDIALOGPUTDOUBLE(IDF_REAL3,MPW%XMAX,'(F15.3)') 
 CALL WDIALOGPUTDOUBLE(IDF_REAL4,MPW%YMAX,'(F15.3)') 

 CALL PMANAGER_INITSIM_FIELDS()
 
 CALL WDIALOGGETMENU(IDF_MENU4,I)
 CALL PMANAGER_TIMESTEPS_GETISTEP(I,J,ISTEP)    
 CALL WDIALOGPUTINTEGER(IDF_INTEGER12,ISTEP) 
 CALL WDIALOGFIELDSTATE(IDF_INTEGER12,J)

 !## blank out MF6 option ...
 CALL WDIALOGFIELDSTATE(IDF_RADIO20,3)

 !## start dialog
 IF(IBATCH.EQ.0)THEN
  CALL WDIALOGSHOW(-1,-1,0,3)

  DO
   CALL WMESSAGE(ITYPE,MESSAGE)
   SELECT CASE (ITYPE)
    CASE(FIELDCHANGED)
     SELECT CASE (MESSAGE%VALUE2)
      CASE (IDF_MENU4)
       CALL WDIALOGGETMENU(IDF_MENU4,I)
       CALL PMANAGER_TIMESTEPS_GETISTEP(I,J,ISTEP)    
       CALL WDIALOGPUTINTEGER(IDF_INTEGER12,ISTEP) 
       CALL WDIALOGFIELDSTATE(IDF_INTEGER12,J)
      CASE (IDF_RADIO1,IDF_RADIO2,IDF_RADIO3,IDF_RADIO4,IDF_RADIO20,IDF_INTEGER1,IDF_RADIO15,IDF_RADIO16,IDF_RADIO17) !IDF_CHECK1
       CALL PMANAGER_INITSIM_FIELDS()
       CASE (IDF_INTEGER2,IDF_INTEGER3,IDF_MENU2)
       CALL UTL_FILLDATES(IDF_INTEGER3,IDF_MENU2,IDF_INTEGER2)
      CASE (IDF_INTEGER4,IDF_INTEGER5,IDF_MENU3)
       CALL UTL_FILLDATES(IDF_INTEGER5,IDF_MENU3,IDF_INTEGER4)
     END SELECT
     SELECT CASE (MESSAGE%VALUE1)
     END SELECT
     
    CASE(PUSHBUTTON)
     SELECT CASE (MESSAGE%VALUE1)
      CASE (ID_OPEN)
       FNAME=TRIM(PREFVAL(1))//'*.idf'
       LEX=UTL_WSELECTFILE('Select (network) IDF File (*.idf)|*.idf|',  &
            LOADDIALOG+PROMPTON+DIRCHANGE+APPENDEXT,FNAME,'Select (network) IDF File')
       IF(LEX)CALL WDIALOGPUTSTRING(IDF_STRING2,FNAME)
       
      CASE (ID_LAYERTYPES)
       CALL PMANAGERLAYERTYPES()
       CALL PMANAGER_INITSIM_FIELDS()
      CASE (ID_SIMCUSTOMIZE)
       CALL PMANAGER_TIMESTEPS()
       CALL WDIALOGPUTOPTION(IDF_MENU4,9)
      CASE (ID_PACKAGE)
       CALL PMANAGER_INITSIM_PACKAGES()
       CALL PMANAGER_INITSIM_FIELDS()
      CASE (IDOK,IDSIMULATE1,IDSIMULATE2)
       !## fill timesteps - if not yet done
       LEX=.TRUE.; IF(.NOT.ASSOCIATED(SIM))LEX=PMANAGER_FILLTIMESTEPS()
       IF(LEX)THEN
        !## get file format
        CALL WDIALOGGETRADIOBUTTON(IDF_RADIO3,PBMAN%IFORMAT)
        CALL WDIALOGGETMENU(IDF_MENU5,I,MODELNAME)
        I=INDEX(MODELNAME,'.',.TRUE.); IF(I.GT.0)MODELNAME=MODELNAME(:I-1)
        IF(PBMAN%IFORMAT.EQ.1)THEN
         FNAME=TRIM(PREFVAL(1))//'\RUNFILES\'//TRIM(MODELNAME)//'.RUN'
        ELSEIF(PBMAN%IFORMAT.EQ.2.OR.PBMAN%IFORMAT.EQ.3)THEN
         CALL UTL_CREATEDIR(TRIM(PREFVAL(1))//'\MODELS') !\'//TRIM(MODELNAME))
         FNAME=TRIM(PREFVAL(1))//'\MODELS\'//TRIM(MODELNAME)//'\'//TRIM(MODELNAME)//'.NAM'
        ENDIF
        CALL WMESSAGEBOX(YESNO,COMMONNO,QUESTIONICON,'Are you sure to continue. iMOD will create:'//CHAR(13)// &
         TRIM(FNAME),'Question')
        IF(WINFODIALOG(4).EQ.1)EXIT
       ENDIF
      CASE (IDCANCEL)
       EXIT
     END SELECT
   END SELECT

  ENDDO
 
 ELSE
 
  !## take care of setting from imod-batch
  IF(PBMAN%ISS.EQ.0)THEN
   CALL WDIALOGPUTRADIOBUTTON(IDF_RADIO1) !## steady-state
  ELSE
   CALL WDIALOGPUTRADIOBUTTON(IDF_RADIO2) !## transient
   IF(LEN_TRIM(PBMAN%TIMFNAME).EQ.0)THEN
    !## start date
    CALL ITIMETOGDATE(PBMAN%SDATE,IYR,IMH,IDY,IHR,IMT,ISC)

    CALL WDIALOGPUTINTEGER(IDF_INTEGER2 ,IDY)
    CALL WDIALOGPUTOPTION(IDF_MENU2     ,IMH)
    CALL WDIALOGPUTINTEGER(IDF_INTEGER3 ,IYR)
    CALL WDIALOGPUTINTEGER(IDF_INTEGER6 ,IHR)
    CALL WDIALOGPUTINTEGER(IDF_INTEGER7 ,IMT)
    CALL WDIALOGPUTINTEGER(IDF_INTEGER8 ,ISC)
    !## end date
    CALL ITIMETOGDATE(PBMAN%EDATE,IYR,IMH,IDY,IHR,IMT,ISC)
    CALL WDIALOGPUTINTEGER(IDF_INTEGER4 ,IDY)
    CALL WDIALOGPUTOPTION(IDF_MENU3     ,IMH)
    CALL WDIALOGPUTINTEGER(IDF_INTEGER5 ,IYR)
    CALL WDIALOGPUTINTEGER(IDF_INTEGER9 ,IHR)
    CALL WDIALOGPUTINTEGER(IDF_INTEGER10,IMT)
    CALL WDIALOGPUTINTEGER(IDF_INTEGER11,ISC)

    CALL WDIALOGPUTINTEGER(IDF_INTEGER12,PBMAN%IDT)
    CALL WDIALOGPUTOPTION(IDF_MENU4     ,PBMAN%ITT)
   ENDIF
   
  ENDIF

  !## first idf
  IF(PBMAN%IWINDOW.EQ.0)CALL WDIALOGPUTRADIOBUTTON(IDF_RADIO17)
  !## window
  IF(PBMAN%IWINDOW.EQ.1)CALL WDIALOGPUTRADIOBUTTON(IDF_RADIO15)
  !## network idf
  IF(PBMAN%IWINDOW.EQ.2)CALL WDIALOGPUTRADIOBUTTON(IDF_RADIO16)

  CALL WDIALOGPUTDOUBLE(IDF_REAL1,PBMAN%XMIN)     !## xmin
  CALL WDIALOGPUTDOUBLE(IDF_REAL2,PBMAN%YMIN)     !## ymin
  CALL WDIALOGPUTDOUBLE(IDF_REAL3,PBMAN%XMAX)     !## xmax
  CALL WDIALOGPUTDOUBLE(IDF_REAL4,PBMAN%YMAX)     !## ymax
  CALL WDIALOGPUTDOUBLE(IDF_REAL5,PBMAN%CELLSIZE) !## cellsize
  CALL WDIALOGPUTDOUBLE(IDF_REAL7,PBMAN%BUFFER)   !## buffer
  IF(PBMAN%BUFFER.LE.0.0D0)PBMAN%BUFFERCS=0.0D0
  CALL WDIALOGPUTDOUBLE(IDF_REAL8,PBMAN%BUFFERCS) !## buffer-cellsize

  IF(PBMAN%IFORMAT.EQ.1)CALL WDIALOGPUTRADIOBUTTON(IDF_RADIO3)  !## runfile
  IF(PBMAN%IFORMAT.EQ.2)CALL WDIALOGPUTRADIOBUTTON(IDF_RADIO4)  !## modflow2005
  IF(PBMAN%IFORMAT.EQ.3)CALL WDIALOGPUTRADIOBUTTON(IDF_RADIO20) !## modflow6

  !## initial steady-state stress-period
  CALL WDIALOGPUTCHECKBOX(IDF_CHECK2,PBMAN%ISTEADY)

  IF(LEN_TRIM(PBMAN%TIMFNAME).NE.0)THEN
   CALL PMANAGER_SAVETIMESTEPS(ID_OPEN,1,PBMAN%TIMFNAME)     
  ELSE
   LEX=.TRUE.; IF(.NOT.ASSOCIATED(SIM))LEX=PMANAGER_FILLTIMESTEPS()
  ENDIF
  
  !## set modflow executable
  PREFVAL(8)=PBMAN%MODFLOW
  
  !## save only, or start model as well
  MESSAGE%VALUE1=IDOK; IF(PBMAN%ISOLVE.EQ.1)MESSAGE%VALUE1=IDSIMULATE1
 
 ENDIF

 IF(ASSOCIATED(SIM))SIM%ISUM=PBMAN%SSYSTEM !1
 
 !## get file format of export
 CALL WDIALOGGETRADIOBUTTON(IDF_RADIO3,PBMAN%IFORMAT)

 CALL WDIALOGGETRADIOBUTTON(IDF_RADIO17,I)
 PBMAN%IWINDOW=0
 IF(I.EQ.3)THEN
  CALL WDIALOGGETSTRING(IDF_STRING2,PBMAN%BNDFILE)
  ISUBMODEL=0; PBMAN%IWINDOW=2
 ELSE
  !## apply submodelling
  IF(I.EQ.2)THEN; ISUBMODEL=1; PBMAN%IWINDOW=1; ENDIF
  SUBMODEL=0.0D0; IF(ISUBMODEL.EQ.1)THEN
   CALL WDIALOGGETDOUBLE(IDF_REAL1,SUBMODEL(1)) !## xmin
   CALL WDIALOGGETDOUBLE(IDF_REAL2,SUBMODEL(2)) !## ymin
   CALL WDIALOGGETDOUBLE(IDF_REAL3,SUBMODEL(3)) !## xmax
   CALL WDIALOGGETDOUBLE(IDF_REAL4,SUBMODEL(4)) !## ymax
   CALL WDIALOGGETDOUBLE(IDF_REAL5,SUBMODEL(5)) !## cellsize
   CALL WDIALOGGETDOUBLE(IDF_REAL7,SUBMODEL(6)) !## buffer
   CALL WDIALOGGETDOUBLE(IDF_REAL8,SUBMODEL(7)) !## buffercs
  ENDIF

 ENDIF

 IF(IBATCH.EQ.0)THEN
  PBMAN%ICONSISTENCY=1
  IF(LLPF)PBMAN%ICONSISTENCY=2
 ENDIF
 
 CALL WDIALOGGETDOUBLE(IDF_REAL6,PBMAN%MINTHICKNESS)
 IF(PBMAN%IFORMAT.EQ.3)THEN
  LBCF=.FALSE.
  LLPF=.FALSE.
  LNPF=.TRUE.
  !## check for top/bot consistencies only
  PBMAN%ICONSISTENCY=1
 ELSE
  !## get subsoil format
  CALL WDIALOGGETRADIOBUTTON(IDF_RADIO5,I)
  LBCF=.FALSE.; IF(I.EQ.1)LBCF=.TRUE.   !## bcf
  LLPF=.FALSE.; IF(I.EQ.2)LLPF=.TRUE.   !## lpf
 ENDIF
 !## output precision
 CALL WDIALOGGETRADIOBUTTON(IDF_RADIO18,PBMAN%IDOUBLE)
 PBMAN%IDOUBLE=PBMAN%IDOUBLE-1

 !## output folder for a runfile
 CALL WDIALOGGETMENU(IDF_MENU5,I,MODELNAME)

 IF(MESSAGE%VALUE1.EQ.IDCANCEL)RETURN

 !## start the model as well
 IF(MESSAGE%VALUE1.EQ.IDSIMULATE1)IRUN=1
 IF(MESSAGE%VALUE1.EQ.IDSIMULATE2)IRUN=-1
 
 !## final check
 IF((ITRANSIENT.EQ.1.AND.ISTEADY.EQ.0).AND.SIZE(SIM).EQ.1)THEN
  IF(SIM(1)%DELT.EQ.0.0D0)THEN
   CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'iMOD cannot start this model as you have defined a timestep length'//CHAR(13)// &
     'of zero (steady-state), and all your packages are assigned'//CHAR(13)//'to a transient period.','Warning')
   RETURN
  ENDIF
 ENDIF
 
 PMANAGER_INITSIM=.TRUE.

 END FUNCTION PMANAGER_INITSIM

 !###======================================================================
 SUBROUTINE PMANAGER_GETNFILES(ITOPICS,MAXPRJNLAY)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,DIMENSION(:),INTENT(IN) :: ITOPICS
 INTEGER,INTENT(OUT) :: MAXPRJNLAY
 INTEGER :: II,I,J,IPER,ITOPIC,ILAY
 INTEGER,POINTER,DIMENSION(:) :: ALAY
 
 !## get maximal number of layers
 MAXPRJNLAY=999; ALLOCATE(ALAY(MAXPRJNLAY)); ALAY=0
 DO II=1,SIZE(ITOPICS) 
  ITOPIC=ITOPICS(II) 
  IF(.NOT.ASSOCIATED(TOPICS(ITOPIC)%STRESS))CYCLE
  IF(.NOT.ASSOCIATED(TOPICS(ITOPIC)%STRESS(1)%FILES))CYCLE
  DO IPER=1,SIZE(TOPICS(ITOPIC)%STRESS)
   DO I=1,SIZE(TOPICS(ITOPIC)%STRESS(IPER)%FILES,1)
    DO J=1,SIZE(TOPICS(ITOPIC)%STRESS(IPER)%FILES,2)
     ILAY=TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,J)%ILAY
     IF(ILAY.GT.0)ALAY(ILAY)=1
    ENDDO
   ENDDO   
  ENDDO
!  SELECT CASE (ITOPIC)
!   !## kvv or vcw
!   CASE (9,10)
!    PRJNLAY=PRJNLAY+1
!  END SELECT
!  PRJMXNLAY=MIN(PRJMXNLAY,PRJNLAY)
 ENDDO
 
 !## how many connected layers are defined
 MAXPRJNLAY=0; DO ILAY=1,SIZE(ALAY); IF(ALAY(ILAY).EQ.0)EXIT; MAXPRJNLAY=MAXPRJNLAY+1; ENDDO
 
 IF(ASSOCIATED(ALAY))DEALLOCATE(ALAY)
 
 END SUBROUTINE PMANAGER_GETNFILES
 
 !###======================================================================
 SUBROUTINE PMANAGER_INITSIM_PACKAGES()
 !###======================================================================
 IMPLICIT NONE
 INTEGER :: ITYPE
 TYPE(WIN_MESSAGE) :: MESSAGE
 INTEGER :: DID,I,N
 CHARACTER(LEN=MAXLENPRJ),ALLOCATABLE,DIMENSION(:) :: PLIST
 INTEGER,ALLOCATABLE,DIMENSION(:) :: IPLIST,JPLIST
 
 DID=WINFODIALOG(CURRENTDIALOG)

 CALL WDIALOGLOAD(ID_DPMANAGER_PACKAGES,ID_DPMANAGER_PACKAGES)

 ALLOCATE(PLIST(SIZE(TOPICS)),IPLIST(SIZE(TOPICS)),JPLIST(SIZE(TOPICS)))
 PLIST=''; IPLIST=0; JPLIST=0
 N=0; DO I=1,SIZE(TOPICS)
  IF(ASSOCIATED(TOPICS(I)%STRESS))THEN
   N=N+1; PLIST(N)=TOPICS(I)%TNAME; IPLIST(N)=TOPICS(I)%IACT_MODEL; JPLIST(N)=I
  ENDIF
 ENDDO

 CALL WDIALOGPUTMENU(IDF_MENU1,PLIST,N,IPLIST)
 CALL WDIALOGSHOW(-1,-1,0,3)

 DO
  CALL WMESSAGE(ITYPE,MESSAGE)
  SELECT CASE (ITYPE)
   CASE(FIELDCHANGED)
    !## previous field
    SELECT CASE (MESSAGE%VALUE1)
     CASE (IDF_MENU1)
    END SELECT
    !## next field
    SELECT CASE (MESSAGE%VALUE2)
     CASE (IDF_MENU1)
    END SELECT
    
   CASE(PUSHBUTTON)
    SELECT CASE (MESSAGE%VALUE1)
     CASE (IDOK)
      CALL WDIALOGGETMENU(IDF_MENU1,IPLIST)
      DO I=1,N; TOPICS(JPLIST(I))%IACT_MODEL=IPLIST(I); ENDDO
      EXIT
     CASE (IDHELP)

     CASE (IDCANCEL)
      EXIT
    END SELECT
  END SELECT

 ENDDO

 CALL WDIALOGUNLOAD(); CALL WDIALOGSELECT(DID)
 
 DEALLOCATE(PLIST,IPLIST,JPLIST)

 END SUBROUTINE PMANAGER_INITSIM_PACKAGES
 
 !###======================================================================
 SUBROUTINE PMANAGERLAYERTYPES()
 !###======================================================================
 IMPLICIT NONE
 INTEGER :: ITYPE
 TYPE(WIN_MESSAGE) :: MESSAGE
 INTEGER,ALLOCATABLE,DIMENSION(:) :: BLAYCON
 INTEGER :: BPRJNLAY
 
 CALL WDIALOGSELECT(ID_DPMANAGERLAYERTYPES)

 !## backup in case cancel is pressed
 CALL WDIALOGPUTINTEGER(IDF_INTEGER1,PRJNLAY)
 ALLOCATE(BLAYCON(PRJMXNLAY)); BLAYCON=LAYCON; BPRJNLAY=PRJNLAY

 CALL PMANAGERLAYERTYPES_PRJNLAY()
 
 CALL WDIALOGSHOW(-1,-1,0,3)
 
 DO
  CALL WMESSAGE(ITYPE,MESSAGE)
  SELECT CASE (ITYPE)
   CASE (FIELDCHANGED)
    SELECT CASE (MESSAGE%VALUE1)
    END SELECT
   CASE (PUSHBUTTON)
    SELECT CASE (MESSAGE%VALUE1)
     CASE (ID_APPLY)
      CALL PMANAGERLAYERTYPES_PRJNLAY()
     CASE (IDOK)
      CALL WGRIDGETMENU(IDF_GRID1,2,LAYCON,PRJNLAY)
      EXIT
     CASE (IDCANCEL)
      PRJNLAY=BPRJNLAY; LAYCON=BLAYCON
      EXIT
     CASE (IDHELP)
 !     CALL UTL_GETHELP('3.3.6','VMO.iMODProjMan')
    END SELECT
  END SELECT
 ENDDO
 
 DEALLOCATE(BLAYCON)
 CALL WDIALOGHIDE(); CALL WDIALOGSELECT(ID_DPMANAGER_SIM)
 CALL WDIALOGPUTSTRING(ID_LAYERTYPES,'Define '//TRIM(ITOS(PRJNLAY))//' Layer Types ...')
 
 END SUBROUTINE PMANAGERLAYERTYPES

 !###======================================================================
 SUBROUTINE PMANAGERLAYERTYPES_PRJNLAY()
 !###======================================================================
 IMPLICIT NONE
 INTEGER :: I
 
 CALL WDIALOGGETINTEGER(IDF_INTEGER1,PRJNLAY)
 CALL WGRIDROWS(IDF_GRID1,PRJNLAY)
 DO I=1,PRJNLAY; CALL WGRIDPUTCELLSTRING(IDF_GRID1,1,I,'Layer '//TRIM(ITOS(I))); ENDDO
 !## write boundary string lower layer
 CALL WGRIDPUTOPTION(IDF_GRID1,2,LAYCON,PRJNLAY)
 IF(PRJNLAY.LT.PRJMXNLAY)CALL WGRIDPUTCELLOPTION(IDF_GRID1,2,PRJNLAY,4)
 
 END SUBROUTINE PMANAGERLAYERTYPES_PRJNLAY
 
 !###======================================================================
 SUBROUTINE PMANAGER_INITSIM_FIELDS()
 !###======================================================================
 IMPLICIT NONE
 INTEGER :: I,J,K,N
 
 !## window or bndfile
 CALL WDIALOGGETRADIOBUTTON(IDF_RADIO17,K)
 IF(K.EQ.1)THEN
  I=0; J=0
 ELSEIF(K.EQ.2)THEN
  I=0; J=1
 ELSEIF(K.EQ.3)THEN
  I=1; J=0
 ENDIF

 CALL WDIALOGFIELDSTATE(IDF_STRING2,I)
 CALL WDIALOGFIELDSTATE(ID_OPEN,I)

 CALL WDIALOGFIELDSTATE(IDF_REAL1,J)
 CALL WDIALOGFIELDSTATE(IDF_REAL2,J)
 CALL WDIALOGFIELDSTATE(IDF_REAL3,J)
 CALL WDIALOGFIELDSTATE(IDF_REAL4,J)
 CALL WDIALOGFIELDSTATE(IDF_REAL5,J)
 CALL WDIALOGFIELDSTATE(IDF_REAL7,J)
 CALL WDIALOGFIELDSTATE(IDF_REAL8,J)
 CALL WDIALOGFIELDSTATE(IDF_LABEL9,J)
 CALL WDIALOGFIELDSTATE(IDF_LABEL10,J)
 CALL WDIALOGFIELDSTATE(IDF_LABEL11,J)
 CALL WDIALOGFIELDSTATE(IDF_LABEL12,J)
 CALL WDIALOGFIELDSTATE(IDF_LABEL19,J)
 CALL WDIALOGFIELDSTATE(ID_DRAW,J)

 CALL WDIALOGGETRADIOBUTTON(IDF_RADIO1,I)
 CALL WDIALOGFIELDSTATE(IDF_LABEL4,I-1)
 CALL WDIALOGFIELDSTATE(IDF_LABEL6,I-1)
 CALL WDIALOGFIELDSTATE(IDF_LABEL7,I-1)
 CALL WDIALOGFIELDSTATE(IDF_INTEGER2,I-1)
 CALL WDIALOGFIELDSTATE(IDF_INTEGER3,I-1)
 CALL WDIALOGFIELDSTATE(IDF_INTEGER4,I-1)
 CALL WDIALOGFIELDSTATE(IDF_INTEGER5,I-1)

 CALL WDIALOGFIELDSTATE(IDF_INTEGER6 ,I-1)
 CALL WDIALOGFIELDSTATE(IDF_INTEGER7 ,I-1)
 CALL WDIALOGFIELDSTATE(IDF_INTEGER8 ,I-1)
 CALL WDIALOGFIELDSTATE(IDF_INTEGER9 ,I-1)
 CALL WDIALOGFIELDSTATE(IDF_INTEGER10,I-1)
 CALL WDIALOGFIELDSTATE(IDF_INTEGER11,I-1)

 CALL WDIALOGFIELDSTATE(IDF_MENU2,I-1)
 CALL WDIALOGFIELDSTATE(IDF_MENU3,I-1)
 CALL WDIALOGFIELDSTATE(IDF_MENU4,I-1)
 CALL WDIALOGFIELDSTATE(IDF_CHECK2,I-1)
 CALL WDIALOGFIELDSTATE(ID_SIMCUSTOMIZE,I-1)

 CALL WDIALOGGETRADIOBUTTON(IDF_RADIO3,J)
 
 !## fill in dropdown menu
 IF(J.EQ.1)THEN
  CALL UTL_IMODFILLMENU(IDF_MENU5,TRIM(PREFVAL(1))//'\RUNFILES','*.RUN','F',N,0,0) 
  CALL WDIALOGPUTSTRING(IDF_LABEL25,'Output Name:')
 ELSE
  CALL UTL_IMODFILLMENU(IDF_MENU5,TRIM(PREFVAL(1))//'\MODELS','*','D',N,0,0) 
  CALL WDIALOGPUTSTRING(IDF_LABEL25,'Output Folder:')
 ENDIF
 CALL WDIALOGFIELDSTATE(IDF_MENU5,1)
 
 !## creating a runfile cannot start that one - will be start the modeltool instead
 I=0; IF(J.NE.1)I=1
 CALL WDIALOGFIELDSTATE(IDSIMULATE1,I)
 CALL WDIALOGFIELDSTATE(IDSIMULATE2,I)
 
 !## minimal thickness
 I=0; IF(J.EQ.2)I=1
 CALL WDIALOGFIELDSTATE(IDF_REAL6  ,I)
 CALL WDIALOGFIELDSTATE(IDF_LABEL14,I)

 !## initially always 3d
 LQBD=.FALSE.

 !## single layer model - usage of interbeds
 IF(PRJNLAY.GT.1)THEN

  !## if kvv specified use quasi-3d discretisation
  IF(PRJNLAY.GT.1)THEN
   IF(ASSOCIATED(TOPICS(9)%STRESS))THEN
    IF(ASSOCIATED(TOPICS(9)%STRESS(1)%FILES))LQBD=.TRUE.     !## vcw
   ENDIF
   IF(ASSOCIATED(TOPICS(10)%STRESS))THEN
    IF(ASSOCIATED(TOPICS(10)%STRESS(1)%FILES))LQBD=.TRUE.    !## kvv
   ENDIF
  ENDIF

 ENDIF

 !## subsoil package
 IF(J.EQ.2)THEN
  I=0; IF(LBCF)I=1; CALL WDIALOGFIELDSTATE(IDF_RADIO5,I)
  I=0; IF(LLPF)I=1; CALL WDIALOGFIELDSTATE(IDF_RADIO6,I)
 ELSE
  CALL WDIALOGFIELDSTATE(IDF_RADIO5,0)
  CALL WDIALOGFIELDSTATE(IDF_RADIO6,0)
 ENDIF

 END SUBROUTINE PMANAGER_INITSIM_FIELDS

 !###======================================================================
 INTEGER FUNCTION PMANAGER_GETCURRENTIPER(IPER,ITOPIC,ITIME,JTIME)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IPER,ITOPIC
 INTEGER(KIND=8),INTENT(OUT) :: ITIME,JTIME
 INTEGER(KIND=8) :: KTIME
 INTEGER :: KPER
 
 PMANAGER_GETCURRENTIPER=0

 KTIME=INT(0,8); JTIME=INT(0,8); ITIME=INT(0,8)
 
 !## get appropriate stress-period to store in runfile   
 IF(SIM(IPER)%DELT.GT.0.0D0)THEN !## transient
  !## previous timestep
  IF(IPER.GT.1)THEN
   IF(SIM(IPER-1)%DELT.GT.0.0D0)THEN
    KTIME=SIM(IPER-1)%IYR*10000000000+SIM(IPER-1)%IMH*100000000+SIM(IPER-1)%IDY*1000000+ &
          SIM(IPER-1)%IHR*10000      +SIM(IPER-1)%IMT*100      +SIM(IPER-1)%ISC
   ENDIF
  ENDIF
  !## current timestep
  ITIME=SIM(IPER  )%IYR*10000000000+SIM(IPER  )%IMH*100000000+SIM(IPER  )%IDY*1000000+ &
        SIM(IPER  )%IHR*10000      +SIM(IPER  )%IMT*100      +SIM(IPER  )%ISC
  !## next timestep
  JTIME=SIM(IPER+1)%IYR*10000000000+SIM(IPER+1)%IMH*100000000+SIM(IPER+1)%IDY*1000000+ &
        SIM(IPER+1)%IHR*10000      +SIM(IPER+1)%IMT*100      +SIM(IPER+1)%ISC
 ENDIF

 KPER=PMANAGER_GETIPER(IPER,KTIME,ITIME,JTIME,TOPICS(ITOPIC)%STRESS)   

 PMANAGER_GETCURRENTIPER=KPER

 END FUNCTION PMANAGER_GETCURRENTIPER

 !###======================================================================
 INTEGER FUNCTION PMANAGER_GETIPER(IPER,PTIME,STIME,ETIME,STRESS) 
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IPER
 INTEGER(KIND=8),INTENT(IN) :: STIME,ETIME,PTIME
 TYPE(STRESSOBJ),INTENT(IN),DIMENSION(:) :: STRESS
 INTEGER :: I,J,ID,IYR
 INTEGER(KIND=8) :: PCKTIME,MD
 
 !## initially nothing found
 PMANAGER_GETIPER=0

 !## look for steady-state
 IF(STIME.EQ.INT(0,8))THEN
  DO I=1,SIZE(STRESS)
   IF(TRIM(UTL_CAP(STRESS(I)%CDATE,'U')).EQ.'STEADY-STATE')THEN
    PMANAGER_GETIPER=I; RETURN
   ENDIF
  ENDDO
  ID=0 !## nothing found
 !## transient
 ELSE
  !## get time-interval window
  !## look for nearest package to current timestep
  MD=10D14; ID=0
  DO I=1,SIZE(STRESS)
   !## skip steady-state
   IF(TRIM(UTL_CAP(STRESS(I)%CDATE,'U')).EQ.'STEADY-STATE')CYCLE

   !## check whether a period is available
   DO J=1,NPERIOD
    IF(TRIM(UTL_CAP(STRESS(I)%CDATE,'U')).EQ.TRIM(UTL_CAP(PERIOD(J)%NAME,'U')))EXIT
   ENDDO
   !## see whether the current stress is within mentioned period
   IF(J.LE.NPERIOD)THEN

    !## check each subsequent period for years to be closed to current time step
    IYR=PERIOD(J)%IYR
    DO 

     !## package time
     PCKTIME=IYR*10000000000+    PERIOD(J)%IMH*100000000+PERIOD(J)%IDY*1000000+ &
             PERIOD(J)%IHR*10000+PERIOD(J)%IMT*100+      PERIOD(J)%ISC

     !## outside (appears to be later) current time-window
     IF(PCKTIME.GE.ETIME)EXIT 
     !## defined at the same period as the current timestep - better than this it will not become, stop search
     IF(STIME.EQ.PCKTIME)THEN; ID=I; EXIT; ENDIF
     !## get closest defined before current timestep
     IF(STIME.GT.PCKTIME)THEN
      !## closer than what we had already
      IF(STIME-PCKTIME.LE.MD)THEN; MD=STIME-PCKTIME; ID=-I; ENDIF
     ENDIF
     !## insert period next year
     IYR=IYR+1
     
    ENDDO

    !## defined at the same period as the current timestep - better than this it will not become, stop search
    IF(STIME.EQ.PCKTIME)EXIT

   ELSE
    !## package time
    PCKTIME=STRESS(I)%IYR*10000000000+STRESS(I)%IMH*100000000+STRESS(I)%IDY*1000000+ &
            STRESS(I)%IHR*10000      +STRESS(I)%IMT*100      +STRESS(I)%ISC

    !## outside (appears to be later) current time-window - try next
    IF(PCKTIME.GE.ETIME)CYCLE
    !## defined at the same period as the current timestep - better than this it will not become, stop search
    IF(STIME.EQ.PCKTIME)THEN; ID=I; EXIT; ENDIF
    !## get closest defined before current timestep
    IF(STIME.GT.PCKTIME)THEN
     !## closer than what we had already
     IF(STIME-PCKTIME.LE.MD)THEN; MD=STIME-PCKTIME; ID=-I; ENDIF
    ENDIF

   ENDIF

  ENDDO
 ENDIF
 
 !## nothing found
 IF(ID.EQ.0)THEN
  !## check steady-state period 
  DO I=1,SIZE(STRESS)
   !## skip steady-state
   IF(TRIM(UTL_CAP(STRESS(I)%CDATE,'U')).EQ.'STEADY-STATE')ID=I
  ENDDO
  !## apply minus 1
  IF(IPER.GT.1)ID=-1*ID
  PMANAGER_GETIPER=ID !0
 !## use previous input
 ELSEIF(ID.LT.0)THEN
  !## no matter what; cannot use -1 for first timestep
  IF(IPER.EQ.1)THEN
   PMANAGER_GETIPER=ABS(ID)
  ELSE
   !## no matter what; cannot use -1 for first timestep after steady-state
   IF(SIM(IPER-1)%DELT.EQ.0.0D0)THEN
    PMANAGER_GETIPER=ABS(ID)
   ELSE
    !## check whether date is after last time-step (ktime)
    IF(STIME-MD.GT.PTIME)THEN
     PMANAGER_GETIPER=ABS(ID)
    ELSE
     PMANAGER_GETIPER=ID
    ENDIF
   ENDIF
  ENDIF
 !## number of systems for current stress period
 ELSE
  PMANAGER_GETIPER=ID 
 ENDIF
 
 END FUNCTION PMANAGER_GETIPER
 
 !#####=================================================================
 INTEGER FUNCTION PMANAGER_FIND_KEYWORD(KEYLINE)
 !#####=================================================================
 IMPLICIT NONE
 CHARACTER(LEN=*),INTENT(IN) :: KEYLINE
 INTEGER :: I,J
 CHARACTER(LEN=3) :: CKEY

 PMANAGER_FIND_KEYWORD=0

 I=INDEX(KEYLINE,'('); J=INDEX(KEYLINE,')')
 IF(I.EQ.0.OR.J.EQ.0)RETURN; IF(J-I.NE.4)RETURN

 CKEY=KEYLINE(I+1:J-1); CKEY=UTL_CAP(CKEY,'U')

 DO I=1,SIZE(CMOD)
  IF(CKEY.EQ.CMOD(I))THEN; PMANAGER_FIND_KEYWORD=I; RETURN; ENDIF
 END DO

 END FUNCTION PMANAGER_FIND_KEYWORD
 
 !###======================================================================
 LOGICAL FUNCTION PMANAGER_GETKEYS(IU)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IU
 INTEGER :: I,J,IOS
 
 PMANAGER_GETKEYS=.FALSE.

 DO I=1,SIZE(TOPICS); CALL PMANAGER_DEALLOCATE(I); ENDDO; CALL PMANAGER_DEALLOCATE_PEST()

 READ(IU,*,IOSTAT=IOS); IF(IOS.NE.0)RETURN
 READ(IU,*,IOSTAT=IOS) PRJNLAY,PRJNLAY,PRJNPER,I,I,I,I,PEST%IIPF; IF(IOS.NE.0)RETURN
 
 IF(PEST%IIPF.NE.0)THEN
  ALLOCATE(PEST%MEASURES(ABS(PEST%IIPF)))
  PEST%IIPF=MIN(PEST%IIPF,0); IF(PEST%IIPF.LT.0)PEST%IIPF=1
  DO I=1,SIZE(PEST%MEASURES)
   READ(IU,'(A256)') LINE
   READ(LINE,*) PEST%MEASURES(I)%IPFNAME,PEST%MEASURES(I)%IPFTYPE,PEST%MEASURES(I)%IXCOL, &
                PEST%MEASURES(I)%IYCOL  ,PEST%MEASURES(I)%ILCOL  ,PEST%MEASURES(I)%IMCOL,PEST%MEASURES(I)%IVCOL
  ENDDO
 ENDIF

 !## skip common settings
 READ(IU,*) 
 
 !## read pcg solvers settings
 READ(IU,*) PCG%NOUTER,PCG%NINNER,PCG%HCLOSE,PCG%RCLOSE,PCG%RELAX
 ALLOCATE(TOPICS(33)%STRESS(1)); ALLOCATE(TOPICS(33)%STRESS(1)%FILES(1,1))
 
 TOPICS(33)%IACT=1; TOPICS(33)%IACT_MODEL=1
 PCG%NPCOND=1
 PCG%IPRPCG=1
 PCG%MUTPCG=0
 PCG%DAMPPCG=1.0D0
 PCG%DAMPPCGT=1.0D0
 !PCG%IMERGE=0
 !PCG%PARTOPT=0
 !PCG%NCORES=1

 !## find available keys
 J=0; DO
  READ(IU,'(A256)') LINE; LINE=UTL_CAP(LINE,'U')
  I=PMANAGER_FIND_KEYWORD(LINE)
  IF(I.GT.0)THEN
   TOPICS(I)%IACT=1; TOPICS(I)%IACT_MODEL=1; J=J+1
  ELSE
   IF(UTL_CAP(LINE,'U').EQ.'MODULES FOR EACH LAYER')EXIT
!   IF(J.GT.0)EXIT
  ENDIF
 ENDDO
  
 PMANAGER_GETKEYS=.TRUE.
 
 END FUNCTION PMANAGER_GETKEYS

 !###======================================================================
 LOGICAL FUNCTION PMANAGER_GETFILES(IU,ITOPIC)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IU
 INTEGER,INTENT(OUT) :: ITOPIC
 INTEGER :: I,II,IOS,IPER,KPER,NSYS,ISYS,MSYS
 CHARACTER(LEN=52) :: CDATE,C
 REAL(KIND=DP_KIND) :: DELT,CNST
 
 PMANAGER_GETFILES=.FALSE.
 
 !## find available files for different keys
 CDATE=''; IARMWP=0
 DO
  READ(IU,'(A256)',IOSTAT=IOS) LINE; IF(IOS.NE.0)EXIT; LINE=UTL_CAP(LINE,'U')

  !## try to read timestamp
  READ(LINE,*,IOSTAT=IOS) KPER,DELT,C,I; IF(IOS.EQ.0)CDATE=C

  ITOPIC=PMANAGER_FIND_KEYWORD(LINE)
  IF(ITOPIC.GT.0)THEN
   IF(TOPICS(ITOPIC)%IACT.EQ.1)THEN
   
    READ(LINE,*,IOSTAT=IOS) NSYS; IF(IOS.NE.0)RETURN; IF(NSYS.LE.0)CYCLE
    !## reduce number of system to 1 for metaswap
    IF(ITOPIC.EQ.1)THEN
     MSYS=NSYS; NSYS=1 
    ENDIF
      
    !## pst module
    IF(ITOPIC.EQ.20)THEN
     !## create new system
     IPER=0; CALL PMANAGER_STRESSES(ITOPIC,IPER)
     ISYS=0; CALL PMANAGER_SYSTEMS(ITOPIC,IPER,ISYS)
     CALL PMANAGER_LOADPST(IU,NSYS,1); TOPICS(ITOPIC)%IACT_MODEL=1; CYCLE
    ENDIF

    !## create stress-period
    IPER=0; CALL PMANAGER_STRESSES(ITOPIC,IPER)
    !## create systems
    ALLOCATE(TOPICS(ITOPIC)%STRESS(IPER)%FILES(TOPICS(ITOPIC)%NSUBTOPICS,NSYS))

    TOPICS(ITOPIC)%STRESS(IPER)%IYR=0; TOPICS(ITOPIC)%STRESS(IPER)%IMH=0; TOPICS(ITOPIC)%STRESS(IPER)%IDY=0
    TOPICS(ITOPIC)%STRESS(IPER)%IHR=0; TOPICS(ITOPIC)%STRESS(IPER)%IMT=0; TOPICS(ITOPIC)%STRESS(IPER)%ISC=0
    IF(TOPICS(ITOPIC)%TIMDEP)THEN
     TOPICS(ITOPIC)%STRESS(IPER)%CDATE=CDATE
     READ(CDATE,'(I4,5I2)',IOSTAT=IOS) TOPICS(ITOPIC)%STRESS(IPER)%IYR,TOPICS(ITOPIC)%STRESS(IPER)%IMH,TOPICS(ITOPIC)%STRESS(IPER)%IDY, &
                                       TOPICS(ITOPIC)%STRESS(IPER)%IHR,TOPICS(ITOPIC)%STRESS(IPER)%IMT,TOPICS(ITOPIC)%STRESS(IPER)%ISC
    ENDIF
    
    I=0; DO II=1,TOPICS(ITOPIC)%NSUBTOPICS
     I=I+1
     !## stop reading
     IF(I.NE.II.AND.II.EQ.TOPICS(ITOPIC)%NSUBTOPICS)EXIT
     DO ISYS=1,NSYS

      SELECT CASE (ITOPIC)
       CASE (1,13)  !## msp,pwt
        READ(IU,*,IOSTAT=IOS) TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%FCT,  &
                              TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%IMP,  &
                              TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%FNAME    
        TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%ILAY=1
        TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%IACT=1
        READ(TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%FNAME,*,IOSTAT=IOS) CNST
        IF(IOS.EQ.0)THEN
         TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%ICNST=1
         TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%CNST =CNST
         TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%FNAME=''
        ELSE
         TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%ICNST=2
         TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%CNST =-999.99
        ENDIF

        !## found ipf for artificial recharge
        IF(ITOPIC.EQ.1.AND.I.EQ.8.AND.TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%ICNST.EQ.2)THEN
         IF(INDEX(UTL_CAP(TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%FNAME,'U'),'.IPF').GT.0)THEN
          TOPICS(1)%SNAME(7) ='Recharge-ID (IDF)'
          TOPICS(1)%SNAME(8) ='Extraction (IPF)'
          TOPICS(1)%SNAME(9) ='<not neccessary>'
          I=I+1; IARMWP=1
          TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%FNAME=''
          TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%FCT=1.0D0
          TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%IMP=0.0D0
          TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%ICNST=1
          TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%CNST=-999.99
          TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%ILAY=1
          TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%IACT=1
         ELSE
          TOPICS(1)%SNAME(7) ='Artificial discharge (IDF)'
          TOPICS(1)%SNAME(8) ='Artificial layer (IDF)'
          TOPICS(1)%SNAME(9) ='Artificial location (IDF)'
         ENDIF
        ENDIF

       CASE (29) !## isg
        READ(IU,*,IOSTAT=IOS) TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%ILAY, &
                              TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%FCT,  &
                              TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%IMP,  &
                              TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%FNAME    
        TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%ICNST=2
        TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%CNST =-999.99
        TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%IACT =1
       CASE DEFAULT
        READ(IU,*,IOSTAT=IOS) TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%ILAY, &
                              TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%FCT,  &
                              TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%IMP,  &
                              TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%FNAME    
        IF(IOS.NE.0)RETURN
        TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%IACT=1
        READ(TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%FNAME,*,IOSTAT=IOS) CNST
        IF(IOS.EQ.0)THEN
         TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%ICNST=1
         TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%CNST =CNST
         TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%FNAME=''
        ELSE
         TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%ICNST=2
         TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%CNST =-999.99
        ENDIF
      END SELECT
      IF(TRIM(PREFVAL(5)).NE.'')THEN
       TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%FNAME=UTL_SUBST(TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%FNAME,TRIM(REPLACESTRING),PREFVAL(5))
      ENDIF
      TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%ALIAS= &
        UTL_CAP(TRIM(TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%FNAME(INDEX(TOPICS(ITOPIC)%STRESS(IPER)%FILES(I,ISYS)%FNAME,'\',.TRUE.)+1:)),'L')
     ENDDO
    ENDDO
    !## read in the inp files
    IF(ITOPIC.EQ.1)THEN
     MSYS=MSYS-TOPICS(ITOPIC)%NSUBTOPICS+IARMWP
     ALLOCATE(TOPICS(ITOPIC)%STRESS(IPER)%INPFILES(MSYS))
     DO ISYS=1,MSYS
      READ(IU,'(A)',IOSTAT=IOS) TOPICS(ITOPIC)%STRESS(IPER)%INPFILES(ISYS)
      TOPICS(ITOPIC)%STRESS(IPER)%INPFILES(ISYS)=ADJUSTL(TOPICS(ITOPIC)%STRESS(IPER)%INPFILES(ISYS))
     ENDDO
    ENDIF

   ENDIF
  ENDIF
 ENDDO
 
 PMANAGER_GETFILES=.TRUE.
 
 END FUNCTION PMANAGER_GETFILES

 !###======================================================================
 SUBROUTINE PMANAGER_LOADPST(IU,NPARAM,IOPTION)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: IU,NPARAM,IOPTION
 INTEGER :: I,J,IOS,N,M
 
 IF(IOPTION.EQ.0)THEN
  READ(IU,*) PEST%IIPF
  IF(PEST%IIPF.NE.0)THEN
   ALLOCATE(PEST%MEASURES(ABS(PEST%IIPF)))
   PEST%IIPF=MIN(PEST%IIPF,0); IF(PEST%IIPF.LT.0)PEST%IIPF=1
   DO I=1,SIZE(PEST%MEASURES)
    READ(IU,'(A256)') LINE
    READ(LINE,*) PEST%MEASURES(I)%IPFNAME,PEST%MEASURES(I)%IPFTYPE,PEST%MEASURES(I)%IXCOL, &
                 PEST%MEASURES(I)%IYCOL  ,PEST%MEASURES(I)%ILCOL  ,PEST%MEASURES(I)%IMCOL,PEST%MEASURES(I)%IVCOL
   ENDDO
  ENDIF
 ENDIF
  
 READ(IU,'(A256)') LINE
 READ(LINE,*,IOSTAT=IOS) PEST%PE_MXITER,PEST%PE_STOP,PEST%PE_SENS,N,M,PEST%PE_TARGET(1),PEST%PE_TARGET(2),PEST%PE_SCALING, &
                         PEST%PE_PADJ,PEST%PE_DRES,PEST%PE_KTYPE,PEST%PE_KRANGE
 IF(IOS.NE.0)THEN
  !## apply default kriging range
  PEST%PE_KRANGE=0.0D0 
  READ(LINE,*,IOSTAT=IOS) PEST%PE_MXITER,PEST%PE_STOP,PEST%PE_SENS,N,M,PEST%PE_TARGET(1),PEST%PE_TARGET(2),PEST%PE_SCALING, &
                          PEST%PE_PADJ,PEST%PE_DRES,PEST%PE_KTYPE
  IF(IOS.NE.0)THEN
   PEST%PE_KTYPE=1
   READ(LINE,*,IOSTAT=IOS) PEST%PE_MXITER,PEST%PE_STOP,PEST%PE_SENS,N,M,PEST%PE_TARGET(1),PEST%PE_TARGET(2),PEST%PE_SCALING, &
                           PEST%PE_PADJ,PEST%PE_DRES
   IF(IOS.NE.0)THEN
    PEST%PE_DRES=0.0D0
    READ(LINE,*,IOSTAT=IOS) PEST%PE_MXITER,PEST%PE_STOP,PEST%PE_SENS,N,M,PEST%PE_TARGET(1),PEST%PE_TARGET(2),PEST%PE_SCALING, &
                            PEST%PE_PADJ
    IF(IOS.NE.0)THEN
     PEST%PE_PADJ=0.0D0
     READ(LINE,*,IOSTAT=IOS) PEST%PE_MXITER,PEST%PE_STOP,PEST%PE_SENS,N,M,PEST%PE_TARGET(1),PEST%PE_TARGET(2),PEST%PE_SCALING
     IF(IOS.NE.0)THEN
      PEST%PE_SCALING=0
      READ(LINE,*,IOSTAT=IOS) PEST%PE_MXITER,PEST%PE_STOP,PEST%PE_SENS,N,M,PEST%PE_TARGET(1),PEST%PE_TARGET(2)
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDIF
 
 IF(PEST%PE_KTYPE.LE.0)THEN
  READ(IU,'(A)') PEST%PPBNDIDF
 ENDIF
 
 PEST%PE_SCALING=PEST%PE_SCALING+1

 !## periods defined
 IF(N.GT.0)THEN
  ALLOCATE(PEST%S_PERIOD(N),PEST%E_PERIOD(N))
  PEST%S_PERIOD='0'; PEST%E_PERIOD='0'
  DO I=1,SIZE(PEST%S_PERIOD)
   READ(IU,'(A256)') LINE
   READ(LINE,*) PEST%S_PERIOD(I),PEST%E_PERIOD(I) 
  ENDDO
 ENDIF

 !## batchfiles defined
 IF(M.GT.0)THEN
  ALLOCATE(PEST%B_FRACTION(M),PEST%B_BATCHFILE(M),PEST%B_OUTFILE(M))
  PEST%B_FRACTION=1.0D0; PEST%B_BATCHFILE=''; PEST%B_OUTFILE=''
  DO I=1,SIZE(PEST%B_FRACTION)
   READ(IU,'(A256)') LINE
   READ(LINE,*,IOSTAT=IOS) PEST%B_FRACTION(I),PEST%B_BATCHFILE(I),PEST%B_OUTFILE(I) 
  ENDDO
 ENDIF

 IF(NPARAM.GT.0)THEN
  ALLOCATE(PEST%PARAM(NPARAM))
  DO I=1,SIZE(PEST%PARAM)
   READ(IU,'(A256)') LINE
   READ(LINE,*,IOSTAT=IOS) PEST%PARAM(I)%PACT,PEST%PARAM(I)%PPARAM,PEST%PARAM(I)%PILS,PEST%PARAM(I)%PIZONE,PEST%PARAM(I)%PINI,PEST%PARAM(I)%PDELTA, &
                           PEST%PARAM(I)%PMIN,PEST%PARAM(I)%PMAX,PEST%PARAM(I)%PINCREASE,PEST%PARAM(I)%PIGROUP,PEST%PARAM(I)%PLOG,PEST%PARAM(I)%ACRONYM
   IF(IOS.NE.0)THEN
    PEST%PARAM(I)%ACRONYM=''
    READ(LINE,*,IOSTAT=IOS) PEST%PARAM(I)%PACT,PEST%PARAM(I)%PPARAM,PEST%PARAM(I)%PILS,PEST%PARAM(I)%PIZONE,PEST%PARAM(I)%PINI,PEST%PARAM(I)%PDELTA, &
                            PEST%PARAM(I)%PMIN,PEST%PARAM(I)%PMAX,PEST%PARAM(I)%PINCREASE,PEST%PARAM(I)%PIGROUP,PEST%PARAM(I)%PLOG
    PEST%PARAM(I)%PPARAM=UTL_CAP(PEST%PARAM(I)%PPARAM,'U')
    IF(IOS.NE.0)THEN

     SELECT CASE (PEST%PARAM(I)%PPARAM)
      !## recharge/anisotropy angle non log transformed
      CASE ('RE','AH')
       PEST%PARAM(I)%PLOG=0
      CASE DEFAULT
       PEST%PARAM(I)%PLOG=1
     END SELECT

     READ(LINE,*,IOSTAT=IOS) PEST%PARAM(I)%PACT,PEST%PARAM(I)%PPARAM,PEST%PARAM(I)%PILS,PEST%PARAM(I)%PIZONE,PEST%PARAM(I)%PINI,PEST%PARAM(I)%PDELTA, &
                  PEST%PARAM(I)%PMIN,PEST%PARAM(I)%PMAX,PEST%PARAM(I)%PINCREASE,PEST%PARAM(I)%PIGROUP
     IF(IOS.NE.0)THEN

      PEST%PARAM(I)%PIGROUP=I
      READ(LINE,*,IOSTAT=IOS) PEST%PARAM(I)%PACT,PEST%PARAM(I)%PPARAM,PEST%PARAM(I)%PILS,PEST%PARAM(I)%PIZONE,PEST%PARAM(I)%PINI,PEST%PARAM(I)%PDELTA,  &
                   PEST%PARAM(I)%PMIN,PEST%PARAM(I)%PMAX,PEST%PARAM(I)%PINCREASE
      IF(IOS.NE.0)THEN
       CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Error reading runfile in the PST section with the parameter definitions.','Error')
       RETURN
      ENDIF
     ENDIF
    ENDIF
   ENDIF

   !## fill in iparam
   DO J=1,SIZE(PARAM); IF(PEST%PARAM(I)%PPARAM.EQ.PARAM(J))EXIT; ENDDO
   PEST%PARAM(I)%IPARAM=J

  ENDDO
 ENDIF

 READ(IU,*) I
 IF(I.GT.0)THEN
  ALLOCATE(PEST%IDFFILES(I))
  DO I=1,SIZE(PEST%IDFFILES)
   READ(IU,'(A256)') LINE
   READ(LINE,*) PEST%IDFFILES(I)
  ENDDO
 ENDIF
 
 END SUBROUTINE PMANAGER_LOADPST
 
 !###======================================================================
 SUBROUTINE PMANAGER_STRESSES(ITOPIC,IPER)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: ITOPIC
 INTEGER,INTENT(INOUT) :: IPER
 INTEGER :: N,I,J,K
 
 IF(IPER.GT.0)RETURN
 
 IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS))THEN
  !## only increase for timedependent information
  IF(TOPICS(ITOPIC)%TIMDEP)THEN
   !## make copy of current memory
   N=SIZE(TOPICS(ITOPIC)%STRESS)
   NULLIFY(TOPICS(ITOPIC)%STRESS_TMP)
   ALLOCATE(TOPICS(ITOPIC)%STRESS_TMP(N+1))
   DO I=1,N
    J=SIZE(TOPICS(ITOPIC)%STRESS(I)%FILES,1)
    K=SIZE(TOPICS(ITOPIC)%STRESS(I)%FILES,2)
    NULLIFY(TOPICS(ITOPIC)%STRESS_TMP(I)%FILES)
    NULLIFY(TOPICS(ITOPIC)%STRESS_TMP(I)%INPFILES)
    ALLOCATE(TOPICS(ITOPIC)%STRESS_TMP(I)%FILES(J,K))
    TOPICS(ITOPIC)%STRESS_TMP(I)%FILES=TOPICS(ITOPIC)%STRESS(I)%FILES
    TOPICS(ITOPIC)%STRESS_TMP(I)%CDATE=TOPICS(ITOPIC)%STRESS(I)%CDATE
    TOPICS(ITOPIC)%STRESS_TMP(I)%IYR=TOPICS(ITOPIC)%STRESS(I)%IYR
    TOPICS(ITOPIC)%STRESS_TMP(I)%IMH=TOPICS(ITOPIC)%STRESS(I)%IMH
    TOPICS(ITOPIC)%STRESS_TMP(I)%IDY=TOPICS(ITOPIC)%STRESS(I)%IDY
    TOPICS(ITOPIC)%STRESS_TMP(I)%IHR=TOPICS(ITOPIC)%STRESS(I)%IHR
    TOPICS(ITOPIC)%STRESS_TMP(I)%IMT=TOPICS(ITOPIC)%STRESS(I)%IMT
    TOPICS(ITOPIC)%STRESS_TMP(I)%ISC=TOPICS(ITOPIC)%STRESS(I)%ISC
    DEALLOCATE(TOPICS(ITOPIC)%STRESS(I)%FILES)
   ENDDO
   TOPICS(ITOPIC)%STRESS=>TOPICS(ITOPIC)%STRESS_TMP
   IPER=N+1 
  ELSE
   IPER=1
  ENDIF
 ELSE
  ALLOCATE(TOPICS(ITOPIC)%STRESS(1))
  NULLIFY(TOPICS(ITOPIC)%STRESS(1)%FILES)

  TOPICS(ITOPIC)%IACT      =1
  TOPICS(ITOPIC)%IACT_MODEL=1

  IPER=1
 ENDIF

 END SUBROUTINE PMANAGER_STRESSES

 !###======================================================================
 SUBROUTINE PMANAGER_SYSTEMS(ITOPIC,IPER,ISYS)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: ITOPIC,IPER
 INTEGER,INTENT(INOUT) :: ISYS
 INTEGER :: N,M

 !## create new system
 IF(ISYS.GT.0)RETURN
  
 IF(ASSOCIATED(TOPICS(ITOPIC)%STRESS(IPER)%FILES))THEN
  !## make copy of current memory
  M=SIZE(TOPICS(ITOPIC)%STRESS(IPER)%FILES,1)
  N=SIZE(TOPICS(ITOPIC)%STRESS(IPER)%FILES,2)
  NULLIFY(TOPICS(ITOPIC)%STRESS(IPER)%FILES_TMP)
  ALLOCATE(TOPICS(ITOPIC)%STRESS(IPER)%FILES_TMP(M,N+1))
  TOPICS(ITOPIC)%STRESS(IPER)%FILES_TMP(1:M,1:N)=TOPICS(ITOPIC)%STRESS(IPER)%FILES(1:M,1:N)
  DEALLOCATE(TOPICS(ITOPIC)%STRESS(IPER)%FILES)
  TOPICS(ITOPIC)%STRESS(IPER)%FILES=>TOPICS(ITOPIC)%STRESS(IPER)%FILES_TMP
  ISYS=N+1
 ELSE
  N=TOPICS(ITOPIC)%NSUBTOPICS
  ALLOCATE(TOPICS(ITOPIC)%STRESS(IPER)%FILES(N,1))
  ISYS=1
 ENDIF
 
 END SUBROUTINE PMANAGER_SYSTEMS
 
 !###======================================================================
 SUBROUTINE PMANAGERSTART(RUNFNAME,IRUNMODE,IBATCH,NICORES,ILOGFILE)
 !###======================================================================
 IMPLICIT NONE
 CHARACTER(LEN=*),INTENT(IN) :: RUNFNAME
 INTEGER,INTENT(IN) :: IRUNMODE,IBATCH,NICORES,ILOGFILE
 CHARACTER(LEN=256) :: DIR,DIRNAME
 CHARACTER(LEN=52) :: MNAME
 INTEGER :: IU,IOS,I,IFLAGS,IEXCOD,IERROR,IMODE
 LOGICAL :: LEX

 IMODE=0

 IF(LEN_TRIM(PREFVAL(8)).GT.0)THEN
  INQUIRE(FILE=PREFVAL(8),EXIST=LEX)
 ELSE
  LEX=.FALSE.
 ENDIF
 IF(.NOT.LEX)THEN
  IF(IBATCH.EQ.0)THEN
   CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'iMODFLOW cannot be started, iMOD cannot find the executable:'//CHAR(13)// &
    '['//TRIM(PREFVAL(8))//']','Error')
  ELSE
   WRITE(*,'(A)') 'iMODFLOW cannot be started, iMOD cannot find the exectuable given'
   WRITE(*,'(A)') '['//TRIM(PREFVAL(8))//']'
  ENDIF
  RETURN
 ENDIF
 
 IMODE=0

 !## runfile or namfile
 IF(INDEX(UTL_CAP(RUNFNAME,'U'),'.NAM',.TRUE.).GT.0)THEN
  IMODE=1
 ELSEIF(INDEX(UTL_CAP(RUNFNAME,'U'),'.RUN',.TRUE.).GT.0)THEN
  IMODE=2
 ELSE
  IF(IBATCH.EQ.0)THEN
   CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'iMODFLOW cannot be started with given file:'//CHAR(13)// &
    TRIM(RUNFNAME),'Error')
  ELSE
   WRITE(*,'(A)') 'iMODFLOW cannot be started with given file: '//TRIM(RUNFNAME)
  ENDIF
  RETURN
 ENDIF

 !## simulation directory 
 DIR=RUNFNAME(:INDEX(RUNFNAME,'\',.TRUE.)-1)
 CALL UTL_CREATEDIR(DIR)
 !## modelname
 MNAME=RUNFNAME(INDEX(RUNFNAME,'\',.TRUE.)+1:INDEX(RUNFNAME,'.',.TRUE.)-1)
 
 !## create component file
 IF(LMSP)THEN
  IU=UTL_GETUNIT()
  CALL OSD_OPEN(IU,FILE=TRIM(DIR)//'\COMPONENTS.INP',STATUS='REPLACE',ACTION='WRITE,DENYREAD',IOSTAT=IOS)
  IF(IOS.NE.0)THEN
   IF(IBATCH.EQ.0)THEN
    CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'iMODFLOW is already running, you cannot start '//CHAR(13)// &
     'new run while previous run is still running'//CHAR(13)//'or'//CHAR(13)//'Run-script cannot be created'//CHAR(13)// &
     TRIM(DIR)//'\COMPONENTS.INP','Error')
   ELSE
    WRITE(*,'(A)') 'iMODFLOW is already running, you cannot start new run while previous run is still running'// &
        'or Run-script cannot be created '//TRIM(DIR)//'\COMPONENTS.INP'
   ENDIF
   RETURN
  ENDIF
  WRITE(IU,'(A)') 'MODFLOW -wd \MODELINPUT -namfile '//TRIM(DIR)//'\'//TRIM(MNAME)//'.NAM -DXC .\MODELINPUT\'//TRIM(MNAME)//'.DXC'
  WRITE(IU,'(A)') 'METASWAP -wd \MSWAPINPUT'
  CLOSE(IU)  
 ENDIF

 !## simulate batch-file, inclusive pause statement.
 IU=UTL_GETUNIT()
 CALL OSD_OPEN(IU,FILE=TRIM(DIR)//'\RUN.BAT',STATUS='REPLACE',ACTION='WRITE,DENYREAD',IOSTAT=IOS)
 IF(IOS.NE.0)THEN
  IF(IBATCH.EQ.0)THEN
   CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'iMODFLOW is already running, you cannot start '//CHAR(13)// &
    'new run while previous run is still running'//CHAR(13)//'or'//CHAR(13)//'Run-script cannot be created'//CHAR(13)// &
    TRIM(DIR)//'\RUN.BAT','Error')
  ELSE
   WRITE(*,'(A)') 'iMODFLOW is already running, you cannot start new run while previous run is still running'// &
       'or Run-script cannot be created '//TRIM(DIR)//'\RUN.BAT'
  ENDIF
  RETURN
 ENDIF

 !## remove previous version of imodflow
 I=INDEXNOCASE(PREFVAL(8),'\',.TRUE.)+1
 INQUIRE(FILE=TRIM(DIR)//'\'//TRIM(PREFVAL(8)(I:)),EXIST=LEX)
 IF(LEX)CALL IOSDELETEFILE(TRIM(DIR)//'\'//TRIM(PREFVAL(8)(I:)))

 !## copy imodflow executable
 CALL IOSCOPYFILE(TRIM(PREFVAL(8)),TRIM(DIR)//'\'//TRIM(PREFVAL(8)(I:)))
 
 INQUIRE(FILE=TRIM(EXEPATH)//'\'//TRIM(LICFILE),EXIST=LEX)
 IF(.NOT.LEX)THEN
  IERROR=0; CALL IMOD_AGREEMENT(IERROR)
  IF(IERROR.NE.1)THEN
   IF(LBETA)THEN
    IF(IBATCH.EQ.0)THEN
     CALL WMESSAGEBOX(OKONLY,COMMONOK,EXCLAMATIONICON,'Cannot start Beta-iMOD because you are not authorized in writing for Beta-iMOD','Error')
    ELSE
     WRITE(*,'(A)') 'Cannot start Beta-iMOD because you are not authorized in writing for Beta-iMOD'
    ENDIF
   ELSE
    IF(IBATCH.EQ.0)THEN
     CALL WMESSAGEBOX(OKONLY,COMMONOK,EXCLAMATIONICON,'Cannot start iMODFLOW unless you accept the iMOD Software License Agreement','Error')
    ELSE
     WRITE(*,'(A)') 'Cannot start iMODFLOW unless you accept the iMOD Software License Agreement'
    ENDIF
   ENDIF
   RETURN
  ENDIF
 ENDIF

 !## copy imod license text file
 CALL IOSCOPYFILE(TRIM(EXEPATH)//'\'//TRIM(LICFILE),TRIM(DIR)//'\'//TRIM(LICFILE))

 !## write start script in batch file
 WRITE(IU,'(A)') 'REM =========================='
 WRITE(IU,'(A)') 'REM Run Script iMOD '//TRIM(RVERSION)
 WRITE(IU,'(A)') 'REM =========================='
 !## namfile
 IF(IMODE.EQ.1)THEN

  IF(PBMAN%IFORMAT.EQ.1)WRITE(IU,'(A)') 'TITLE "NAMFILE: '//TRIM(MNAME)//'.nam"' 

  IF(LMSP)THEN
   IF(PBMAN%IPEST.EQ.0)THEN
    WRITE(IU,'(/A/)') '"'//TRIM(PREFVAL(8))//'" -components components.inp' 
   ELSE
    WRITE(IU,'(/A/)') '"'//TRIM(PREFVAL(8))//'" -components components.inp -ipest ".\modelinput\'//TRIM(MNAME)//'.pst1"' 
   ENDIF
  ELSE
   IF(PBMAN%IPEST.EQ.0)THEN
    IF(PBMAN%IFORMAT.EQ.2)WRITE(IU,'(/A/)') '"'//TRIM(PREFVAL(8))//'" "'//TRIM(MNAME)//'.nam"' 
    IF(PBMAN%IFORMAT.EQ.3)WRITE(IU,'(/A/)') '"'//TRIM(PREFVAL(8))//'"' 
   ELSE
    WRITE(IU,'(/A/)') '"'//TRIM(PREFVAL(8))//'" "'//TRIM(MNAME)//'.nam" -ipest ".\modelinput\'//TRIM(MNAME)//'.pst1"'
   ENDIF
  ENDIF

  !## include conversion of sfr package into isg-file
  IF(LSFR)THEN
   WRITE(IU,'(/A)') 'REM ============================================='
   WRITE(IU,'( A)') 'REM iMOD Batch Script iMOD '//TRIM(RVERSION)
   WRITE(IU,'( A)') 'REM ============================================='
   WRITE(IU,'( A)')  'ECHO FUNCTION=SFRTOISG > SFRTOISG.INI'
   WRITE(IU,'( A)')  'ECHO ISGFILE_IN= "'//TRIM(DIR)//'\MODELINPUT\SFR7\SFR.ISG" >> SFRTOISG.INI'
   WRITE(IU,'( A)')  'ECHO ISGFILE_OUT="'//TRIM(DIR)//'\BDGSFR\ISG\SFR.ISG" >> SFRTOISG.INI'
   WRITE(IU,'(A/)')  'ECHO SFRFILE_IN= "'//TRIM(DIR)//'\'//TRIM(MNAME)//'_FSFR.TXT" >> SFRTOISG.INI'
   WRITE(IU,'(A)') 
   WRITE(IU,'(A)') '"'//TRIM(EXENAME)//'" SFRTOISG.INI'
   WRITE(IU,'(A)') 
  ENDIF
  
 !## runfile
 ELSEIF(IMODE.EQ.2)THEN
 
  IF(IBATCH.EQ.0)THEN
   IF(NICORES.GT.1)THEN
    WRITE(IU,'(A)') ':: Set number of MPI processes'
    WRITE(IU,'(A)') 'set np='//ITOS(NICORES)
    WRITE(IU,'(A)') ''
    WRITE(IU,'(A)') ':: Run model'
    WRITE(IU,'(A)') '"C:\Program Files\MPICH2\bin\mpiexec.exe" -localonly %np% "'//TRIM(PREFVAL(8))//'" '//TRIM(MNAME)//'.run"'
   ELSE
    WRITE(IU,'(A)') '"'//TRIM(PREFVAL(8))//'" '//'IMODFLOW.RUN'
   ENDIF
  ELSE
   WRITE(IU,'(A)') '"'//TRIM(PREFVAL(8))//'" '//TRIM(MNAME)//'.run' 
  ENDIF
  
 ENDIF
 CLOSE(IU)

 !## move iMOD to the simulation directory
 CALL IOSDIRNAME(DIRNAME); CALL IOSDIRCHANGE(TRIM(DIR)//'\')

 !## start the batch file - run in the foreground
 IF(IRUNMODE.GT.0)THEN

  IFLAGS=PROCBLOCKED 
 !## executes on commandtool such that commands alike 'dir' etc. works
#if (defined(WINTERACTER11))
  IFLAGS=IFLAGS+PROCCMDPROC
#endif 

  IF(ILOGFILE.EQ.0)THEN
   CALL IOSCOMMAND('RUN.BAT',IFLAGS,IEXCOD=IEXCOD)
  ELSE
  CALL IOSCOMMAND('RUN.BAT > RUN_LOG.TXT',IFLAGS,IEXCOD=IEXCOD)
  ENDIF
  
  IF(IEXCOD.EQ.0)THEN
   IF(IBATCH.EQ.0)THEN 
    CALL WMESSAGEBOX(OKONLY,INFORMATIONICON,COMMONOK,'Successful simulation using: '//CHAR(13)// &
                   'MODFLOW:         '//TRIM(PREFVAL(8))//CHAR(13)// &
                   'RUNFILE/NAMFILE: '//TRIM(RUNFNAME),'Information')
   ELSE
    WRITE(*,'(A)') 'Successfully STARTED the Modflow simulation using:'
    WRITE(*,'(A)') 'MODFLOW:         '//TRIM(PREFVAL(8))
    WRITE(*,'(A)') 'RUNFILE/NAMFILE: '//TRIM(RUNFNAME)
   ENDIF
  ELSE
   IF(IBATCH.EQ.0)THEN
    CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'An error occured in starting your simulation','Error')
   ELSE
    WRITE(*,'(A)') 'An error occured in starting your simulation'
   ENDIF
  ENDIF
   
 !## start the batch file - run in the background
 ELSEIF(IRUNMODE.LT.0)THEN

  IFLAGS=0 
 !## executes on commandtool such that commands alike 'dir' etc. works

#if(defined(WINTERACTER11))
  IFLAGS=IFLAGS+PROCCMDPROC
#endif 
  
  IF(ILOGFILE.EQ.0)THEN
   CALL IOSCOMMAND('RUN.BAT',IFLAGS,IEXCOD=IEXCOD)
  ELSE
   CALL IOSCOMMAND('RUN.BAT > RUN_LOG.TXT',IFLAGS,IEXCOD=IEXCOD)
  ENDIF
  
  IF(IBATCH.EQ.0)THEN
   CALL WMESSAGEBOX(OKONLY,INFORMATIONICON,COMMONOK,'Successfully STARTED the Modflow simulation using:'//CHAR(13)// &
                  'MODFLOW:         '//TRIM(PREFVAL(8))//CHAR(13)// &
                  'RUNFILE/NAMFILE: '//TRIM(RUNFNAME),'Information')
  ELSE
   WRITE(*,'(A)') 'Successful simulation using:'
   WRITE(*,'(A)') 'MODFLOW:         '//TRIM(PREFVAL(8))
   WRITE(*,'(A)') 'RUNFILE/NAMFILE: '//TRIM(RUNFNAME)
  ENDIF

 ENDIF

 CALL IOSDIRCHANGE(DIRNAME)

 END SUBROUTINE PMANAGERSTART

 !###====================================================================
 LOGICAL FUNCTION PMANAGER_SAVEMF2005_COARSEGRID(IDF,X1,Y1,X2,Y2,BUFFERCS)
 !###====================================================================
 IMPLICIT NONE
 TYPE(IDFOBJ),INTENT(INOUT) :: IDF
 REAL(KIND=DP_KIND),INTENT(IN) :: BUFFERCS,X1,Y1,X2,Y2
 REAL(KIND=DP_KIND),PARAMETER :: INC=1.0D0                    !## minimal scaling in interest
 REAL(KIND=DP_KIND),PARAMETER :: FINCR=0.02D0
 REAL(KIND=DP_KIND),PARAMETER :: POWR=0.3     !     
 INTEGER :: NOMAXCELL                         !## maximal # cells in the end
 INTEGER,PARAMETER :: NOMINCELL=1             !## minimal # cells in the centre
 LOGICAL,PARAMETER :: LCLIP=.TRUE.            !## along edge small cells
 INTEGER :: IC1,IC2,IR1,IR2,ORGNCOL,ORGNROW,OC1,OC2,OR1,OR2,I
 INTEGER,ALLOCATABLE,DIMENSION(:) :: PDELR,PDELC
 REAL(KIND=DP_KIND),DIMENSION(:),ALLOCATABLE :: DX,DY
 
 PMANAGER_SAVEMF2005_COARSEGRID=.FALSE.
 
 NOMAXCELL=INT(BUFFERCS/IDF%DX)

 IC1=INT((X1-IDF%XMIN)/IDF%DX)+1
 IC2=INT((X2-IDF%XMIN)/IDF%DX)+1
 IR1=INT((IDF%YMAX-Y1)/IDF%DY)+1
 IR2=INT((IDF%YMAX-Y2)/IDF%DY)+1

 ORGNCOL=IDF%NCOL
 ORGNROW=IDF%NROW

 ALLOCATE(PDELR(IDF%NCOL),PDELC(IDF%NROW))
 CALL UTL_MODELLHS1(PDELR,ORGNCOL,IDF%NCOL,IC1,IC2,OC1,OC2,INC,FINCR,POWR,NOMINCELL,NOMAXCELL,LCLIP)
 CALL UTL_MODELLHS1(PDELC,ORGNROW,IDF%NROW,IR1,IR2,OR1,OR2,INC,FINCR,POWR,NOMINCELL,NOMAXCELL,LCLIP)

 IDF%IEQ=1; IF(.NOT.IDFALLOCATESXY(IDF))RETURN
 
 ALLOCATE(DX(IDF%NCOL),DY(IDF%NROW))

 CALL PMANAGER_SAVEMF2005_COARSEGRID_RESULT(PDELR,DX,IDF%NCOL,ORGNCOL,IDF%DX)
 CALL PMANAGER_SAVEMF2005_COARSEGRID_RESULT(PDELC,DY,IDF%NROW,ORGNROW,IDF%DY)

 IDF%SX(0)=IDF%XMIN
 DO I=1,IDF%NCOL; IDF%SX(I)=IDF%SX(I-1)+DX(I); ENDDO
 IDF%SY(0)=IDF%YMAX
 DO I=1,IDF%NROW; IDF%SY(I)=IDF%SY(I-1)-DY(I); ENDDO

 DEALLOCATE(DX,DY)
 
 PMANAGER_SAVEMF2005_COARSEGRID=.TRUE.

 END FUNCTION PMANAGER_SAVEMF2005_COARSEGRID

 !###====================================================================
 SUBROUTINE PMANAGER_SAVEMF2005_COARSEGRID_RESULT(IX,DX,NX,NXORG,SIMCSIZE)
 !###====================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: NX,NXORG
 REAL(KIND=DP_KIND),INTENT(IN) :: SIMCSIZE
 REAL(KIND=DP_KIND),INTENT(OUT),DIMENSION(NX) :: DX
 INTEGER,INTENT(IN),DIMENSION(NXORG) :: IX
 INTEGER :: I,J,K
 
 J=1
 K=1
 DO I=2,NXORG
  IF(IX(I).NE.IX(I-1))THEN
   DX(K)=SIMCSIZE*REAL(J)
   K=K+1
   J=1
  ELSE
   J=J+1
  ENDIF
 END DO
 DX(K)=SIMCSIZE*REAL(J)

 END SUBROUTINE PMANAGER_SAVEMF2005_COARSEGRID_RESULT

 !###======================================================================
 LOGICAL FUNCTION PMANAGER_SAVEMF2005_PCK_GETMINMAX(X,NCOL,NROW,XB,MINV,MAXV,IFBND)
 !###======================================================================
 IMPLICIT NONE
 REAL(KIND=DP_KIND),INTENT(IN),DIMENSION(NCOL,NROW) :: X,XB
 INTEGER,INTENT(IN) :: NROW,NCOL,IFBND
 INTEGER :: IROW,ICOL,I
 REAL(KIND=DP_KIND),INTENT(OUT) :: MINV,MAXV

 PMANAGER_SAVEMF2005_PCK_GETMINMAX=.FALSE.

 MINV=HUGE(1.0D0); MAXV=-HUGE(1.0D0); I=0
 DO IROW=1,PRJIDF%NROW; DO ICOL=1,PRJIDF%NCOL
  !## skip nodata points
  IF(X(ICOL,IROW).EQ.HNOFLOW)CYCLE
  !## check on active nodes only
  IF(IFBND.EQ.1)THEN
   IF(XB(ICOL,IROW).NE.0.0D0)THEN 
    MINV=MIN(MINV,X(ICOL,IROW))
    MAXV=MAX(MAXV,X(ICOL,IROW))
    I   =I+1
   ENDIF
  ELSE
   MINV=MIN(MINV,X(ICOL,IROW))
   MAXV=MAX(MAXV,X(ICOL,IROW))
   I   =I+1
  ENDIF
 ENDDO; ENDDO

 IF(I.LE.0)THEN
  MINV=HNOFLOW; MAXV=MINV
!  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Cannot find any data for active cells'//CHAR(13)// &
!    TRIM(EXFNAME),'Error')
 ENDIF

 PMANAGER_SAVEMF2005_PCK_GETMINMAX=.TRUE.
 
 END FUNCTION PMANAGER_SAVEMF2005_PCK_GETMINMAX

 !###======================================================================
 SUBROUTINE PMANAGER_SAVEMF2005_ALLOCATEPCK(N)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: N
 INTEGER :: I
 
 IF(ALLOCATED(PCK))CALL PMANAGER_SAVEMF2005_DEALLOCATEPCK()

 ALLOCATE(PCK(N))
 DO I=1,N
  CALL IDFNULLIFY(PCK(I))
  CALL IDFCOPY(BND(1),PCK(I)) 
 ENDDO
 
 END SUBROUTINE PMANAGER_SAVEMF2005_ALLOCATEPCK

 !###======================================================================
 SUBROUTINE PMANAGER_SAVEMF2005_DEALLOCATEPCK()
 !###======================================================================
 IMPLICIT NONE
 INTEGER:: N,I
 
 IF(.NOT.ALLOCATED(PCK))RETURN
 
 N=SIZE(PCK)
 DO I=1,N; CALL IDFDEALLOCATEX(PCK(I)); ENDDO
 DEALLOCATE(PCK)
  
 END SUBROUTINE PMANAGER_SAVEMF2005_DEALLOCATEPCK

 !###======================================================================
 SUBROUTINE PMANAGER_ALLOCATE()
 !###======================================================================
 IMPLICIT NONE
 INTEGER :: I,N,M
 
 DO I=1,SIZE(TOPICS)
  IF(ASSOCIATED(TOPICS(I)%STRESS))THEN
   N=SIZE(TOPICS(I)%STRESS)
   M=TOPICS(I)%NSUBTOPICS
   IF(ASSOCIATED(TOPICS(I)%IDT))DEALLOCATE(TOPICS(I)%IDT)
   IF(ASSOCIATED(TOPICS(I)%ISD))DEALLOCATE(TOPICS(I)%ISD)
   ALLOCATE(TOPICS(I)%IDT(N))
   ALLOCATE(TOPICS(I)%ISD(N,M))
   TOPICS(I)%IDT=0; TOPICS(I)%ISD=0
  ENDIF
 ENDDO
 
 END SUBROUTINE PMANAGER_ALLOCATE

 !###======================================================================
 SUBROUTINE PMANAGER_DEALLOCATE(I)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: I
 INTEGER :: J
 
 IF(ASSOCIATED(TOPICS(I)%STRESS))THEN
  DO J=1,SIZE(TOPICS(I)%STRESS)
   IF(ASSOCIATED(TOPICS(I)%STRESS(J)%FILES))DEALLOCATE(TOPICS(I)%STRESS(J)%FILES)
   IF(ASSOCIATED(TOPICS(I)%STRESS(J)%INPFILES))DEALLOCATE(TOPICS(I)%STRESS(J)%INPFILES)
  ENDDO
  DEALLOCATE(TOPICS(I)%STRESS)
 ENDIF
 IF(ASSOCIATED(TOPICS(I)%IDT))DEALLOCATE(TOPICS(I)%IDT)
 IF(ASSOCIATED(TOPICS(I)%ISD))DEALLOCATE(TOPICS(I)%ISD)
 NULLIFY(TOPICS(I)%STRESS); NULLIFY(TOPICS(I)%IDT); NULLIFY(TOPICS(I)%ISD)
 TOPICS(I)%IACT_MODEL=0
 
 END SUBROUTINE PMANAGER_DEALLOCATE
 
 !#####=================================================================
 SUBROUTINE PMANAGER_DEALLOCATE_PEST()
 !#####=================================================================
 IMPLICIT NONE
 
 IF(ASSOCIATED(PEST%PARAM))      DEALLOCATE(PEST%PARAM)
 IF(ASSOCIATED(PEST%S_PERIOD))   DEALLOCATE(PEST%S_PERIOD)
 IF(ASSOCIATED(PEST%E_PERIOD))   DEALLOCATE(PEST%E_PERIOD)
 IF(ASSOCIATED(PEST%B_FRACTION)) DEALLOCATE(PEST%B_FRACTION)
 IF(ASSOCIATED(PEST%B_BATCHFILE))DEALLOCATE(PEST%B_BATCHFILE)
 IF(ASSOCIATED(PEST%B_OUTFILE))  DEALLOCATE(PEST%B_OUTFILE)

 END SUBROUTINE PMANAGER_DEALLOCATE_PEST

 !###======================================================================
 SUBROUTINE PMANAGER_UTL_SHOW(ICODE)
 !###======================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: ICODE
 
 CALL WINDOWSELECT(0)
 IF(WMENUGETSTATE(ID_PMANAGER,2).EQ.1)THEN
  IF(ICODE.EQ.0)THEN; CALL PMANAGER_UTL_CLOSE(); RETURN; ENDIF
 ENDIF
 CALL WMENUSETSTATE(ID_PMANAGER,2,1)

 CALL WDIALOGSELECT(ID_DPMANAGER); CALL WDIALOGSHOW(0,65,0,2)

 END SUBROUTINE PMANAGER_UTL_SHOW

 !###======================================================================
 SUBROUTINE PMANAGER_UTL_INIT()
 !###======================================================================
 IMPLICIT NONE
 INTEGER :: I
 
 TOPICS(1)%TNAME ='(CAP) MetaSwap'
 TOPICS(2)%TNAME ='(TOP) Top Elevation'
 TOPICS(3)%TNAME ='(BOT) Bottom Elevation'
 TOPICS(4)%TNAME ='(BND) Boundary Condition'
 TOPICS(5)%TNAME ='(SHD) Starting Heads'
 TOPICS(6)%TNAME ='(KDW) Transmissivity'
 TOPICS(7)%TNAME ='(KHV) Horizontal Permeability'
 TOPICS(8)%TNAME ='(KVA) Vertical Anisotropy'
 TOPICS(9)%TNAME ='(VCW) Vertical Resistance'
 TOPICS(10)%TNAME='(KVV) Vertical Permeability'
 TOPICS(11)%TNAME='(STO) Confined Storage Coefficient'
 TOPICS(12)%TNAME='(SPY) Specific Yield'
 TOPICS(13)%TNAME='(PWT) Perched Water Table'
 TOPICS(14)%TNAME='(ANI) Anisotropy'
 TOPICS(15)%TNAME='(HFB) Horizontal Flow Barrier'
 TOPICS(16)%TNAME='(IBS) Interbed Storage'
 TOPICS(17)%TNAME='(SFT) StreamFlow Thickness'
 TOPICS(18)%TNAME='(UZF) Unsaturated Zone Flow Package'
 TOPICS(19)%TNAME='(MNW) Multi Node Well Package'
 TOPICS(20)%TNAME='(PST) Parameter Estimation'
 TOPICS(21)%TNAME='(WEL) Wells'
 TOPICS(22)%TNAME='(DRN) Drainage'
 TOPICS(23)%TNAME='(RIV) Rivers'
 TOPICS(24)%TNAME='(EVT) Evapotranspiration'
 TOPICS(25)%TNAME='(GHB) General Head Boundary'
 TOPICS(26)%TNAME='(RCH) Recharge'
 TOPICS(27)%TNAME='(OLF) Overland Flow'
 TOPICS(28)%TNAME='(CHD) Constant Head Boundary'
 TOPICS(29)%TNAME='(ISG) iMOD Segment Rivers'
 TOPICS(30)%TNAME='(SFR) Stream Flow Routing'
 TOPICS(31)%TNAME='(FHB) Flow and Head Boundary'
 TOPICS(32)%TNAME='(LAK) Lake Package'
 TOPICS(33)%TNAME='(PCG) Precondition Conjugate-Gradient'

 TOPICS(1)%NSUBTOPICS =22 !CAP
 TOPICS(2)%NSUBTOPICS =1  !TOP
 TOPICS(3)%NSUBTOPICS =1  !BOT
 TOPICS(4)%NSUBTOPICS =1  !BND
 TOPICS(5)%NSUBTOPICS =1  !SHD
 TOPICS(6)%NSUBTOPICS =1  !KDW
 TOPICS(7)%NSUBTOPICS =1  !KHV
 TOPICS(8)%NSUBTOPICS =1  !KHA
 TOPICS(9)%NSUBTOPICS =1  !VCW
 TOPICS(10)%NSUBTOPICS=1  !KVV
 TOPICS(11)%NSUBTOPICS=1  !STO
 TOPICS(12)%NSUBTOPICS=1  !SSC
 TOPICS(13)%NSUBTOPICS=6  !PWT
 TOPICS(14)%NSUBTOPICS=2  !ANI
 TOPICS(15)%NSUBTOPICS=1  !HFB
 TOPICS(16)%NSUBTOPICS=4  !IBS
 TOPICS(17)%NSUBTOPICS=2  !SFT
 TOPICS(18)%NSUBTOPICS=8  !UZF
 TOPICS(19)%NSUBTOPICS=1  !MNW
 TOPICS(20)%NSUBTOPICS=1  !PST
 TOPICS(21)%NSUBTOPICS=1  !WEL
 TOPICS(22)%NSUBTOPICS=2  !DRN
 TOPICS(23)%NSUBTOPICS=4  !RIV
 TOPICS(24)%NSUBTOPICS=3  !EVT
 TOPICS(25)%NSUBTOPICS=2  !GHB
 TOPICS(26)%NSUBTOPICS=1  !RCH
 TOPICS(27)%NSUBTOPICS=1  !OLF
 TOPICS(28)%NSUBTOPICS=1  !CHD
 TOPICS(29)%NSUBTOPICS=1  !ISG
 TOPICS(30)%NSUBTOPICS=1  !SFR
 TOPICS(31)%NSUBTOPICS=2  !FHB
 TOPICS(32)%NSUBTOPICS=10 !LAK
 TOPICS(33)%NSUBTOPICS=1  !PCG

 TOPICS(1)%TIMDEP =.FALSE. !CAP
 TOPICS(2)%TIMDEP =.FALSE. !TOP
 TOPICS(3)%TIMDEP =.FALSE. !BOT
 TOPICS(4)%TIMDEP =.FALSE. !BND
 TOPICS(5)%TIMDEP =.FALSE. !SHD
 TOPICS(6)%TIMDEP =.FALSE. !KDW
 TOPICS(7)%TIMDEP =.FALSE. !KHV
 TOPICS(8)%TIMDEP =.FALSE. !KVA
 TOPICS(9)%TIMDEP =.FALSE. !VCW
 TOPICS(10)%TIMDEP=.FALSE. !KVV
 TOPICS(11)%TIMDEP=.FALSE. !STO
 TOPICS(12)%TIMDEP=.FALSE. !SSC
 TOPICS(13)%TIMDEP=.FALSE. !PWT
 TOPICS(14)%TIMDEP=.FALSE. !ANI
 TOPICS(15)%TIMDEP=.FALSE. !HFB
 TOPICS(16)%TIMDEP=.FALSE. !IBS
 TOPICS(17)%TIMDEP=.FALSE. !SFT
 TOPICS(18)%TIMDEP=.TRUE.  !UZF
 TOPICS(19)%TIMDEP=.TRUE.  !MNW
 TOPICS(20)%TIMDEP=.FALSE. !PST
 TOPICS(21)%TIMDEP=.TRUE.  !WEL
 TOPICS(22)%TIMDEP=.TRUE.  !DRN
 TOPICS(23)%TIMDEP=.TRUE.  !RIV
 TOPICS(24)%TIMDEP=.TRUE.  !EVT
 TOPICS(25)%TIMDEP=.TRUE.  !GHB
 TOPICS(26)%TIMDEP=.TRUE.  !RCH
 TOPICS(27)%TIMDEP=.TRUE.  !OLF
 TOPICS(28)%TIMDEP=.TRUE.  !CHD
 TOPICS(29)%TIMDEP=.TRUE.  !ISG
 TOPICS(30)%TIMDEP=.TRUE.  !SFR
 TOPICS(31)%TIMDEP=.TRUE.  !FHB
 TOPICS(32)%TIMDEP=.TRUE.  !LAK
 TOPICS(33)%TIMDEP=.FALSE. !PCG
 
 TOPICS(1)%SNAME(1)  ='(BND) Boundary (IDF)'
 TOPICS(1)%SNAME(2)  ='(LUS) Landuse (IDF)'
 TOPICS(1)%SNAME(3)  ='(RTZ) Rootzone (IDF)'
 TOPICS(1)%SNAME(4)  ='(SLT) Soiltype (IDF)'
 TOPICS(1)%SNAME(5)  ='(MST) Meteostation (IDF)'
 TOPICS(1)%SNAME(6)  ='(SFL) Surfacelevel (IDF)'
 TOPICS(1)%SNAME(7)  ='(ARQ) Artificial discharge (IDF)'
 TOPICS(1)%SNAME(8)  ='(ARL) Artificial layer (IDF)'
 TOPICS(1)%SNAME(9)  ='(ARL) Artificial location (IPF)' 
 TOPICS(1)%SNAME(10) ='(WRA) Wetted Rural Area (IDF)'
 TOPICS(1)%SNAME(11) ='(WUA) Wetted Urban Area (IDF)'
 TOPICS(1)%SNAME(12) ='(PUA) Pondingdepth Urban Area (IDF)'
 TOPICS(1)%SNAME(13) ='(PRA) Pondingdepth Rural Area (IDF)'
 TOPICS(1)%SNAME(14) ='(RUA) Runoff Resistance Urban Area (IDF)'
 TOPICS(1)%SNAME(15) ='(RRA) Runoff Resistance Rural Area (IDF)'
 TOPICS(1)%SNAME(16) ='(RUA) Runon Resistance Urban Area (IDF)'
 TOPICS(1)%SNAME(17) ='(RRA) Runon Resistance Rural Area (IDF)'
 TOPICS(1)%SNAME(18) ='(IUA) Infiltration Capacity Urban Area (IDF)'
 TOPICS(1)%SNAME(19) ='(IRA) Infiltration Capacity Rural Area (IDF)'
 TOPICS(1)%SNAME(20) ='(PWD) Purgewater Depth (IDF)'
 TOPICS(1)%SNAME(21) ='(SMF) Soil Moisture Factor (IDF)'
 TOPICS(1)%SNAME(22) ='(SPF) Soil Permeability Factor (IDF)'
 TOPICS(2)%SNAME(1)  ='(TOP) Top of Modellayer (IDF)'
 TOPICS(3)%SNAME(1)  ='(BOT) Bottom of Modellayer (IDF)'
 TOPICS(4)%SNAME(1)  ='(BND) Boundary Settings (IDF)'
 TOPICS(5)%SNAME(1)  ='(SHD) Starting Heads (IDF)'
 TOPICS(6)%SNAME(1)  ='(KDW) COnductance (IDF)'
 TOPICS(7)%SNAME(1)  ='(KHV) Horizontal Permeability (IDF)'
 TOPICS(8)%SNAME(1)  ='(KVA) Vertical Anisotropy (IDF)'
 TOPICS(9)%SNAME(1)  ='(VCW) Vertical Resistance (IDF)'
 TOPICS(10)%SNAME(1) ='(KVV) Vertical Permeability (IDF)'
 TOPICS(11)%SNAME(1) ='(STO) Storage Coefficient (IDF)'
 TOPICS(12)%SNAME(1) ='(SSY) Specific Yield / Confined Storage Coef. (IDF)'
 TOPICS(13)%SNAME(1) ='(LAY) Layer Identification (IDF)'
 TOPICS(13)%SNAME(2) ='(STO) Phreatic Storage Coefficient (IDF)'
 TOPICS(13)%SNAME(3) ='(TA1) Top of Aquifer above PWT-layer (IDF)'
 TOPICS(13)%SNAME(4) ='(TAQ) Top of Aquitard PWT-layer (IDF)'
 TOPICS(13)%SNAME(5) ='(TA2) Top of Aquifer beneath PWT-layer (IDF)'
 TOPICS(13)%SNAME(6) ='(VCP) Vertical Resistance of PWT-clay (IDF)'
 TOPICS(14)%SNAME(1) ='(FCT) Factor (IDF)'
 TOPICS(14)%SNAME(2) ='(ANG) Angle (IDF)'
 TOPICS(15)%SNAME(1) ='(HFB) Horizontal Barrier Flow (GEN)'
 TOPICS(16)%SNAME(1) ='(PCH) Preconsolidation Head (IDF)'
 TOPICS(16)%SNAME(2) ='(ESC) Elastic Storage Coefficient (IDF)'
 TOPICS(16)%SNAME(3) ='(ISC) Inelastic Storage Coefficient (IDF)'
 TOPICS(16)%SNAME(4) ='(SCP) Starting Compaction (IDF)'
 TOPICS(17)%SNAME(1) ='(SFT) Stream Flow Thickness (IDF)'
 TOPICS(17)%SNAME(2) ='(PER) Permeability (IDF)'
 TOPICS(18)%SNAME(1) ='(AEA) Areal Extent of Active Model (IDF)'
! TOPICS(18)%SNAME(2) ='Overland Flow to SFR (>0) / LAK (<0) (IDF)'
! TOPICS(18)%SNAME(2) ='Saturated Vertical Conductivity (IDF)'
 TOPICS(18)%SNAME(2) ='(BCE) Brooks-Corey Epsilon (IDF)'
 TOPICS(18)%SNAME(3) ='(SWC) Saturated Water Content of Unsat. Zone (IDF)'
! TOPICS(18)%SNAME(4) ='(RWC) Residual Water Content of Unsat. Zone (IDF)'
 TOPICS(18)%SNAME(4) ='(IWC) Initial Water Content (IDF)'
 TOPICS(18)%SNAME(5) ='(INF) Infiltration Rates at Land Surface (IDF)'
 TOPICS(18)%SNAME(6) ='(EVA) Evaporation Demands (IDF)'
 TOPICS(18)%SNAME(7) ='(EXD) Extinction Depth (IDF)'
 TOPICS(18)%SNAME(8) ='(EWC) Extinction Water Content (IDF)'
 TOPICS(19)%SNAME(1) ='(WRL) Well Rate and Well Loss (IPF)'
 TOPICS(20)%SNAME(1) ='(PAR) Parameters Estimation (-)'
 TOPICS(21)%SNAME(1) ='(WRA) Well Rate (IPF)'
 TOPICS(22)%SNAME(1) ='(CON) Conductance (IDF)'
 TOPICS(22)%SNAME(2) ='(DEL) Drainage Level (IDF)'
 TOPICS(23)%SNAME(1) ='(CON) Conductance (IDF)'
 TOPICS(23)%SNAME(2) ='(RST) River Stage (IDF)'
 TOPICS(23)%SNAME(3) ='(RBT) River Bottom (IDF)'
 TOPICS(23)%SNAME(4) ='(RIF) Infiltration Factor (IDF)'
 TOPICS(24)%SNAME(1) ='(EVA) Evapotranspiration Rate (IDF)'
 TOPICS(24)%SNAME(2) ='(SUR) Surface Level (IDF)'
 TOPICS(24)%SNAME(3) ='(EXD) Extinction Depth (IDF)'
 TOPICS(25)%SNAME(1) ='(CON) Conductance (IDF)'
 TOPICS(25)%SNAME(2) ='(LVL) Reference Level (IDF)'
 TOPICS(26)%SNAME(1) ='(RCH) Recharge Rate (IDF)'
 TOPICS(27)%SNAME(1) ='(LVL) Overland Flow Level (IDF)'
 TOPICS(28)%SNAME(1) ='(CHD) Constant Head (IDF)'
 TOPICS(29)%SNAME(1) ='(ISG) Segment River (ISG)'
 TOPICS(30)%SNAME(1) ='(ISG) Stream Flow River (ISG)'
 TOPICS(31)%SNAME(1) ='(FHB) Specified Flow (IDF)'
 TOPICS(31)%SNAME(2) ='(FHB) Specified Head (IDF)'
 TOPICS(32)%SNAME(1) ='(LID) Lake Identifications (IDF)'
 TOPICS(32)%SNAME(2) ='(LBA) Lake Bathymetry (IDF)'
 TOPICS(32)%SNAME(3) ='(INI) Initial Lake Levels (IDF)'
 TOPICS(32)%SNAME(4) ='(MIN) Minimal Lake Levels (IDF)'
 TOPICS(32)%SNAME(5) ='(MAX) Maximal Lake Levels (IDF)'
 TOPICS(32)%SNAME(6) ='(LRE) Lakebed Resistance (IDF)'
 TOPICS(32)%SNAME(7) ='(LPR) Precipitation at surface Lake (IDF)'
 TOPICS(32)%SNAME(8) ='(LEV) Evaporation at surface Lake (IDF)'
 TOPICS(32)%SNAME(9) ='(LOR) Overland runoff (IDF)'
 TOPICS(32)%SNAME(10)='(LWD) Lake Withdrawall (IDF)'
 TOPICS(33)%SNAME(1) ='(PCG) Parameters PCG method (-)'
 
 CALL WDIALOGLOAD(ID_DPMANAGER)
 CALL WDIALOGPUTIMAGE(ID_OPEN,ID_ICONOPEN,1)
 CALL WDIALOGPUTIMAGE(ID_SAVE,ID_ICONSAVEAS,1)
 CALL WDIALOGPUTIMAGE(ID_PROPERTIES,ID_ICONPROPERTIES,1)
 CALL WDIALOGPUTIMAGE(ID_PROPERTIES_AUTO,ID_ICONPROPERTIES_AUTO,1)
 CALL WDIALOGPUTIMAGE(ID_DRAW,ID_ICONDRAW,1)
 CALL WDIALOGPUTIMAGE(ID_DRAW2,ID_ICONDRAWPLUS,1)
 CALL WDIALOGPUTIMAGE(ID_OPENRUN,ID_ICONOPENRUN,1)
 CALL WDIALOGPUTIMAGE(ID_SAVERUN,ID_ICONSAVERUN,1)
 CALL WDIALOGPUTIMAGE(ID_CLEAN,ID_ICONNEW,1)
 CALL WDIALOGPUTIMAGE(ID_DELETE,ID_ICONDELETE,1)
 CALL WDIALOGPUTIMAGE(ID_CALC,ID_ICONCALC,1)
 ALLOCATE(PERIOD(MAXPERIODS)); NPERIOD=0
 
 DO I=1,SIZE(TOPICS)
  NULLIFY(TOPICS(I)%STRESS)
  NULLIFY(TOPICS(I)%STRESS_TMP)
 ENDDO

 END SUBROUTINE PMANAGER_UTL_INIT

 !#####=================================================================
 SUBROUTINE PMANAGER_UTL_CLOSE()
 !#####=================================================================
 IMPLICIT NONE

 CALL WINDOWSELECT(0); CALL WMENUSETSTATE(ID_PMANAGER,2,0)
 CALL WDIALOGSELECT(ID_DPMANAGER); CALL WDIALOGHIDE()
 IF(ALLOCATED(LAYCON))DEALLOCATE(LAYCON)
  
 END SUBROUTINE PMANAGER_UTL_CLOSE
 
END MODULE MOD_PMANAGER_UTL