!!  Copyright (C) Stichting Deltares, 2005-2016.
!!
!!  This file is part of iMOD.
!!
!!  This program is free software: you can redistribute it and/or modify
!!  it under the terms of the GNU General Public License as published by
!!  the Free Software Foundation, either version 3 of the License, or
!!  (at your option) any later version.
!!
!!  This program is distributed in the hope that it will be useful,
!!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!  GNU General Public License for more details.
!!
!!  You should have received a copy of the GNU General Public License
!!  along with this program.  If not, see <http://www.gnu.org/licenses/>.
!!
!!  Contact: imod.support@deltares.nl
!!  Stichting Deltares
!!  P.O. Box 177
!!  2600 MH Delft, The Netherlands.

MODULE MOD_IMPORT_UTL

USE WINTERACTER
USE MOD_UTL, ONLY : UTL_CAP,ITOS,UTL_GETUNIT,UTL_CREATEDIR,UTL_JDATETOIDATE,UTL_MESSAGEHANDLE
USE MOD_IDF_PAR, ONLY : IDFOBJ
USE MOD_IDF, ONLY : IDFWRITE
USE MOD_OSD, ONLY : OSD_OPEN
USE MOD_IMPORT_PAR

TYPE PACKAGE_TYPE
 INTEGER :: ILAY,IROW,ICOL
 REAL,DIMENSION(10) :: X
END TYPE PACKAGE_TYPE
TYPE(PACKAGE_TYPE),ALLOCATABLE,DIMENSION(:) :: XP

CHARACTER(LEN=256),PRIVATE :: LINE

CONTAINS

 !###====================================================================
 LOGICAL FUNCTION IMPORT_ALLOCATE_XP(N)
 !###====================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: N
 INTEGER :: IOS
 
 IMPORT_ALLOCATE_XP=.FALSE.
 
 IF(ALLOCATED(XP))CALL IMPORT_DEALLOCATE_XP()
 ALLOCATE(XP(N),STAT=IOS)
 IF(IOS.NE.0)THEN
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Cannot allocate memory for XP()','Error')
  RETURN
 ENDIF
 
 IMPORT_ALLOCATE_XP=.TRUE.
 
 END FUNCTION
 
 !###====================================================================
 SUBROUTINE IMPORT_DEALLOCATE_XP()
 !###====================================================================
 IMPLICIT NONE
 
 IF(.NOT.ALLOCATED(XP))RETURN
 DEALLOCATE(XP)
 
 END SUBROUTINE IMPORT_DEALLOCATE_XP

 !###====================================================================
 LOGICAL FUNCTION IMPORT_GETNUMBER(IU,N,MVERSION)
 !###====================================================================
 IMPLICIT NONE
 INTEGER,INTENT(INOUT) :: IU
 INTEGER,INTENT(IN) :: MVERSION
 INTEGER,INTENT(OUT) :: N
 INTEGER :: IOS
 CHARACTER(LEN=4) :: FRMT
 CHARACTER(LEN=256) :: FNAME,LINE

 IMPORT_GETNUMBER=.FALSE.
 
 IF(MVERSION.EQ.2005)THEN
  READ(IU,*,IOSTAT=IOS) N
 ELSE
  DO  
   READ(IU,'(A256)',IOSTAT=IOS) LINE
   IF(IOS.NE.0)THEN
    CALL IMPORT_ERROR('Error reading package: end of file!',IOS,ABS(IU))
    RETURN
   ENDIF
   IF(LINE(1:1).NE.'#')EXIT
  ENDDO
  IF(FREEFORMATTED)READ(LINE,*,IOSTAT=IOS) N
  IF(.NOT.FREEFORMATTED)READ(LINE,'(I10)',IOSTAT=IOS) N
  IF(IOS.NE.0)THEN
   READ(LINE,*,IOSTAT=IOS) FRMT
   IF(UTL_CAP(ADJUSTL(FRMT),'U').EQ.'FILE')THEN
    READ(IU,*,IOSTAT=IOS) FNAME
    IU=UTL_GETUNIT()
    CALL OSD_OPEN(IU,FILE=FNAME,STATUS='OLD',ACTION='READ,DENYWRITE')
    READ(IU,*,IOSTAT=IOS)
    READ(IU,'(I10)',IOSTAT=IOS) N
    IU=-1*IU
   ELSE
    CALL IMPORT_ERROR('Error reading package',1,IU)
    RETURN
   ENDIF
  ENDIF
 ENDIF

 IF(IOS.NE.0)THEN
  CALL IMPORT_ERROR('Error reading package',IOS,ABS(IU))
  RETURN
 ENDIF
 
 IMPORT_GETNUMBER=.TRUE.
 
 END FUNCTION IMPORT_GETNUMBER

 !###====================================================================
 SUBROUTINE IMPORT_ERROR(TXT,I,IFILE)
 !###====================================================================
 IMPLICIT NONE
 INTEGER,INTENT(IN) :: I,IFILE
 CHARACTER(LEN=*),INTENT(IN) :: TXT

 IF(IFILE.NE.0)THEN
  INQUIRE(UNIT=IFILE,NAME=LINE)
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Error message:'//CHAR(13)//TRIM(TXT)//CHAR(13)//CHAR(13)// &
   'within file:'//CHAR(13)//TRIM(LINE)//CHAR(13)//'IOSTAT Error Code= '//TRIM(ITOS(I)),'Error')
 ELSE
  CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Error message:'//CHAR(13)//TRIM(TXT)//CHAR(13)// &
    'IOSTAT Error Code= '//TRIM(ITOS(I)),'Error')
 ENDIF
 CALL UTL_MESSAGEHANDLE(1)

 END SUBROUTINE IMPORT_ERROR

 !###====================================================================
 FUNCTION IMPORT_READPACKAGE(IU,N,M,TXT,MVERSION,F)
 !###====================================================================
 IMPLICIT NONE
 LOGICAL :: IMPORT_READPACKAGE
 CHARACTER(LEN=*),INTENT(IN) :: TXT
 REAL,INTENT(IN),DIMENSION(:) :: F
 INTEGER,INTENT(IN) :: N,M,IU,MVERSION
 INTEGER :: I,J,IOS
 CHARACTER(LEN=20) :: FRM
 
 IMPORT_READPACKAGE=.FALSE.
 
 WRITE(FRM,'(A6,I2.2,A6)') '(3I10,',M,'F10.0)'

 DO I=1,N
  IF(IU.LT.0.OR.MVERSION.NE.1988)THEN
   IF(FREEFORMATTED)THEN
    READ(ABS(IU),*,IOSTAT=IOS) XP(I)%ILAY,XP(I)%IROW,XP(I)%ICOL,(XP(I)%X(J),J=1,M)
   ELSE
    READ(ABS(IU),FRM,IOSTAT=IOS) XP(I)%ILAY,XP(I)%IROW,XP(I)%ICOL,(XP(I)%X(J),J=1,M)
   ENDIF
  ELSE
   READ(ABS(IU),FRM,IOSTAT=IOS) XP(I)%ILAY,XP(I)%IROW,XP(I)%ICOL,(XP(I)%X(J),J=1,M)
  ENDIF
  DO J=1,M; XP(I)%X(J)=F(J)*XP(I)%X(J); ENDDO
  IF(IOS.NE.0)THEN
   CALL IMPORT_ERROR('Error reading package info (record '//TRIM(ITOS(I))//') for '//TRIM(TXT)//CHAR(13)// &
   'Stressperiod '//TRIM(ITOS(IPER)),IOS,ABS(IU))
   RETURN
  ENDIF
 END DO

 IMPORT_READPACKAGE=.TRUE.

 END FUNCTION IMPORT_READPACKAGE

 !###====================================================================
 LOGICAL FUNCTION IMPORT_READU2DREL(IU,X,NCOL,NROW,TXT)
 !###====================================================================
 IMPLICIT NONE
 CHARACTER(LEN=*),INTENT(IN) :: TXT
 INTEGER,INTENT(IN) :: NCOL,NROW,IU
 REAL,INTENT(OUT),DIMENSION(NCOL,NROW) :: X
 INTEGER :: IROW,ICOL,IOS,I,LOCAT,IUF,JU,IFILE,FREETYPE
 REAL,ALLOCATABLE,DIMENSION(:,:) :: IX
 REAL :: CNSTNT
 CHARACTER(LEN=20) :: TEXT,FMTIN
 CHARACTER(LEN=256) :: FNAME

 IMPORT_READU2DREL=.FALSE.

 ALLOCATE(IX(NCOL,NROW))

 IF(FREEFORMATTED)THEN
 
  !## number of freeformatted type
  FREETYPE=0
  
  READ(IU,'(A256)') LINE
  I=INDEX(UTL_CAP(LINE,'U'),'CONSTANT')
  IF(I.GT.0)THEN
   READ(LINE(I+8:),*,IOSTAT=IOS) CNSTNT
   IF(IOS.NE.0)THEN
    CALL IMPORT_ERROR('Error reading CNSTNT',IOS,IU)
    RETURN
   ENDIF
   LOCAT=0
   FREETYPE=1
  ENDIF

  !## internal data stored
  I=INDEX(UTL_CAP(LINE,'U'),'INTERNAL')
  IF(I.GT.0)THEN
   READ(LINE,*,IOSTAT=IOS) TEXT,CNSTNT,FMTIN
   IF(IOS.NE.0)THEN
    CALL IMPORT_ERROR('Error reading TEXT(INTERNAL),CNSTNT,FMTIN',IOS,IU)
    RETURN
   ENDIF
   IF(UTL_CAP(FMTIN,'U').EQ.'(FREE)')FMTIN='*'
   FMTIN=ADJUSTL(FMTIN); LOCAT=1; IFILE=0
   FREETYPE=2; IUF=IU
  ENDIF
 
  !## external file stored
  I=INDEX(UTL_CAP(LINE,'U'),'OPEN/CLOSE')
  IF(I.GT.0)THEN
   READ(LINE(I+11:),*,IOSTAT=IOS) FNAME,CNSTNT,FMTIN
   IF(IOS.NE.0)THEN
    CALL IMPORT_ERROR('Error reading FNAME,CNSTNT,FMTIN',IOS,IU)
    RETURN
   ENDIF
   IF(UTL_CAP(FMTIN,'U').EQ.'(FREE)')FMTIN='*'
   FMTIN=ADJUSTL(FMTIN); LOCAT=1; IFILE=1
   FREETYPE=3
  ENDIF
 
  !## external file stored (file)
  I=INDEX(UTL_CAP(LINE,'U'),'FILE')
  IF(I.GT.0)THEN
   READ(LINE,'(2I10,A20)',IOSTAT=IOS) LOCAT,CNSTNT,FMTIN
   IF(IOS.NE.0)THEN
    CALL IMPORT_ERROR('Error reading LOCAT,CNSTNT,FMTIN',IOS,IU)
    RETURN
   ENDIF
   FMTIN=ADJUSTL(FMTIN); LOCAT=1; IFILE=2
   FREETYPE=4
  ENDIF
 
  !## external file stored
  I=INDEX(UTL_CAP(LINE,'U'),'EXTERNAL')
  IF(I.GT.0)THEN
   READ(LINE(I+8:),*,IOSTAT=IOS) LOCAT,CNSTNT,FMTIN
   IF(IOS.NE.0)THEN
    CALL IMPORT_ERROR('Error reading LOCAT,CNSTNT,FMTIN',IOS,IU)
    RETURN
   ENDIF
   IF(UTL_CAP(FMTIN,'U').EQ.'(FREE)')FMTIN='*'
   FMTIN=ADJUSTL(FMTIN); IFILE=3
   FREETYPE=5
  ENDIF
 
  !## use default
  IF(FREETYPE.EQ.0)THEN
   READ(LINE,'(I10,F10.0,A20)') LOCAT,CNSTNT,FMTIN
   IFILE=0
   IUF=IU
  ENDIF
  
 ELSE

  !## number of freeformatted type
  FREETYPE=0
  
  READ(IU,'(A256)') LINE

  I=INDEX(UTL_CAP(LINE,'U'),'INTERNAL')
  IF(I.GT.0)THEN
   READ(LINE,*,IOSTAT=IOS) TEXT,CNSTNT,FMTIN
   IF(IOS.NE.0)THEN
    CALL IMPORT_ERROR('Error reading TEXT(INTERNAL),CNSTNT,FMTIN',IOS,IU)
    RETURN
   ENDIF
   FMTIN=ADJUSTL(FMTIN); LOCAT=IU; IFILE=0
   FREETYPE=1; IUF=IU
  ENDIF
  
  !## use default
  IF(FREETYPE.EQ.0)THEN
   READ(LINE,'(I10,F10.0,A20)') LOCAT,CNSTNT,FMTIN
   IFILE=0; IUF=IU
  ENDIF
  
  !## check whether external file is used
!  IUF=IU
  DO I=1,SIZE(DATAI)
   IF(DATAI(I).EQ.LOCAT)IUF=DATAI(I)
  ENDDO
  
 ENDIF

 !## unformatted input
 IF(LOCAT.LT.0)THEN
 !## constant
 ELSEIF(LOCAT.EQ.0)THEN
  X=REAL(CNSTNT)
 !## formatted input
 ELSE
  IF(IFILE.EQ.0)THEN
   IF(FMTIN.EQ.'*')THEN
    READ(IUF,*,IOSTAT=IOS) ((IX(ICOL,IROW),ICOL=1,NCOL),IROW=1,NROW)
   ELSE
    DO IROW=1,NROW
     READ(IUF,FMTIN,IOSTAT=IOS) (IX(ICOL,IROW),ICOL=1,NCOL)
    ENDDO
   ENDIF
   IF(IOS.NE.0)THEN
    CALL IMPORT_ERROR('Error reading data matrix '//TRIM(TXT),IOS,IU)
    RETURN
   ENDIF
  ELSEIF(IFILE.EQ.1.OR.IFILE.EQ.2)THEN
   !## ascii-file/datfile
   IF(IFILE.EQ.2)READ(IU,*) FNAME
   IUF=UTL_GETUNIT()
   CALL OSD_OPEN(IUF,FILE=FNAME,STATUS='OLD',ACTION='READ,DENYWRITE')
   IF(IUF.LE.0)THEN
    CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Cannot find file'//CHAR(13)// &
     TRIM(FNAME),'Error')
    RETURN
   ENDIF
   IF(IFILE.EQ.2)THEN; DO I=1,6; READ(IUF,*); END DO; ENDIF
   IF(FMTIN.EQ.'*')THEN
    READ(IUF,*,IOSTAT=IOS) ((IX(ICOL,IROW),ICOL=1,NCOL),IROW=1,NROW)
   ELSE
    DO IROW=1,NROW
     READ(IUF,FMTIN,IOSTAT=IOS) (IX(ICOL,IROW),ICOL=1,NCOL)
    ENDDO
   ENDIF
   IF(IOS.NE.0)THEN
    CALL IMPORT_ERROR('Error reading data matrix '//TRIM(TXT),IOS,IU)
    RETURN
   ENDIF
   CLOSE(IUF)
  ELSEIF(IFILE.EQ.3)THEN
   JU=IU
   IF(ALLOCATED(DATAI))THEN
    DO I=1,SIZE(DATAI)
     IF(LOCAT.EQ.DATAI(I))THEN
      JU=UTL_GETUNIT()
      CALL OSD_OPEN(JU,FILE=DATAF(I),STATUS='OLD',ACTION='READ',IOSTAT=IOS)
      IF(IOS.NE.0)THEN
       CALL IMPORT_ERROR('Cannot open file: '//TRIM(DATAF(I)),IOS,IU)
       RETURN      
      ENDIF
      EXIT
     ENDIF
    ENDDO
   ENDIF 
   DO IROW=1,NROW
    IF(FMTIN.EQ.'*')THEN
     READ(JU,*,IOSTAT=IOS) (IX(ICOL,IROW),ICOL=1,NCOL)
    ELSE
     READ(JU,FMTIN,IOSTAT=IOS) (IX(ICOL,IROW),ICOL=1,NCOL)
    ENDIF
    IF(IOS.NE.0)THEN
     CALL IMPORT_ERROR('Error reading data matrix '//TRIM(TXT),IOS,JU)
     RETURN
    ENDIF
   ENDDO
   IF(IU.NE.JU)CLOSE(JU)    
  ENDIF
  X=REAL(IX)
  IF(CNSTNT.NE.0.0)X=X*CNSTNT
 ENDIF

 DEALLOCATE(IX)

 IMPORT_READU2DREL=.TRUE.

 END FUNCTION IMPORT_READU2DREL
 
 !###====================================================================
 FUNCTION IMPORT_READU2DINT(IU,X,NCOL,NROW,TXT)
 !###====================================================================
 IMPLICIT NONE
 LOGICAL :: IMPORT_READU2DINT
 CHARACTER(LEN=*),INTENT(IN) :: TXT
 INTEGER,INTENT(IN) :: NCOL,NROW,IU
 REAL,INTENT(OUT),DIMENSION(NCOL,NROW) :: X
 INTEGER :: IROW,ICOL,IOS,I,LOCAT,CNSTNT,IUF,JU,IFILE,FREETYPE
 INTEGER,ALLOCATABLE,DIMENSION(:,:) :: IX
 CHARACTER(LEN=20) :: TEXT,FMTIN
 CHARACTER(LEN=256) :: FNAME

 IMPORT_READU2DINT=.FALSE.

 ALLOCATE(IX(NCOL,NROW))
 IF(FREEFORMATTED)THEN
 
  FREETYPE=0
 
  READ(IU,'(A256)') LINE
  I=INDEX(UTL_CAP(LINE,'U'),'CONSTANT')
  IF(I.GT.0)THEN
   READ(LINE(I+8:),*,IOSTAT=IOS) CNSTNT
   IF(IOS.NE.0)THEN
    CALL IMPORT_ERROR('Error reading CNSTNT',IOS,IU)
    RETURN
   ENDIF
   LOCAT=0
   FREETYPE=1
  ENDIF

  !## internal data stored
  I=INDEX(UTL_CAP(LINE,'U'),'INTERNAL')
  IF(I.GT.0)THEN
   READ(LINE,*,IOSTAT=IOS) TEXT,CNSTNT,FMTIN
   IF(IOS.NE.0)THEN
    CALL IMPORT_ERROR('Error reading TEXT(INTERNAL),CNSTNT,FMTIN',IOS,IU)
    RETURN
   ENDIF
   IF(UTL_CAP(FMTIN,'U').EQ.'(FREE)')FMTIN='*'
   FMTIN=ADJUSTL(FMTIN); LOCAT=1; IFILE=0
   FREETYPE=2; IUF=IU
  ENDIF
 
  !## external file stored
  I=INDEX(UTL_CAP(LINE,'U'),'OPEN/CLOSE')
  IF(I.GT.0)THEN
   READ(LINE(I+11:),*,IOSTAT=IOS) FNAME,CNSTNT,FMTIN
   IF(IOS.NE.0)THEN
    CALL IMPORT_ERROR('Error reading FNAME,CNSTNT,FMTIN',IOS,IU)
    RETURN
   ENDIF
   IF(UTL_CAP(FMTIN,'U').EQ.'(FREE)')FMTIN='*'
   FMTIN=ADJUSTL(FMTIN); LOCAT=1; IFILE=1
   FREETYPE=3
  ENDIF
 
  !## external file stored (file)
  I=INDEX(UTL_CAP(LINE,'U'),'FILE')
  IF(I.GT.0)THEN
   READ(LINE,'(2I10,A20)',IOSTAT=IOS) LOCAT,CNSTNT,FMTIN
   IF(IOS.NE.0)THEN
    CALL IMPORT_ERROR('Error reading LOCAT,CNSTNT,FMTIN',IOS,IU)
    RETURN
   ENDIF
   FMTIN=ADJUSTL(FMTIN); LOCAT=1; IFILE=2
   FREETYPE=4
  ENDIF
 
  !## external file stored
  I=INDEX(UTL_CAP(LINE,'U'),'EXTERNAL')
  IF(I.GT.0)THEN
   READ(LINE(I+8:),*,IOSTAT=IOS) LOCAT,CNSTNT,FMTIN
   IF(IOS.NE.0)THEN
    CALL IMPORT_ERROR('Error reading LOCAT,CNSTNT,FMTIN',IOS,IU)
    RETURN
   ENDIF
   IF(UTL_CAP(FMTIN,'U').EQ.'(FREE)')FMTIN='*'
   FMTIN=ADJUSTL(FMTIN); LOCAT=1; IFILE=3
   FREETYPE=5
  ENDIF

  IF(FREETYPE.EQ.0)THEN
   READ(LINE,'(2I10.0,A20)') LOCAT,CNSTNT,FMTIN
   IFILE=0
   IUF=IU  
  ENDIF
  
 ELSE
 
  READ(IU,'(2I10.0,A20)') LOCAT,CNSTNT,FMTIN
  IFILE=0
 
  !## check whether external file is used
  IUF=IU
  DO I=1,SIZE(DATAI)
   IF(DATAI(I).EQ.LOCAT)IUF=DATAI(I)
  ENDDO
 
 ENDIF

 !## unformatted input
 IF(LOCAT.LT.0)THEN
 !## constant
 ELSEIF(LOCAT.EQ.0)THEN
  X=REAL(CNSTNT)
 !## formatted input
 ELSE
  IF(IFILE.EQ.0)THEN
   IF(FMTIN.EQ.'*')THEN
    READ(IUF,*,IOSTAT=IOS) ((IX(ICOL,IROW),ICOL=1,NCOL),IROW=1,NROW)
   ELSE
    DO IROW=1,NROW
     READ(IUF,FMTIN,IOSTAT=IOS) (IX(ICOL,IROW),ICOL=1,NCOL)
    ENDDO
   ENDIF
   IF(IOS.NE.0)THEN
    CALL IMPORT_ERROR('Error reading data matrix '//TRIM(TXT),IOS,IU)
    RETURN
   ENDIF
  ELSEIF(IFILE.EQ.1.OR.IFILE.EQ.2)THEN
   !## ascii-file/datfile
   IF(IFILE.EQ.2)READ(IU,*) FNAME
   IUF=UTL_GETUNIT()
   CALL OSD_OPEN(IUF,FILE=FNAME,STATUS='OLD',ACTION='READ,DENYWRITE')
   IF(IUF.LE.0)THEN
    CALL WMESSAGEBOX(OKONLY,EXCLAMATIONICON,COMMONOK,'Cannot find file'//CHAR(13)// &
     TRIM(FNAME),'Error')
    RETURN
   ENDIF
   IF(IFILE.EQ.2)THEN; DO I=1,6; READ(IUF,*); END DO; ENDIF
   IF(FMTIN.EQ.'*')THEN
    READ(IUF,*,IOSTAT=IOS) ((IX(ICOL,IROW),ICOL=1,NCOL),IROW=1,NROW)
   ELSE
    DO IROW=1,NROW
     READ(IUF,FMTIN,IOSTAT=IOS) (IX(ICOL,IROW),ICOL=1,NCOL)
    ENDDO
   ENDIF
   IF(IOS.NE.0)THEN
    CALL IMPORT_ERROR('Error reading data matrix '//TRIM(TXT),IOS,IU)
    RETURN
   ENDIF
   CLOSE(IUF)
  ELSEIF(IFILE.EQ.3)THEN
   JU=IU
   IF(ALLOCATED(DATAI))THEN
    DO I=1,SIZE(DATAI)
     IF(LOCAT.EQ.DATAI(I))THEN
      JU=UTL_GETUNIT()
      CALL OSD_OPEN(JU,FILE=DATAF(I),STATUS='OLD',ACTION='READ',IOSTAT=IOS)
      IF(IOS.NE.0)THEN
       CALL IMPORT_ERROR('Cannot open file: '//TRIM(DATAF(I)),IOS,IU)
       RETURN      
      ENDIF
      EXIT
     ENDIF
    ENDDO
   ENDIF 
   DO IROW=1,NROW
    IF(FMTIN.EQ.'*')THEN
     READ(JU,*,IOSTAT=IOS) (IX(ICOL,IROW),ICOL=1,NCOL)
    ELSE
     READ(JU,FMTIN,IOSTAT=IOS) (IX(ICOL,IROW),ICOL=1,NCOL)
    ENDIF
    IF(IOS.NE.0)THEN
     CALL IMPORT_ERROR('Error reading data matrix '//TRIM(TXT),IOS,JU)
     RETURN
    ENDIF
   ENDDO
   IF(IU.NE.JU)CLOSE(JU)    
  ENDIF
  X=REAL(IX)
  IF(CNSTNT.NE.0.0)X=X*CNSTNT
 ENDIF

 DEALLOCATE(IX)

 IMPORT_READU2DINT=.TRUE.

 END FUNCTION IMPORT_READU2DINT

 !###======================================================================
 FUNCTION IMPORT_WRT1IPF(FNAME,N,XMIN,YMAX,NLAY,NROW,NCOL,DELR,DELC,IURUN)
 !###======================================================================
 IMPLICIT NONE
 LOGICAL :: IMPORT_WRT1IPF
 CHARACTER(LEN=*),INTENT(IN) :: FNAME
 INTEGER,INTENT(IN) :: N,NLAY,NROW,NCOL,IURUN
 REAL,INTENT(IN) :: XMIN,YMAX
 REAL,INTENT(IN),DIMENSION(NROW) :: DELC
 REAL,INTENT(IN),DIMENSION(NCOL) :: DELR
 INTEGER :: ILAY,I,IU,NP,IOS
 INTEGER,ALLOCATABLE,DIMENSION(:) :: TLAY
 REAL :: X,Y

 IMPORT_WRT1IPF=.FALSE.

 ALLOCATE(TLAY(NLAY))

 TLAY=0

 DO ILAY=1,NLAY
  I=INDEX(FNAME,'\',.TRUE.)-1
  CALL UTL_CREATEDIR(FNAME(:I))
  LINE=TRIM(FNAME)//TRIM(ITOS(ILAY))//'.IPF'
  IU=UTL_GETUNIT()
  CALL OSD_OPEN(IU,FILE=LINE,STATUS='UNKNOWN',FORM='FORMATTED',ACTION='WRITE,DENYREAD',IOSTAT=IOS)
  IF(IOS.NE.0)THEN
   CALL IMPORT_ERROR('Error creating '//TRIM(LINE),IOS,0)
   RETURN
  ENDIF
  
  IF(IBATCH.EQ.0)CALL WINDOWOUTSTATUSBAR(4,'Writing '//TRIM(LINE)//' ...')
  IF(IBATCH.EQ.1)WRITE(*,'(A)') 'Writing '//TRIM(LINE)//' ...'
  
  NP=0
  DO I=1,N
   IF(XP(I)%ILAY.EQ.ILAY.AND.XP(I)%X(1).NE.0.0)NP=NP+1
  END DO
  IF(NP.GT.0)THEN
   TLAY(ILAY)=1
   WRITE(IU,*) NP
   IF(IUNIT(IMOC).EQ.0)WRITE(IU,*) 3
   IF(IUNIT(IMOC).EQ.1)WRITE(IU,*) 4
   WRITE(IU,*) 'X-COORD.'
   WRITE(IU,*) 'Y-COORD.'
   WRITE(IU,*) 'Q(M3/DAY)'
   IF(IUNIT(IMOC).EQ.1)WRITE(IU,*) 'CONCENTRATION'
   WRITE(IU,*) '0,TXT'
   DO I=1,N
    IF(XP(I)%ILAY.EQ.ILAY.AND.XP(I)%X(1).NE.0.0)THEN
     X=XMIN+SUM(DELR(1:XP(I)%ICOL))
     Y=YMAX-SUM(DELC(1:XP(I)%IROW))
     X=X-(DELR(XP(I)%ICOL)/2.0)
     Y=Y+(DELC(XP(I)%IROW)/2.0)
     IF(IUNIT(IMOC).EQ.0)WRITE(IU,'(2(F12.2,A1), G15.7)') X,',',Y,',',XP(I)%X(1)
     IF(IUNIT(IMOC).EQ.1)WRITE(IU,'(2(F12.2,A1),2G15.7)') X,',',Y,',',XP(I)%X(1),XP(I)%X(2)
    ENDIF
   END DO
   CLOSE(IU)
  ELSE
   CLOSE(IU,STATUS='DELETE')
  ENDIF

 END DO

 LINE=TRIM(ITOS(SUM(TLAY)))//',(wel)'
 WRITE(IURUN,'(A)') '  '//TRIM(LINE)
 DO ILAY=1,NLAY
  IF(TLAY(ILAY).EQ.1)THEN
   LINE='  '//TRIM(ITOS(ILAY))//',1.0,0.0,"'//TRIM(FNAME)//TRIM(ITOS(ILAY))//'.IPF"'
   WRITE(IURUN,'(A)') TRIM(LINE)
  ENDIF
 END DO

 DEALLOCATE(TLAY)

 IMPORT_WRT1IPF=.TRUE.

 END FUNCTION IMPORT_WRT1IPF

 !###======================================================================
 LOGICAL FUNCTION IMPORT_WRT1PACKAGE(FNAME,IDF,N,M,NLAY,CPCK,CPACKAGE,NODATA,IPER,IURUN,IORDER)
 !###======================================================================
 IMPLICIT NONE
 TYPE(IDFOBJ) :: IDF
 INTEGER,INTENT(IN) :: N,M,NLAY,IPER,IURUN
 INTEGER,INTENT(IN),DIMENSION(M) :: IORDER
 CHARACTER(LEN=*),INTENT(IN) :: FNAME,CPCK
 CHARACTER(LEN=*),DIMENSION(:),INTENT(IN) :: CPACKAGE
 REAL,DIMENSION(:),INTENT(IN) :: NODATA
 INTEGER :: ILAY,I,J,NP,IS,IPCK,IROW,ICOL
 INTEGER,ALLOCATABLE,DIMENSION(:,:) :: TLAY
 REAL,DIMENSION(:,:),ALLOCATABLE :: IX

 IMPORT_WRT1PACKAGE=.FALSE.

 ALLOCATE(IX(IDF%NCOL,IDF%NROW))
 ALLOCATE(TLAY(M,NLAY))
 TLAY=0

 DO J=1,M
  IPCK=IORDER(J)
  DO ILAY=1,NLAY

   NP   =0
   IX   =0.0
   IDF%NODATA=NODATA(IPCK)
   IDF%X=IDF%NODATA
   DO I=1,N
    IF(XP(I)%ILAY.EQ.ILAY)THEN
     TLAY(J,ILAY)=1
     NP=NP+1
     ICOL=XP(I)%ICOL
     IROW=XP(I)%IROW
     IF(IX(ICOL,IROW).EQ.0.0)THEN
      IDF%X(ICOL,IROW)=XP(I)%X(IPCK)
     ELSE
      IDF%X(ICOL,IROW)=IDF%X(ICOL,IROW)+XP(I)%X(IPCK)
     ENDIF
     IX(ICOL,IROW)=IX(ICOL,IROW)+1.0
    ENDIF
   ENDDO

   !## number of systems
   IF(ISUMPCK.EQ.1.AND.NP.GT.0)TLAY(J,ILAY)=TLAY(J,ILAY)+MAXVAL(IX)-1

   IF(NP.GT.0)THEN
    I=INDEX(FNAME,'\',.TRUE.)-1
    CALL UTL_CREATEDIR(FNAME(:I))

    DO IS=1,TLAY(J,ILAY)
     LINE=TRIM(FNAME)//'_'//TRIM(CPACKAGE(IPCK))//'_'//TRIM(LONGDATE1)//'_L'//TRIM(ITOS(ILAY)) 
     !## add system number to it (if retain option is selected)
     IF(ISUMPCK.EQ.1)LINE=TRIM(LINE)//'_SYS'//TRIM(ITOS(IS))
     LINE=TRIM(LINE)//'.IDF'

     !## refill x in case retain option is selected
     IF(TLAY(J,ILAY).GT.1)THEN
      IDF%X=IDF%NODATA
      IX   =0.0
      DO I=1,N
       IF(XP(I)%ILAY.EQ.ILAY)THEN
        ICOL=XP(I)%ICOL
        IROW=XP(I)%IROW
        IX(ICOL,IROW)=IX(ICOL,IROW)+1.0
        !## get current package value for system is
        IF(IX(ICOL,IROW).EQ.IS)IDF%X(ICOL,IROW)=XP(I)%X(IPCK)
       ENDIF
      ENDDO
      !## make sure ix has maximal value one at the end!
      IX=MIN(IX,1.0)
     ELSE
      !## conductance and not usage of retain option
      IF(NODATA(IPCK).EQ.0.0)IX=MIN(IX,1.0)
     ENDIF

     DO IROW=1,IDF%NROW
      DO ICOL=1,IDF%NCOL
       IF(IX(ICOL,IROW).GT.0.0)THEN
        IDF%X(ICOL,IROW)=IDF%X(ICOL,IROW)/IX(ICOL,IROW)
       ELSE
        IDF%X(ICOL,IROW)=IDF%NODATA
       ENDIF
      END DO
     END DO
     IF(.NOT.IMPORT_WRT1IDF(LINE,IDF))THEN
      DEALLOCATE(TLAY,IX)
      RETURN
     ENDIF
    ENDDO
   ENDIF

  END DO
 END DO

 LINE='  '//TRIM(ITOS(SUM(TLAY(1,:))))//',('//TRIM(CPCK)//')'
 WRITE(IURUN,'(A)') TRIM(LINE)
 
 DO J=1,M
  IPCK=IORDER(J)
  DO ILAY=1,NLAY
   IF(TLAY(J,ILAY).GT.0)THEN
    DO IS=1,TLAY(J,ILAY)
     LINE=TRIM(FNAME)//'_'//TRIM(CPACKAGE(IPCK))//'_'//TRIM(LONGDATE1)//'_L'//TRIM(ITOS(ILAY)) 
     !## add system number to it (if retain option is selected)
     IF(ISUMPCK.EQ.1)LINE=TRIM(LINE)//'_SYS'//TRIM(ITOS(IS))
     LINE=TRIM(LINE)//'.IDF'
     LINE='  '//TRIM(ITOS(ILAY))//',1.0,0.0,"'//TRIM(LINE)//'"'
     WRITE(IURUN,'(A)') TRIM(LINE)
    ENDDO
   ENDIF
  END DO
 END DO
 !## write default infiltration factor
 IF(TRIM(CPCK).EQ.'riv'.AND.IRIV5.EQ.0)THEN
  DO ILAY=1,NLAY
   IF(TLAY(1,ILAY).GT.0)THEN
    DO IS=1,TLAY(1,ILAY)
     LINE=' '//TRIM(ITOS(ILAY))//',1.0,0.0,1.0'
     WRITE(IURUN,*) TRIM(LINE)
    ENDDO
   ENDIF
  END DO
 ENDIF

 DEALLOCATE(TLAY,IX)

 IMPORT_WRT1PACKAGE=.TRUE.

 END FUNCTION IMPORT_WRT1PACKAGE

 !###======================================================================
 FUNCTION IMPORT_WRT1IDF(FNAME,IDF)
 !###======================================================================
 IMPLICIT NONE
 LOGICAL :: IMPORT_WRT1IDF
 TYPE(IDFOBJ) :: IDF
 CHARACTER(LEN=*),INTENT(IN) :: FNAME
 INTEGER :: I

 IMPORT_WRT1IDF=.FALSE.

 I=INDEX(FNAME,'\',.TRUE.)-1
 CALL UTL_CREATEDIR(FNAME(:I))

 IF(IBATCH.EQ.0)CALL WINDOWOUTSTATUSBAR(4,'Writing '//TRIM(FNAME)//' ...')
 IF(IBATCH.EQ.1)WRITE(*,'(A)') 'Writing '//TRIM(FNAME)//' ...'
 
 !## will be written with appropriate nodata value
 IF(.NOT.IDFWRITE(IDF,FNAME,1))RETURN

 IMPORT_WRT1IDF=.TRUE.

 END FUNCTION IMPORT_WRT1IDF

END MODULE MOD_IMPORT_UTL
